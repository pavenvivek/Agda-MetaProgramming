\documentclass[sigplan,10pt]{acmart}
\settopmatter{printfolios=true,printccs=false,printacmref=false}

\usepackage{booktabs} % For formal tables
%\usepackage{breqn}


% Copyright
%\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
\setcopyright{none}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}


\acmConference[TyDe'18]{ACM SIGPLAN Workshop on Type-Driven Development}{September 27, 2018}{St. Louis, MO, USA}
\acmYear{2018}
%\acmISBN{} % \acmISBN{978-x-xxxx-xxxx-x/YY/MM}
%\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption

\usepackage{bbm}
\usepackage[greek,english]{babel}

% This handles the translation of unicode to latex:
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{autofe}
\usepackage{fixltx2e}
\usepackage{hyphenat}

\DeclareUnicodeCharacter{8988}{\ensuremath{\ulcorner}}
\DeclareUnicodeCharacter{8989}{\ensuremath{\urcorner}}
\DeclareUnicodeCharacter{8803}{\ensuremath{\overline{\equiv}}}
%\DeclareUnicodeCharacter{11820}{\ensuremath{\urcorner}}
%\DeclareUnicodeCharacter{8759}{\ensuremath{\urcorner}}

\usepackage{amsmath}
\usepackage{fancyvrb}
\usepackage[euler]{textgreek}
\usepackage{textcomp}
\usepackage{relsize}
\usepackage{mathabx}
\usepackage{amssymb}
\usepackage{mathtools}

\renewcommand{\theFancyVerbLine}{%
  \sffamily
  \textcolor[rgb]{0,0.7,0}{%
    \tiny{%
      \arabic{FancyVerbLine}%
    }
  }%
}


\begin{document}
\title{Encoding Higher Inductive Types Without Boilerplate}
                                        %% when present, will be used in
                                        %% header instead of Full Title.
%\titlenote{with title note}             %% \titlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'
%\subtitle{Automating Code Generation for Higher Inductive Types}                     %% \subtitle is optional
%\subtitlenote{with subtitle note}       %% \subtitlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{Paventhan Vivekanandan}
%\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  %\position{Position1}
  \department{School of Informatics, Computing and Engineering}  %% \department is recommended
  \institution{Indiana University Bloomington} %% \institution is required
  %\streetaddress{Street1 Address1}
  %\city{City1}
  %\state{State1}
  %\postcode{Post-Code1}
  \country{USA}                    %% \country is recommended
}
\email{pvivekan@indiana.edu}          %% \email is recommended

%% Author with two affiliations and emails.
\author{David Thrane Christiansen}
%\authornote{with author2 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
%  \position{Position2a}
  \institution{Galois, Inc.} %% \institution is required
  %\streetaddress{Street2a Address2a}
  \city{Portland}
  \state{Oregon}
  %\postcode{Post-Code2a}
  \country{USA}                   %% \country is recommended
}
\email{dtc@galois.com}         %% \email is recommended
%\affiliation{
%  \position{Position2b}
%  \department{Department2b}             %% \department is recommended
%  \institution{Institution2b}           %% \institution is required
%  \streetaddress{Street3b Address2b}
%  \city{City2b}
%  \state{State2b}
%  \postcode{Post-Code2b}
%  \country{Country2b}                   %% \country is recommended
%}
%\email{first2.last2@inst2b.org}         %% \email is recommended



% The default list of authors is too long for headers}
%\renewcommand{\shortauthors}{B. Trovato et al.}


\begin{abstract}
Higher inductive types are inductive types that include nontrivial higher-dimensional structure, represented as identifications at the type that are not reflexivity. While work proceeds on type theories with a computational interpretation of univalence and higher inductive types, it is convenient to encode these structures in more traditional type theories. However, these encodings involve a great deal of error-prone additional syntax. We present a library that uses Agda's metaprogramming facilities to automate this process, allowing higher inductive types to be specified with minimal additional syntax.
\end{abstract}

%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below. 
%
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003456.10003457.10003521.10003525</concept_id>
<concept_desc>Social and professional topics~History of programming languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~General programming languages}
\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code

\keywords{Higher inductive type, Elaboration, Elimination rules, Computation rules}

\maketitle

\section{Introduction}
\label{sec:intro}

A metaprogram is a program used to create other programs. In dependently-typed programming languages like Agda and Coq, a reflection library provides metaprogramming interfaces to support code generation for proofs and programs. Elaborator reflection \cite{David-2016}, a new paradigm for metaprogramming, provides the language users with a powerful set of interfaces for efficient code generation. An $elaborator$ is a metaprogram that converts a high-level language syntax in its abstract representation to a core language which is then type checked independently. By exposing a primitive monad to elaboration framework in Idris, Christiansen \cite{David-2016} showed how to write termination proofs for general recursive functions by automating Bove-Capretta \cite{Bove-2005} transformation, and how to generate data types matching schemas of external data sources based on Idris’s type providers \cite{David-2013}.

Agda is a proof-assistant based on Martin-Löf’s intensional type theory. Unlike Idris, which has a dedicated elaborator to convert the high-level syntax to its core language, Agda’s elaboration mechanism is a part of its type checker. Inspired by Idris’s elaborator reflection, Agda development team extended the reflection library of Agda by exposing its elaboration monad to its high-level metaprogramming instructions. The elaboration monad provides an interface to the Agda type checker through a set of primitive operations which can be used to retrieve static type information regarding various code segments. The primitive operations can also be used to build code fragments using constructs of an abstract syntax tree, and to convert an abstract syntax tree to its concrete syntax.

In this paper, we discuss metaprogramming using elaborator reflection in Agda. By using the elaboration monad, we performed code generation for the elimination and computation rules of inductive types and higher inductive types. We also automated the code generation for the boiler-plate code segment used to define the higher inductive type. We discuss the construction process in detail and introduce new metaprogramming interfaces which build the code segments using elaborator reflection. The interfaces extensively use Agda’s reflection primitives and build the abstract syntax tree of the code segments with static type information obtained using the reflection primitives. The generated code is then brought into scope by another top-level reflection primitive.

Elaborator reflection is a powerful mechanism which allows us to create more interesting metaprograms. By performing the above automation, we abstracted the difficulties involved in implementing and using inductive types and higher inductive types by automating the construction of their corresponding elimination and computation rules. We also achieved an extensive reduction in code size, and we demonstrated how to extend a language without modifying the compiler or depending on the language implementers. More specifically, we discuss the following contributions in this paper.

\begin{itemize}
\item We automate the construction of the recursion and the induction principles for inductive types with constructors taking zero arguments, one or more arguments, and the type being defined itself as an argument.

\item We discuss the automation of code generation of boiler-plate code for a higher inductive type defined inside a module. The boiler-plate code depends on a base type defined as private inside the module. The constructors of the private base type are not accessible outside the module.

\item We discuss the automation of code generation of the elimination and the computation rules for a higher inductive type with point and path constructors. We demonstrate the code generation of the reduction rules, specified as postulates, for the path constructors of the higher inductive type.

\item We discuss the automation of code generation for patch theory \cite{Angiuli-2014} implementation enriched with patches of encryption. We also examine the usage of the automation tool in a cryptography application \cite{Paventhan-2018}.
\end{itemize}

The automation tool abstracts the implementation difficulties of a higher inductive type and its recursion and induction principles. We automated the code generation of approximately 1500 lines of code of the patch theory implementation with just 70 lines of automation code. The automation code extensively uses the static type information queried from the type checker using the reflection primitives.

\section{Background}
\label{sec:sec2}

\subsection{Agda Reflection}
\label{sec:sec2.1}
Agda has a reflection library that enables compile time meta-programming. The reflection library provides an interface to the Agda type checker through a built-in type checking elaborator {\tt TC} monad. Using the reflection library and its meta-programming interface, we can convert a code fragment to its corresponding abstract syntax tree, and we can also convert the abstract representation back to its concrete agda code. Internally, agda translates the reflection code to a unique reflection syntax. The core library of Agda is enriched with functions supporting translations from reflection syntax to abstract syntax and from abstract syntax to concrete syntax and vice-versa. In this section, we will see usage examples for some of the primitive operations specified in the Agda reflection library which are used by the metaprogramming interfaces described in this paper. More information on the reflection library can be found in the Agda documentation \cite{Agda-doc-2017}.

In Agda, a macro is used to construct a metaprogram that executes in a {\tt Term} position. A macro is a function of type {\tt t1 → t2 → ... → Term → TC ⊤} defined inside a macro block. During a macro invocation, the last argument of type {\tt Term} is provided by the type checker, and it represents the metavariable instantiated with the result of the macro invocation. Also, the arguments of type {\tt Term} and {\tt Name} are automatically quoted. For example, consider the following macro invocation on an identity function.

%, fontsize=\relsize{-0.5}
\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = lines, rulecolor=\color{blue}, numbers = left, numbersep = 0pt]

  macro
    mc1 : Term → Term → TC ⊤
    mc1 exp hole = bindTC (quoteTC exp) 
                     (λ exp' → unify hole exp')

  sampleTerm : Term
  sampleTerm = mc1 (λ (n : Nat) → n) 

\end{Verbatim}
\endgroup
\end{center}

\normalsize

The value of {\tt sampleTerm} is as follows: 
%\begin{Verbatim}[fontsize=\relsize{-0.5},commandchars=\\\{\}]
\begin{equation} \label{eq:lam}
	lam \, visible \, (abs \, "n" \, (var \, 0 \, []))
\end{equation}

In \eqref{eq:lam}, the constructor \emph{lam} encodes the abstract representation of the identity function. The argument {\tt n} is represented as explicit and the body of the lambda function refers to {\tt n} using a de-bruijn index.   

{\tt Term} is the central type that defines an abstract syntax tree representation for the Agda terms. It is mapped to the AGDATERM built-in. The surface syntax for reflection primitives is not fixed, and so they are mapped to their corresponding built-ins, using BUILTIN pragma, to inform the type checker about the reflection concept being defined. In the above macro, the {\tt quoteTC} primitive converts a concrete agda syntax into its {\tt Term} representation. {\tt unify} performs the unification of two terms and attempts to solve any meta variables present during the unification process. {\tt bindTC} unwraps the result of {\tt (quoteTC exp)}, which is captured in {\tt exp'}, and passes it to {\tt unify} for the unification process.

The {\tt unquoteTC} primitive converts the abstract syntax tree representation of {\tt Term} into its concrete Agda syntax. The following code gives an example usage for the {\tt unquoteTC} primitive.

\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = lines, rulecolor=\color{blue}, numbers = left, numbersep = 0pt]

  macro
    mc2 : Term → Term → TC ⊤
    mc2 exp hole = bindTC (unquoteTC exp) 
                     (λ exp' → unify hole exp')

  sampleSyntax : Nat → Nat
  sampleSyntax = mc2 (lam visible (abs "n" (var 0 [])))

\end{Verbatim}
\endgroup
\end{center}

\normalsize

Macro {\tt mc2} converts the abstract representation of the identity function given by (1) to its concrete syntax. We also have a type {\tt Name}, an internal identifier mapped to a built-in type {\tt QName}. In Agda, {\tt Name} literals are created using {\tt quote} primitive.

Metaprograms to create top-level definitions are brought into scope and executed using {\tt unquoteDecl} or {\tt unquoteDef} primitive. A function of a given type is declared using {\tt declareDef}, and is later defined by {\tt defineFun}. A postulate of a given type is defined using {\tt declarePostulate}. Newly defined functions and postulates are brought into scope and executed by {\tt unquoteDecl}. The usage of {\tt declareDef}, {\tt defineFun} and {\tt unquoteDecl} is best illustrated with the following example:

\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = lines, rulecolor=\color{blue}, numbers = left, numbersep = 0pt]

  plus : Nat → Nat → Nat
  plus zero b = b
  plus (suc n) b = suc (plus n b)

\end{Verbatim}
\endgroup
\end{center}

\normalsize

The above function computes addition of two natural numbers. It can be defined using Agda reflection primitives as follows: 

\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = lines, rulecolor=\color{blue}, numbers = left, numbersep = 0pt]

   pattern vArg x = arg (arg-info visible relevant) x
   pattern _`⇒_ a b = pi (vArg a) (abs "_" b)
   pattern `Nat = def (quote Nat) []

   unquoteDecl plus =
     bindTC (declareDef (vArg plus) (`Nat `⇒ `Nat `⇒ `Nat)) λ _ → 
         defineFun plus
           (clause (vArg (con (quote zero) []) ::
                         vArg (var "y") :: [])
              (var 0 []) ::
            clause (vArg (con (quote suc)
                         (vArg (var "x") :: [])) ::
               vArg (var "y") :: [])
               (con (quote suc)
                    (vArg
                        (def plus
                           (vArg (var 1 []) ::
                            vArg (var 0 []) :: [])) :: [])) :: [])

\end{Verbatim}
\endgroup
\end{center}

\normalsize

In the above code, {\tt declareDef} declares the type of {\tt plus} using the constructor {\tt pi}, and {\tt defineFun} uses the declared type information to define the clauses for {\tt plus} using constructors {\tt con} and {\tt def}. Finally, the function {\tt plus} is brought into scope by {\tt unquoteDecl}. Terms use the de-bruijn indices to refer to the declared variables. For example, the variable {\tt y} declared at line 10 is referenced using a de-bruijn index {\tt 0} at line 11. {\tt vArg} encodes the visibility and relevance informations of the arguments to the reflection constructs.

\subsection{Higher Inductive Type}
\label{sec:sec2.2}

Type theory, a foundational language of mathematics, is a functional programming language and a theorem prover. We can view a type in type theory as a topological space in homotopy theory or a groupoid in category theory. Based on this view, elements of a type corresponds to points in a topological space and elements of an identity type corresponds to paths in a topological space. Homotopy type theory extends type theory by adding the notion of higher inductive type and univalence axiom. A higher inductive type is a general schema for defining new types using constructors for points and paths. The paths specified by a higher inductive type are realized by equivalences in the universe, and the mapping of paths to equivalences is made possible by univalence axiom \cite{HoTT-2013}.

In homotopy type theory, an element of an \emph{identity type} is used to model the notion of a path in a topological space or a morphism in a groupoid. An element of an identity type $a =_A b$ states that $a$ and $b$ are propositionally equal. In type theory, \emph{propositional equality} is a proof-relevant notion of equality, internal to the theory, expressed by identity types. We also have a proof-irrelevant notion of equality, external to the theory, known as \emph{judgmental equality} or \emph{definitional equality}. Definitional equality is used to express equality by definition. For instance, when we have a function $f : Nat \rightarrow Nat$ defined as $f(x) = x^2$ then the expression $f(3)$ is definitionally equal to $3^2$. 

A higher inductive type extends normal inductive type by providing constructors for generating paths in addition to providing constructors for generating points. For example, consider the following higher inductive type definition of $circle$ which has a point constructor $base$ and a path constructor $loop$.

\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = lines, rulecolor=\color{blue}, numbers = left, numbersep = 0pt]

  data Circle : Set where
    base : Circle         -- point constructor
    loop : base ≡ base    -- path constructor

\end{Verbatim}
\endgroup
\end{center}

\normalsize

Agda is an implementation of Martin-Löf’s intensional type theory. In Agda, we don't have built-in primitives to support the definition of higher inductive type such as {\tt Circle}. One approach is to use Agda's $Rewrite$ \cite{Agda-doc-2017} mechanism to define higher inductive types. In this approach, we define the dependent and non-dependent eliminators of a higher inductive type as paramterized modules inside which we declare the computation rules for points as rewrite rules using $\{-\# REWRITE \, ...\#-\}$ pragma. However, Agda's reflection library do not have interfaces to support introducing new pragmas and defining new modules. Another approach to define higher inductive types is to use Dan Licata's method \cite{Licata-2011}. According to this method, a higher inductive type is defined using type abstraction inside a module. The module consists of a boiler-plate code segment which defines the higher inductive type using a private base type. Inside the module, the recursion and the induction principles acts on the constructors of the private base type. The abstract type is then exported allowing the reduction rules for point constructors to hold definitionally. For example, {\tt Circle} is defined using Dan Licata's method as follows.

\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = lines, rulecolor=\color{blue}, numbers = left, numbersep = 0pt]

  module Circle where
    private
      data S* : Set where
        base* : S*

    S : Set
    S = S*

    base : S
    base = base*
	   
    postulate
      loop : base ≡ base

\end{Verbatim}
\endgroup
\end{center}

\normalsize

Inside the module {\tt Circle}, the type {\tt S} is defined using a private type {\tt S*}. The constructor {\tt base} is defined using {\tt base*} and the path {\tt loop} is given as a propositional equality. The recursion and the induction principles are defined to pattern match on the constructor {\tt base*} of the type {\tt S*}. The clients of {\tt Circle} will not have access to the constructor {\tt base*} of the private type {\tt S*} as it is not visible outside the module. The clients only way of access to the constructor is through the non-dependent and dependent elimination rules. The following code gives the non-dependent eliminator or the recursion rule {\tt recS}. 

\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = lines, rulecolor=\color{blue}, numbers = left, numbersep = 0pt]

    recS : {C : Set} → 
      (cbase : C) → 
      (cloop : cbase ≡ cbase) → 
      S → C
    recS cbase cloop base* = cbase

    postulate
      βrecS : {C : Set} → 
        (cbase : C) → 
        (cloop : cbase ≡ cbase) → 
        ap (recS cbase cloop) loop ≡ cloop

\end{Verbatim}
\endgroup
\end{center}

\normalsize
 
{\tt recS} ignores the path argument and simply computes to the appropriate answer for the point constructor. The computational behavior for the path constructor loop is postulated using reduction rule {\tt βrecS}. In the above code, the function {\tt ap} gives the action of a function $f$ on paths. The following equation gives the type of {\tt ap}. 
\begin{align} \label{eq:ap}
ap_f : (x =_A y) \rightarrow (f(x) =_A f(y))
\end{align}

The following code gives the dependent eliminator or the induction rule {\tt indS} and its computational rules.
 
\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = lines, rulecolor=\color{blue}, numbers = left, numbersep = 0pt]
 
    indS : {C : S → Set} → 
      (cbase : C base) → 
      (cloop : transport C loop cbase ≡ cbase) → 
      (circle : S) → C circle
    indS cbase cloop base* = cbase

    postulate
      βindS : {C : S → Set} → 
        (cbase : C base) →
        (cloop : transport C loop cbase ≡ cbase) → 
        apd (indS {C} cbase cloop) loop ≡ cloop

\end{Verbatim}
\endgroup
\end{center}

\normalsize
In the above code, the function {\tt apd} gives the action of dependent functions of type $f : \prod_{(x:A)}B(x)$ on paths. The following equation gives the type of {\tt apd}.
\begin{equation} \label{eq:apd}
	apd_f : \prod_{p:x=y} (p_*(f(x)) =_{B(y)} f(y))
\end{equation}
 
In \eqref{eq:apd}, the point $p_*(f(x))$ lying in space $B(y)$ can be thought of as an endpoint of a path obtained by lifting the path p from f(x) to a path in the total space $\sum_{(x:A)} B(x) \rightarrow A$. The following equation gives the type of $p*$ which is also known as $transport$ \cite{HoTT-2013}.
\begin{equation} \label{eq:transport}
	transport^B_p : B(x) \rightarrow B(y)
\end{equation}
where $p : x = y$ for $x,y : A$.

In the next section, we will see automation of code generation for normal inductive types. In section 4, we will see automation of code generation for higher inductive types, and in section 5, we will revisit patch theory \citep{Angiuli-2014} application and discuss automation of code generation for the higher inductive types defined to model Darc's version control system.

\section{Code Generation for Inductive Type}
\label{sec:sec3}
An inductive type {\tt X} is a type that is freely generated by a finite collection of constructors. The constructors of {\tt X} are functions with zero or more arguments and codomain {\tt X}. The constructors can also take an element of type {\tt X} itself as an argument, but only strictly positively. In Agda reflection library, {\tt data-type} of type {\tt Definition} stores the constructors of an inductive type as a list of {\tt Name}. The type of a constructor can be retrieved by giving its {\tt Name} as an input to the {\tt getType} primitive. In the following subsections, we will discuss how to use the constructor informations to generate code for the elimination rules of an inductive type. 

\subsection{Non-dependent Eliminator}
\label{sec:sec3.1}

For an inductive type \emph{W}, with a constructor \emph{g}, the recursion principle says that to define a mapping $f : W \rightarrow P$, it suffices to define the action of \emph{f} on input \emph{g}. For example, the recursion principle for {\tt Nat} says that a mapping {\tt f : Nat → P} can be given by defining the action of {\tt f} on the constructors {\tt zero} and {\tt (suc x)} for {\tt x : Nat}. 

The constructor \emph{g} can take zero or more arguments including an element of the type \emph{W}. Lets define the type of \emph{g} as follows.
\begin{equation}
g : (A \rightarrow W) \rightarrow B \rightarrow W \rightarrow W \nonumber
\end{equation}

To define the action of \emph{f} on input \emph{g}, we need a function \emph{d} of the following type.
\begin{equation}
d : (A \rightarrow W) \rightarrow (A \rightarrow P) \rightarrow B \rightarrow W \rightarrow P \rightarrow P \nonumber
\end{equation}

The function \emph{f} will map the constructor $g$ to $d$. To construct the type of the recursion rule for \emph{W}, we need to build the type of $d$. We can retrieve the static type information of \emph{g} using reflection primitives, and use that to construct the type of \emph{d}. The constructor {\tt pi} of type {\tt Term} encodes the abstract syntax tree (AST) representation of \emph{g} (fig.~\ref{fig:ast-g}). We can retrieve and traverse the AST of \emph{g}, and add new type information into it to build a new type representing \emph{d}.

\begin{figure}
\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = single]

   (pi (vArg 
      (pi (vArg `A) (abs "_" `W)))     -- f1 : A → W
      (abs "_" (pi (vArg `B)           -- B
      (abs "_" (pi (vArg `W)           -- W
      (abs "_" `W))))))                -- W

\end{Verbatim}
\endgroup
\end{center}
\caption{Abstract syntax tree for constructor $g$}
\label{fig:ast-g}
\end{figure}

\normalsize

During the traversal of the abstract syntax tree of $g$, when we identify a function {\tt f1} with codomain \emph{W}, we add a new function {\tt f2}, with the same arguments as {\tt f1} and codomain \emph{P}, to the tree. For example, in figure~\ref{fig:ast-g}, a new function is built from the first argument $A \rightarrow W$ by modifying the codomain \emph{W} to \emph{P}. The new function of type $A \rightarrow P$ is added after the function $A \rightarrow W$ as in figure~\ref{fig:ast-d}. Constant types require no modifications. Therefore, we copy \emph{B} into the new type without any changes. When the type \emph{W} occurs directly in a non-codomain position, we add the type \emph{P} next to it. Finally, we change the codomain \emph{W} of $g$ to \emph{P} resulting in an abstract syntax tree representation of $d$ (fig.~\ref{fig:ast-d}). We repeat this process for all the constructors of a given type. In the case of {\tt Nat}, we construct the output types for {\tt zero} and {\tt (suc x)} for {\tt x : Nat} using the above method.


\begin{figure}
\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = single]

   (pi (vArg 
      (pi (vArg `A) (abs "_" `W)))      -- f1 : A → W
      (abs "_" (pi (vArg 
      (pi (vArg `A) (abs "_" `P)))      -- f2 : A → P
      (abs "_" (pi (vArg `B)            -- B
      (abs "_" (pi (vArg `W)            -- W
      (abs "_" (pi (vArg `P)            -- P
      (abs "_" `P))))))))))             -- P

\end{Verbatim}
\endgroup
\end{center}
\caption{Abstract syntax tree for constructor $d$}
\label{fig:ast-d}
\end{figure}

\normalsize

The parameter and the index of \emph{W}, if present, should be encoded as part of the type of function \emph{f}. We can retrieve information about the parameter and the index of \emph{W} from its type. The constructors refer to the parameter and the index using de-bruijn indices. During the construction of the output type $d$, we should update the de-bruijn indices accordingly. The constructor {\tt data-type} contains the count \emph{cp} of parameters occurring in a defined type. It also encodes the constructors of the type as a list of {\tt Name}. We can retrieve the index count by finding the difference between \emph{cp} and length of the constructor list. The parameters are common to all the constructors of a type. But the index values are different for each constructor. So we have to encode unique indices for each constructor. Also, some constructors might not take the same number of indices as the parent type. For example, in the case of {\tt Vec}, the constructor {\tt []} excludes the index {\tt Nat} from its type. We do not have any reflection primitive to retrieve the index count from a constructor name. A workaround is to pass the index count of each constructor explicitly to the automation tool.

Once we have the type of $d$, we can build the type of the recursion rule for \emph{W}. To encode the mapping $W \rightarrow P$ in the recursion type we need to declare \emph{P}. We can use the constructor {\tt agda-sort} to introduce the type \emph{(P : Set)}. The type of the recursion rule \emph{f} is given as follows.
\begin{align}
& f : (P : Set) \rightarrow  \nonumber \\
& \hspace {0.5cm} (d : (A \rightarrow W) \rightarrow (A \rightarrow P) \rightarrow B \rightarrow W \rightarrow P \rightarrow P) \rightarrow \nonumber \\  
& \hspace {0.5cm} W \rightarrow P \nonumber
\end{align}
 
The above type is declared using {\tt declareDef}. We can build the computation rule representing the action of function \emph{f} on $d$ using {\tt clause} (fig.~\ref{fig:ast-cdef}). The first argument to {\tt clause} encodes variables corresponding to the above type, and it also includes the abstract representation of $g$ on which the pattern matching should occur. The second argument to clause, which is of type {\tt Term}, refers to the variables in the first argument using de-bruijn indices, and it encodes the output of the action of function \emph{f} on $d$. The constructor {\tt var} in {\tt Pattern} is used to introduce new variables in the {\tt clause} definition. The type {\tt Pattern} also has another constructor {\tt con} used to represent the pattern matching term $g$. The type {\tt Term} has similar constructors {\tt var} and {\tt con}, but with different types, used to encode the output of the recursion rule. Given $\alpha : A \rightarrow W$, $\beta : B$ and $\omega : W$, the computation rule corresponding to the above type is given as follows.
\begin{equation}
f (P, d, g (\alpha, \beta, \omega)) \equiv d (\alpha, f \circ \alpha, \beta, \omega, f (\omega)) \nonumber
\end{equation}

\begin{figure}
\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = single]

  (clause 
    (vArg (var "P") ::                           -- P
     vArg (var "d") ::                           -- d
     vArg (con (quote g)                         -- g
            (vArg (var "alpha") ::               -- α
             vArg (var "beta") ::                -- β
             vArg (var "omega") :: [])) :: [])   -- ω
    (var 3                                       -- d
      (vArg (var 2 []) ::                        -- α
       vArg (lam visible (abs "a"                -- a
         (def f                                  -- f ∘ α
           (vArg (var 3                     
           (vArg (var 0 []) :: [])) :: []))) ::
       vArg (var 1 []) ::                        -- β
       vArg (var 0 []) ::                        -- ω
       vArg (def f (vArg (var 0 []) :: [])))))   -- f(ω)

\end{Verbatim}
\endgroup
\end{center}
\caption{Clause definition for the computation rule of \emph{W}}
\label{fig:ast-cdef}
\end{figure}

\normalsize

The second argument $(f \circ \alpha)$ to $d$ is the composite of function $f$ and $\alpha$. We can build a composite function inside a lambda using the constructor {\tt lam}. The arguments to {\tt lam} are referenced using de-bruijn indices inside the lambda body. So, the de-bruijn indices for referring variables outside the lambda body are updated accordingly. The clause definition, which evaluates to the above computation rule of \emph{W}, is given in figure~\ref{fig:ast-cdef}. The de-bruijn index reference increments right to left starting from the last argument $\omega$. Inside the lambda body, the reference {\tt 0} refers to the lambda argument {\tt a}, and the index references to the variables outside the lambda body starts from 1 and increments towards the left. The above clause definition is defined using {\tt defineFun} primitive, and the function \emph{f} is brought into scope by {\tt unquotedecl}. 

In the automation tool, {\tt generateRec} interface is used to generate the resursion rule $f$ for the type $W$. The implementation of {\tt generateRec} is given as follows.

\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = lines, rulecolor=\color{blue}, numbers = left, numbersep = 0pt]

  generateRec : Arg Name → Name → List Nat → TC ⊤
  generateRec (arg i f) t indLs =
    bindTC (getConstructors t) λ cns →
    bindTC (getLength cns) λ lcons →
    bindTC (getClause lcons zero t f indLs cns) λ cls →
    bindTC (getType t) λ RTy → 
    bindTC (getRtype t indLs zero RTy) λ funType →
    bindTC (declareDef (arg i f) funType) λ _ →
    (defineFun f cls)

\end{Verbatim}
\endgroup
\end{center}

\normalsize

{\tt generateRec} uses {\tt getClause} and {\tt getRtype} to build the computation and elimination rules respectively. It takes three arguments which consists of the function name to be defined as an element of type {\tt Arg Name}, the quoted {\tt Name} of the type \emph{W} and a list containing the index count of the individual constructors. {\tt generateRec} can be used to automate the generation of recursion rules for the inductive types with point constructors. It can be used with the constructors of inductive types that takes no arguments (eg. {\tt Bool}), one or multiple arguments (eg. coproduct, cartesian product) and the constructors that takes argument from the inductive type being defined (eg. {\tt Nat}, {\tt List}, {\tt Vec}). The recursion rule generated by {\tt generateRec} is brought into scope using {\tt unquoteDecl} as follows.

\begin{center}
\begingroup
\fontsize{8pt}{9pt}\selectfont
\begin{Verbatim}

  unquoteDecl f = generateRec (vArg f) (quote W) (0 :: [])

\end{Verbatim}
\endgroup
\end{center}

\normalsize

The third argument to {\tt generateRec} is a list consisting of the index count for the constructors. Since the constructor $g$ does not have any index, the count is given as 0. It is required to pass the index count for each constructor explicitly as the Agda reflection library does not have built-in primitives to retrieve the index value.

\subsection{Dependent Eliminator}
\label{sec:sec3.2}

The dependent eliminator or the induction principle is used to define the behavior of a mapping $f'$ when the output type is dependent on the input element to $f'$. For the inductive type $W$, the induction principle says that to define a mapping $f' : (w : W) \rightarrow P(w)$, it suffices to define the action of $f'$ on $g$. To define the action of $f'$ on $g$, we need an element of the following type.
\begin{equation}
d' : \prod_{\alpha : A \rightarrow W} (\prod_{a : A} P(\alpha (a))) \rightarrow  \prod_{\beta : B} \prod_{\omega : W} P(\omega) \rightarrow P (g(\alpha, \beta, \omega)) \nonumber
\end{equation}

In the first argument of $d'$, the type $P$ depends on the action of the function $\alpha$ on input $a : A$. In the second argument, it depends on the input element $\omega : W$. The output of function $d'$ depends on the action of constructor $g$ on inputs $\alpha$, $\beta$, and $\omega$. 

To build the dependent eliminator, we need the type of the function $d'$. We can construct the abstract syntax tree of $d'$ using the static type information obtained from $g$. To construct $d'$, during the traversal of the abstract syntax tree of $g$, when we identify a function $\alpha$ with codomain \emph{W}, we add a new function with the same argument {\tt A} as in $\alpha$ and codomain \emph{P}, which depends on the action of $\alpha$ on {\tt (a : A)}. We copy the constant \emph{B} directly without any changes as in the case of the non-dependant eliminator. When we see $(\omega : W)$ in a non-codomain position, we add the type \emph{P}, which depends on the element $\omega$, next to it. Finally, the output type \emph{W} of the constructor $g$ is changed to \emph{P}, which depends on the action of the constructor $g$ on inputs $\alpha$, $\beta$ and $\omega$ (fig.~\ref{fig:ast-d'}). 

\begin{figure}
\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = single]

   (pi (vArg
      (pi (vArg `A) (abs "_" `W)))                -- α : A → W
      (abs "_" (pi (vArg                          -- A → P(α(a))
      (pi (vArg `A)                               -- a : A
      (abs "_" (var 2                             -- P(α(a))
      (vArg (var 1                                -- α ref
      (vArg (var 0 []) :: [])) :: [])))))         -- a ref
      (abs "_" (pi (vArg `B)                      -- β : B
      (abs "_" (pi (vArg `W)                      -- ω : W
      (abs "_" (pi (vArg (var 4                   -- P(ω)
      (vArg (var 0 []) :: [])))                   -- ω ref
      (abs "_" (var 5                             -- P(g i β ω)
      (vArg (con (quote g)                        -- g ref
      (vArg (var 4 []) ::                         -- α ref
       vArg (var 2 []) ::                         -- β ref
       vArg (var 1 []) :: [])) :: []))))))))))))  -- ω ref

\end{Verbatim}
\endgroup
\end{center}
\caption{Abstract syntax tree for constructor $d'$}
\label{fig:ast-d'}
\end{figure}

\normalsize

We can construct the type of the induction principle $f'$ using $d'$ . The type \emph{P} in the mapping $f'$ depends on the element of the input type \emph{W}. The following equation gives the type of the induction principle $f'$.
\begin{align}
& f' : (P : W \rightarrow Set) \rightarrow \nonumber \\
& \hspace {0.6cm} (d' : \prod_{\alpha : A \rightarrow W} (\prod_{a : A} P(\alpha (a))) \rightarrow \prod_{\beta : B} \prod_{\omega : W} P(\omega) \rightarrow \nonumber \\ 
& \hspace {1.6cm} P (g(\alpha, \beta, \omega))) \rightarrow \nonumber \\
& \hspace {0.6cm} (w : W) \rightarrow P (w) \nonumber
\end{align}

The computation rule corresponding to the above type is the same as the computation rule of the recursion principle of \emph{W} except that the function \emph{f} and $d$ are changed to \emph{f'} and $d'$ respectively. It is constructed using {\tt clause} definitions following the same approach as the recursion principle. The computation rule corresponding to \emph{f'} is given as follows.
\begin{equation}
f' (P, d', g (\alpha, \beta, \omega)) \equiv d' (\alpha, f' \circ \alpha, \beta, \omega, f' (\omega)) \nonumber
\end{equation}

We can automate the generation of the induction rule $f'$ and its corresponding computation rules for the type \emph{W} using {\tt generateInd} interface. The following code gives the implementation of {\tt generateInd}.

\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = lines, rulecolor=\color{blue}, numbers = left, numbersep = 0pt]

  generateInd : Arg Name → Name → List Nat → TC ⊤
  generateInd (arg i f) t indLs =
    bindTC (getIndex t indLs) λ indLs' →
    bindTC (getConstructors t) λ cns →
    bindTC (getLength cns) λ lcons →
    bindTC (getClauseDep lcons zero t f indLs' cns) λ cls →
    bindTC (getType t) λ RTy →
    bindTC (getRtypeInd t zero indLs' RTy) λ funType → 
    bindTC (declareDef (arg i f) funType) λ _ →
    (defineFun f cls)

\end{Verbatim}
\endgroup
\end{center}

\normalsize

{\tt generateInd} uses {\tt getClauseDep} to generate the {\tt clause} definitions representing the computation rule of the type \emph{W}. The abstract representation of the type of \emph{W} is provided by {\tt getRtypeInd}. $f'$ generated by {\tt generateInd} is brought into scope by {\tt unquoteDecl} as follows.
\begin{center}
\begingroup
\fontsize{8pt}{9pt}\selectfont
\begin{Verbatim}

  unquoteDecl f' = generateInd (vArg f') (quote W) [] 

\end{Verbatim}
\endgroup
\end{center}
\normalsize

We pass an empty list to {\tt generateInd} as the type \emph{W} has no index. We can also pass an empty list if all the constructors of a type has the same number of index as the parent type. But if any one constructor has an index count different from the index count of the parent type, then we have to explicitly pass the index count of all the constructors.

\section{Code Generation for Higher Inductive Type}
\label{sec:sec4}

In Agda, there are no built-in primitives to support the definition of higher inductive types. However, we can still define a higher inductive type with a base type using Dan Licata's \citep{Licata-2011} method as discussed in section 2.1. In this section, we discuss the automation of code generation for the boiler-plate code segments defining the higher inductive type. We also describe how to automate the code generation for the elimination and the computation rules of the higher inductive type using static type information obtained from the base type.


\subsection{Higher Inductive Type Definition}
\label{sec:sec4.1}

In Agda, we define an inductive type using {\tt data} keyword. The {\tt data} literal characterize a data type by declaring its type and specifying its constructors. Consider the following generic form for the definition of an inductive type \emph{W} with constructors $g_1 \ldots g_n$. 
\begin{center}
\begingroup
\fontsize{7.9pt}{0pt}\selectfont
\begin{align}
& data \hspace{0.2cm} W^* \hspace{0.2cm} (x_1:P_1)\ldots(x_n:P_n) : Q_1 \rightarrow\ldots\rightarrow Q_n \rightarrow Set \, \ell \, \, where \nonumber \\
& \hspace{0.3cm} g_1^* : \{i_1 : Q_1\} \ldots \{i_n : Q_n\} \rightarrow Type_1\rightarrow W^* x_1 \ldots x_n \, i_1 \ldots i_n \nonumber \\
& \hspace{3.5cm} \vdots \nonumber \\ 
& \hspace{0.3cm} g_n^* : \{j_1 : Q_1\} \ldots \{j_n : Q_n\} \rightarrow Type_n\rightarrow W^* x_1 \dots x_n \, j_1 \ldots j_n \nonumber \\ \nonumber
\end{align}
\endgroup
\end{center}
\normalsize

The parameters $(x_1:P_1)\ldots(x_n:P_n)$ are common to all the constructors, and the type of each constructor implicitly encodes the parameter references. However, the indices are different for each constructor. So, the type of each constructor explicitly exhibits the index declaration. During the construction of a higher inductive type, we have to represent the parameters and the indices as explicit arguments in the type of the constructors. We define a higher inductive type $W$ as a top-level definition using a base type $W^*$ similar to the module {\tt Circle} in section 2.1. The reflection type {\tt Definition} provides us the type and the constructors of the base type $W^*$. We copy the type of $W^*$ to $W$ and for the constructors $g_1 \ldots g_n$ of $W$, we traverse the abstract representation of the type of $g_1^* \ldots g_n^*$ respectively replacing the occurrence of $W^*$ to $W$ in every strict positive position. Consider a constructor $g_i^*$ having the following type.
\begin{equation}
g_i^* : (A \rightarrow W^*) \rightarrow (B \rightarrow W^*) \rightarrow C \rightarrow W^* \rightarrow W^* \nonumber
\end{equation}

We built the type of $g_i$ by traversing the abstract syntax tree of $g_i^*$ and replacing the base type $W^*$ with the higher inductive type $W$. The abstract syntax tree of $g_i^*$ incorporates the type of the parameters and the indices if present. We have to retain the parameters and the indices explicitly during the construction of $g_i$. The following equation represents the type of the constructor $g_i$.
\begin{equation}
g_i : (A \rightarrow W) \rightarrow (B \rightarrow W) \rightarrow C \rightarrow W \rightarrow W \nonumber
\end{equation}

We explicitly pass the type of the path constructors to the automation tool. The higher inductive type definition of {\tt Circle} in section 2.1 represents the path constructors as propositional equalities. The automation tool takes the path types as input and declares them as propositional equalities using the reflection primitive {\tt declarePostulate}. We introduce a new data type {\tt ArgPath} to input the path types to the automation tool. 
\begin{center}
\begingroup
\fontsize{7.9pt}{0pt}\selectfont
\begin{align}
& data \hspace {0.1cm} ArgPath \hspace {0.1cm} \{\ell_1\} : Set \hspace {0.1cm} (lsuc \hspace {0.1cm} \ell_1) \hspace {0.1cm} where \nonumber \\
& \hspace {0.4cm} argPath : Set \hspace {0.1cm} \ell_1 \rightarrow ArgPath \nonumber \\ \nonumber
\end{align}
\endgroup
\end{center}
\normalsize

The constructor $argPath$ takes the type of a path constructor as input. We define the generic form of a higher inductive type as follows.
\begin{center}
\begingroup
\fontsize{7.9pt}{0pt}\selectfont
\begin{align}
& data{\text -}hit \hspace {0.1cm} (quote \hspace {0.1cm} W^*) \hspace {0.1cm} W \nonumber \\
  & \hspace {0.3cm} Wpoints \hspace {0.2cm} (g_1 ::  \ldots :: g_n :: []) \nonumber \\
  & \hspace {0.3cm} Wpaths  \hspace {0.2cm} (p_1 :: \ldots :: p_n :: []) \nonumber \\
  & \hspace {0.3cm} (argPath \nonumber \\ 
  & \hspace {0.6cm} (\{x_1:P_1\} \rightarrow \ldots \rightarrow \{x_n:P_n\} \rightarrow \nonumber \\ 
  & \hspace {0.7cm} \{i_1:Q_1\} \rightarrow \ldots \rightarrow \{i_n:Q_n\} \rightarrow Type_1 \rightarrow \nonumber \\ 
  & \hspace {0.7cm} (g_i \{x_1\} \ldots \{x_n\} \{i_1\} \ldots \{i_n\} \ldots) \equiv (g_j \ldots)) :: \nonumber \\
  & \hspace {3cm} \vdots \nonumber \\
  & \hspace {0.4cm} argPath \nonumber \\ 
  & \hspace {0.6cm} (\{x_1:P_1\} \rightarrow \ldots \rightarrow \{x_n:P_n\} \rightarrow \nonumber \\ 
  & \hspace {0.7cm} \{j_1:Q_1\} \rightarrow \ldots \rightarrow \{j_n:Q_n\} \rightarrow Type_n \rightarrow \nonumber \\ 
  & \hspace {0.7cm} (g_i \{x_1\} \ldots \{x_n\} \{j_1\} \ldots \{j_n\} \ldots) \equiv (g_j \ldots)) :: [])\nonumber \\ \nonumber
\end{align}
\endgroup
\end{center}
\normalsize

We define holders $Wpoints$ for point constructors and $Wpaths$ for path constructors as part of the higher inductive type definition of $W$. We cannot retrieve the constructors of the higher inductive type $W$ using {\tt Definition}. Therefore, $Wpoints$ and $Wpaths$ act as the only references for the constructors of $W$. The elements of the $argPath$ list represent the type of the path constructors $p_1 \ldots p_n$ respectively. We explicitly include the parameter references $\{x_1 : P_1\} \ldots \{x_n : P_n\}$ and the index references $\{k_1 : Q_1\} \ldots \{k_n : Q_n\}$ in the type of the arguments to $argPath$. The points $g_1 \ldots g_n$ are not in scope when used in the identity type passed to $argPath$. The automation tool uses the base type constructors $g_1^* \ldots g_n^*$ as dummy arguments in the place of $g_1 \ldots g_n$ respectively. The automation tool implements the interface {\tt data-hit} as follows.

\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = lines, rulecolor=\color{blue}, numbers = left, numbersep = 0pt]

  data-hit : ∀{ℓ₁} (baseType : Name) → (indType : Name) → 
    (pointHolder : Name) → (lcons : List Name) → 
    (pathHolder : Name) → (lpaths : List Name) →
    (lpathTypes : (List (ArgPath {ℓ₁}))) → TC ⊤
  data-hit base ind pointH lcons pathH lpaths lpathTypes =
    bindTC (defineHindType base ind) λ _ → 
    bindTC (getConstructors base) λ lcons'  →
    bindTC (defineHitCons base ind lcons' lcons) λ _ →
    bindTC (getPathTypes base ind lcons' lcons lpathTypes) λ lp →
    bindTC (defineHitPathCons lpaths lp) λ _ →
    bindTC (definePointHolder pointHolder lcons) λ _ →
    definePathHolder pathHolder lpaths

\end{Verbatim}
\endgroup
\end{center}

The higher inductive type $W$, the points $g_1 \ldots g_n$, the paths $p_1 \ldots p_n$, and the holders $Wpoints$ and $Wpaths$ are brought into scope by {\tt unquoteDecl}. In the above implementation of {\tt data-hit}, {\tt defineHindType} defines the higher inductive type as a top-level definition using the base type. {\tt defineHitCons} specifies the point constructors of the higher inductive type using the type information obtained from the constructors of the base type, and {\tt defineHitPathCons} builds the paths constructors of the higher inductive type using the {\tt argPath} list. The following code automates the generation of the higher inductive type definition for {\tt Circle} given in section 2.1.
\begin{center}
\begingroup
\fontsize{8pt}{9pt}\selectfont
\begin{Verbatim}

  unquoteDecl S Spoints base Spaths loop = 
    data-hit (quote S*) S
      Spoints (base :: []) -- point constructors
      Spaths (loop :: [])  -- path constructors
      (argPath (base* ≡ base*) :: []) -- base replaces base*

\end{Verbatim}
\endgroup
\end{center}

The identity type input {\tt (base* ≡ base*)} to argPath represents the type of the path {\tt loop}, and it uses the inductive type constructor {\tt base*} as a dummy argument in the place of the higher inductive type constructor {\tt base}. The constructor {\tt base} comes into scope only during the execution of {\tt unquoteDecl}, and so cannot be used in the identity type reference in {\tt argPath}. We use the constructor {\tt base*} of type {\tt S*} as dummy argument because the type of {\tt base*} is similar to {\tt base}, and has the same references for the common arguments. The automation tool traverses the abstract syntax tree of {\tt loop} and replaces the occurrences of {\tt base*} with {\tt base}. 

\subsection{Non-dependent Eliminator}
\label{sec:sec4.2}

Non-dependent eliminator or the recursion principle of a higher inductive type $W$ maps the points and paths of $W$ to an output type $P$. Let $g_1 : A \rightarrow W$ and $g_2 : B \rightarrow W$ be the point constructors, and $l : (\alpha : A) \rightarrow (\beta : B) \rightarrow (g_1 \, \alpha) \equiv (g_2 \, \beta)$ be the path constructor of $W$. To define a mapping $f : W \rightarrow P$, we need points $d_1 : A \rightarrow P$ and $d_2 : B \rightarrow P$ and a path $h : (\alpha : A) \rightarrow (\beta : B) \rightarrow (d_1 \, \alpha) \equiv (d_2 \, \beta)$ in the space $P$. The path constructor $l$ can take arguments of any type including the higher inductive type $W$ but for simplicity we will consider only arguments of constant type.

To construct the recursion principle $f$, we need to build the type of points $d1, d2$ and path $h$. The type of $d1$ and $d2$ are built from the abstract syntax tree of points $g1$ and $g2$ respectively using the approach described in section \eqref{sec:sec3.1}. We build the type of $h$ by traversing the abstract syntax tree of $l$. During the traversal, we replace the points $g_1$ and $g_2$, which are arguments to the identity type, in the co-domain of the path $l$ by the points $d_1$ and $d_2$ respectively. In figure \eqref{fig:ast-f}, the arguments of the identity type in the abstract syntax tree of $h$ references the points $d_1$ and $d_2$ using de-bruijn index 3 and 2 respectively. We copy the other two arguments of $l$, which are of constant type $A$ and $B$, without any changes into the type of $h$.

\begin{figure}
\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = single]

   (pi (vArg (agda-sort (lit 0)))                  -- P
      (abs "P"
   (pi (vArg (pi (vArg (def (quote A) []))         -- d₁ : A → P
      (abs "_" (var 1 []))))                       -- P ref
      (abs "d₁"
   (pi (vArg (pi (vArg (def (quote B) []))         -- d₂ : B → P
      (abs "_" (var 2 []))))                       -- P ref
      (abs "d₂"
   (pi (vArg                                       -- h
      (pi (vArg (def (quote A) []))                -- α : A
      (abs "α"
      (pi (vArg (def (quote B) []))                -- β : B
      (abs "β"
      (def (quote _≡_)
         vArg (var 3                               -- d₁ ref
            (vArg (var 1 []) :: [])) ::            -- α ref
         vArg (var 2                               -- d₂ ref
            (vArg (var 0 []) :: [])) :: []))))))   -- β ref
      (abs "h" 
   (pi (vArg (def (quote W) []))                   -- W → P
      (abs "_" (var 4 [])))))))))))

\end{Verbatim}
\endgroup
\end{center}
\caption{Abstract syntax tree for constructor $f$}
\label{fig:ast-f}
\end{figure}

The recursion rule $f$ corresponding to figure \eqref{fig:ast-f} is given by the following equation.
\begin{align}
& f : (P : Set) \rightarrow (d_1 : A \rightarrow P) \rightarrow (d_2 : B \rightarrow P) \rightarrow \nonumber \\
& \hspace {0.4cm} (h : (\alpha : A) \rightarrow (\beta : B) \rightarrow (d_1 \, \alpha) \equiv (d_2 \, \beta)) \rightarrow \nonumber \\
& \hspace {0.4cm} W \rightarrow P \nonumber
\end{align}
The computation rules for constructors $g_1$ and $g_2$ give the action of eliminator $f$ on input $g_1 (\alpha)$ and $g_2 (\beta)$ respectively. The computation rules say that the function $f$ maps the points $g_1 (\alpha)$ and $g_2 (\beta)$ to the points $d_1 (\alpha)$ and $d_2 (\beta)$ respectively in the output type $P$. We specify the clause definition to build the computation rules for $g_1$ and $g_2$ in the same way as for a regular inductive type (sec.~\ref{sec:sec3.1}) except that the clause definition for the higher inductive type $W$ has an additional reference variable to the path $h$. The following definitional equalities give the computation rules for $g_1$ and $g_2$.
\begin{align}
f (P, d_1, d_2, h, g_1 (\alpha)) \equiv d_1 (\alpha) \nonumber \\
f (P, d_1, d_2, h, g_2 (\beta)) \equiv d_2 (\beta) \nonumber
\end{align}

The computation rule for the path constructor $l$ defines the action of function $f$ on the path $(l \, \alpha \, \beta)$. In type theory, the functions are functorial, and they preserve the path structures in their mapping to the output type \citep{HoTT-2013}. The function $ap_f$ \eqref{eq:ap} defines the action of the non-dependent eliminator $f$ on the path $l$. Using \eqref{eq:ap}, we can build the computation rule for the path $l$ as follows.
\begin{align}
& \beta_f : (P : Set) \rightarrow (d_1 : A \rightarrow P) \rightarrow (d_2 : B \rightarrow P) \rightarrow \nonumber \\
& \hspace {0.4cm} (h : (\alpha : A) \rightarrow (\beta : B) \rightarrow (d_1 \,  \alpha) \equiv (d_2 \, \beta)) \rightarrow \nonumber \\
& \hspace {0.4cm} \{\alpha : A\} \rightarrow \{\beta : B\} \rightarrow \nonumber \\
& \hspace {0.4cm} ap_{(\lambda x \rightarrow f(P, d_1, d_2, h, x))}(l \, \alpha \, \beta) \equiv (h \, \alpha \, \beta) \nonumber
\end{align}

The computation rule $\beta_f$ exists only as propositional equality. We build the type of $\beta_f$ using the same approach as for the recursion rule $f$. The type of $f$ and $\beta_f$ is identical except for the mapping $W \rightarrow P$ in $f$ which is replaced by the term representing the action of function $f$ on the path $(l \, \alpha \, \beta)$. The function $ap$ applies $f$, which is nested inside a lambda function, on the arguments $(g_1 \, \alpha)$ and $(g_2 \, \beta)$ of the path $(l \, \alpha \, \beta)$. We use the constructor {\tt lam} of {\tt Term} to introduce the lambda function with argument {\tt x} (fig.~\ref{fig:ast-beta-f}). Inside the lambda body, the argument {\tt x} gets a de-bruijn index reference of zero and we update the remaining de-bruijn indices accordingly. The application of function $f$ to the path $(l \, \alpha \, \beta)$ substitutes the points $(g_1 \, \alpha)$ and $(g_2 \, \beta)$ for the lambda argument {\tt x}, and it evaluates to the path $(h \, \alpha \, \beta)$ in the output type $P$. We implement the {\tt generateRecHit} interface as follows. 

\begin{figure}
\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = single]

   (def (quote _≡_) 
      (vArg (def (quote ap)                        -- ap
         (vArg (lam visible (abs "x"               -- x
            (def (quote f)                         -- f
               (vArg (var 6 []) ::                 -- P ref
                vArg (var 5 []) ::                 -- d₁ ref
                vArg (var 4 []) ::                 -- d₂ ref
                vArg (var 3 []) ::                 -- h ref
                vArg (var 0 []) :: [])))) ::       -- x ref
          vArg (def (quote l)                      -- l
             (vArg (var 1 []) ::                   -- α ref
              vArg (var 0 []) :: [])) :: [])) ::   -- β ref
          vArg (var 2                              -- h ref
             (vArg (var 1 []) ::                   -- α ref
              vArg (var 0 []) :: [])) :: []))      -- β ref
             
\end{Verbatim}
\endgroup
\end{center}
\caption{Abstract syntax tree for the term representing the action of function $f$ on path $l$}
\label{fig:ast-beta-f}
\end{figure}

\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = lines, rulecolor=\color{blue}, numbers = left, numbersep = 0pt]

  generateRecHit : Arg Name → List (Arg Name) → 
    (baseType : Name) → (indexList : List Nat) → 
    (baseRec : Name) → (indType : Name) → 
    (points : List Name) → (paths : List Name) → TC ⊤
  generateRecHit (arg i f) argD base il rec ind points paths =
    bindTC (getConstructors base) λ lcons → 
    bindTC (getLength points) λ lpoints →
    bindTC (getLength paths) λ lpaths →
    bindTC (getPathClause lpoints lpaths rec) λ clause →
    bindTC (getType base) λ RTy →
    bindTC (getRtypePath base ind rec il paths zero RTy) λ fty →
    bindTC (declareDef (arg i f) fty) λ _ →
    bindTC (defineFun f clause) λ _ →
    (generateβRecHit argD base il rec ind f points paths)

\end{Verbatim}
\endgroup
\end{center}

{\tt generateRecHit} takes the base type recursion rule as input and uses that to map the points $g_1 (\alpha)$ and $g_2 (\beta)$ to $d_1 (\alpha)$ and $d_2 (\beta)$ respectively in the abstract syntax tree of the path $(l \, \alpha \, \beta)$. The second argument {\tt argD} is a list of terms representing the computation rules for the path constructors. The {\tt generateβRecHit} interface takes {\tt argD} as input and builds the computation rule for the path constructor $l$. Other inputs to {\tt generateRecHit} are the point and path holders declared during the higher inductive type definition of $W$. The following automation code generates the recursion rule and the computation rules for {\tt Circle}.

\begin{center}
\begingroup
\fontsize{8pt}{9pt}\selectfont
\begin{Verbatim}

  unquoteDecl recS₁* = generateRec (vArg recS₁*)
                          (quote S₁*) (0 :: [])

  unquoteDecl recS₁ βrecS₁ = generateRecHit (vArg recS₁) 
                                ((vArg βrecS₁) :: [])
                                (quote S₁*) (0 :: [])
                                (quote recS₁*)
                                (quote S₁) S₁points S₁paths

\end{Verbatim}
\endgroup
\end{center}

The term {\tt βrecS₁} represents the computation rule for the path constructor {\tt loop} and is brought into scope by {\tt unquoteDecl}.

\subsection{Dependent Eliminator}
\label{sec:sec4.3}

Dependent eliminator or the induction principle of a higher inductive type $W$ is a dependent function that maps an element $\omega$ of $W$ to an output type $P \, \omega$. For the type $W$ with point constructors $g_1 : A \rightarrow W$ and $g_2 : B \rightarrow W$ and path constructor $l : (\alpha \rightarrow A) \rightarrow (\beta \rightarrow B) \rightarrow (g_1 \, \alpha) \equiv (g_2 \, \beta)$, to define a mapping $f' : (\omega : W) \rightarrow P \, \omega$, we need $d_1 : (\alpha : A) \rightarrow P \, \alpha$, $d_2 : (\beta : B) \rightarrow P \, \beta$, and $h : (\alpha \rightarrow A) \rightarrow (\beta : B) \rightarrow transport \, P \, (l \, \alpha \, \beta) \, (d_1 \, \alpha) \equiv (d_2 \, \beta)$, where $(h \, \alpha \, \beta)$ is a heterogeneous path transported over $(l \, \alpha \, \beta)$ lying in the space $P \, \beta$. Equation \eqref{eq:transport} gives the type of $transport$.

\begin{figure}
\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = single]

  (pi (vArg (`W `⇒ agda-sort (lit 0)))
     (abs "P"
  (pi (vArg
     (pi (vArg `A)
     (abs "α"
     (var 1 (vArg (con (quote g₁) 
              (vArg (var 0 []) :: [])) :: [])))))
     (abs "d₁"
  (pi (vArg
     (pi (vArg `B)
     (abs "β"
     (var 2 (vArg (con (quote g₂) 
              (vArg (var 0 []) :: [])) :: [])))))
     (abs "d₂"
  (pi (vArg
     (pi (vArg `A)
     (abs "α"
     (pi (vArg `B)
     (abs "β"
     (def (quote _≡_)
       (vArg (def (quote transport)
         (vArg (var 4 []) ::
          vArg (def (quote l) (vArg (var 1 []) :: 
          vArg (var 0 []) :: [])) ::
          vArg (var 3 (vArg (var 1 []) :: [])) :: [])) :: 
       vArg (var 2 (vArg (var 0 []) :: [])) :: [])))))))
     (abs "h"
  (pi (vArg `W)
     (abs "ω" (var 4 (vArg (var 0 []) :: [])))))))))))

\end{Verbatim}
\endgroup
\end{center}
\caption{Abstract syntax tree of function $f'$}
\label{fig:ast-ind-f'}
\end{figure}

In the abstract syntax tree of $f'$ (fig. \ref{fig:ast-ind-f'}), the type of constructors $d_1$ and $d_2$ are built from the type of $g_1$ and $g_2$ respectively using the same approach as in section \eqref{sec:sec3.2}. When building the type of $d_1$, we copy the constant argument $A$ directly into the abstract syntax tree of $d_1$, and for the codomain P, which depends on the action of constructor $g_1$ on the constant argument $\alpha : A$, we pass the de-bruijn index reference of $\alpha$ as an argument to the constructor $g_1$ built using the reflection construct {\tt con}. Similarly, for $d_2$, we copy the type $B$ directly into the abstract syntax tree of $d_2$ and pass the de-bruijn index of $\beta : B$ to the constructor $g_2$ in the co-domain. We build the type of path $h$ by traversing the abstract syntax tree of $l$ and adding relevant type information into it. We copy the constant arguments of type $A$ and $B$ without modification. For the codomain of $l$, which is the identity type $(g_1 \, \alpha) \equiv (g_2 \, \beta)$, we insert the quoted {\tt name} of function $transport$ with arguments $P$, the path $(l \, \alpha \, \beta)$ and $(d_1 \, \alpha)$. We apply the base eliminator to the arguments of the path $(l \, \alpha \, \beta)$ to form the elements $(d_1 \, \alpha)$ and $(d_2 \, \beta)$. The following declaration gives the type of $f'$ corresponding to figure \eqref{fig:ast-ind-f'}. 
\begin{align}
& f' : (P : W \rightarrow Set) \rightarrow \nonumber \\
& \hspace {0.6cm} (d_1 : (\alpha : A) \rightarrow P (g_1 \, \alpha)) \rightarrow (d_2 : (\beta : B) \rightarrow P (g_2 \, \beta)) \rightarrow \nonumber \\ 
& \hspace {0.6cm} (h : (\alpha : A) \rightarrow (\beta : B) \rightarrow \nonumber \\
& \hspace {1.2cm} transport \, P \, (l \, \alpha \, \beta) (d_1 \, \alpha) \equiv (d_2 \, \beta)) \rightarrow \nonumber \\
& \hspace {0.6cm} (\omega : W) \rightarrow P (\omega) \nonumber
\end{align}

We build the computation rules corresponding to the mapping $f'$ for the point constructors $g_1$ and $g_2$ using the same approach as for the non-dependent eliminator $f$. The following equations give the computation rules for the point constructors $g_1$ and $g_2$.
\begin{align}
f' (P, d_1, d_2, h, g_1 (\alpha)) \equiv d_1 (\alpha) \nonumber \\
f' (P, d_1, d_2, h, g_2 (\beta)) \equiv d_2 (\beta) \nonumber
\end{align}

The computation rule $\beta_{f'}$ for the heterogeneous path $h$ depends on $apd$ \eqref{eq:apd} which gives the action of dependent function $f'$ on the path $h$. We build the type of $\beta_{f'}$ using \eqref{eq:apd} as follows.
\begin{align}
&\beta_{f'} : (P : W \rightarrow Set) \rightarrow \nonumber \\
& \hspace {0.6cm} (d_1 : (\alpha : A) \rightarrow P (g_1 \, \alpha)) \rightarrow (d_2 : (\beta : B) \rightarrow P (g_2 \, \beta)) \rightarrow \nonumber \\ 
& \hspace {0.6cm} (h : (\alpha : A) \rightarrow (\beta : B) \rightarrow \nonumber \\
& \hspace {1.2cm} transport \, P \, (l \, \alpha \, \beta) (d_1 \, \alpha) \equiv (d_2 \, \beta)) \rightarrow \nonumber \\
& \hspace {0.6cm} apd_{(\lambda x \rightarrow f'(P, d_1, d_2, h, x))}(l \, \alpha \, \beta) \equiv (h \, \alpha \, \beta) \nonumber
\end{align}

\begin{figure}
\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = single]

   (def (quote _≡_) 
      (vArg (def (quote apd)                       -- apd
         (vArg (lam visible (abs "x"               -- x
            (def (quote f')                        -- f
               (vArg (var 6 []) ::                 -- P ref
                vArg (var 5 []) ::                 -- d₁ ref
                vArg (var 4 []) ::                 -- d₂ ref
                vArg (var 3 []) ::                 -- h ref
                vArg (var 0 []) :: [])))) ::       -- x ref
          vArg (def (quote l)                      -- l
             (vArg (var 1 []) ::                   -- α ref
              vArg (var 0 []) :: [])) :: [])) ::   -- β ref
          vArg (var 2                              -- h ref
             (vArg (var 1 []) ::                   -- α ref
              vArg (var 0 []) :: [])) :: []))      -- β ref
             
\end{Verbatim}
\endgroup
\end{center}
\caption{Abstract syntax tree for the term representing the action of dependent function $f'$ on path $l$}
\label{fig:ast-beta-f'}
\end{figure}

We build the abstract syntax tree for the computation rule $\beta_{f'}$ in the same way as for induction principle $f'$. In the codomain of $\beta_{f'}$ (fig.~\ref{fig:ast-beta-f'}), which is an identity type, we insert the abstract representation of the function $apd$ with arguments $f'$, nested inside a lambda body, and the path $(l \, \alpha \, \beta)$. We pass the path $(h \, \alpha \, \beta)$, built using de-bruijn indices, as the second argument to the identity type. The following code gives the implementation of the {\tt generateIndHit} interface in the automation tool.

\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = lines, rulecolor=\color{blue}, numbers = left, numbersep = 0pt]

  generateIndHit : Arg Name → List (Arg Name) → 
    (baseType : Name) → (indLs : List Nat) → 
    (baseElm : Name) → (indType : Name) → 
    (points : List Name) → (paths : List Name) → TC ⊤
  generateIndHit (arg i f) argD b indLs elm ind p1 p2 =
    bindTC (getIndex base indLs) λ il →
    bindTC (getConstructors base) λ lcons → 
    bindTC (getLength points) λ l1 →
    bindTC (getLength paths) λ l2 →
    bindTC (getPathClauseDep l1 l2 base elm il lcons) λ cl →
    bindTC (getType baseType) λ RTy →
    bindTC (getRtypePathDep base ind elm p1 p2 zero il RTy) λ fty →
    bindTC (declareDef (arg i f) fty) λ _ →
    bindTC (defineFun f cl) λ _ →
    (generateβIndHit argD base indLs elm ind f points paths)

\end{Verbatim}
\endgroup
\end{center}

The interface {\tt generateIndHit} takes the base eliminator as an argument and uses that to map the point constructors $g_1$ and $g_2$ to output $d_1$ and $d_2$ when building the codomain of the path constructor $h$. {\tt generateβIndHit} builds the computation rule for the path constructor $h$. The following code builds the induction principle and the computation rules for {\tt Circle}.

\begin{center}
\begingroup
\fontsize{8pt}{9pt}\selectfont
\begin{Verbatim}

  unquoteDecl indS₁* = generateInd (vArg indS₁*)
                          (quote S₁*) []

  unquoteDecl indS₁ βindS₁ = generateIndHit (vArg indS₁) 
                                ((vArg βindS₁) :: [])
                                (quote S₁*) []
                                (quote indS₁*)
                                (quote S₁) S₁points S₁paths

\end{Verbatim}
\endgroup
\end{center}

The primitive {\tt unquoteDecl} declares {\tt βindS₁} as a postulate. {\tt βindS₁} gives the action of dependent function {\tt indS₁} on the path constructor {\tt loop}.

\section{Application}

The field of homotopy type theory is less well-developed on the programming side. There are only few programming applications of homotopy type theory, and the role of computationally relevant equality proofs on programming is an area of active research. Applications such as homotopical patch theory \cite{Angiuli-2014} discuss the implementation of Darcs \cite{Darcs-2005} version control system using patch theory \cite{Mimram-2013} \cite{Jason-2009} in the context of homotopy type theory. Containers in homotopy type theory \cite{Altenkirch-2014} \cite{Abbott-2005} implement data structures such as multisets and cycles. The automation tool discussed in this paper abstracts away the difficulties involved in the implementation of a higher inductive type and its elimination rules. It introduces interfaces which simplify the intricacies of a higher inductive type definition and usage by automating the generation of the code segments defining the higher inductive type and its elimination rules. The automation tool is significant in reducing the development effort for existing applications, and it can also attract new programming applications in homotopy type theory.

In the next section, we discuss the implementation of patch theory application in Agda and exhibit a tremendous reduction in code size using the automation tool. In section \ref{crypto}, we present a cryptography application and discuss how to abstract the implementation difficulties of a higher inductive type making it more accessible to the cryptographers.

\subsection{Patch Theory Revisited}
\label{patch-theory}
A patch is a syntactic representation of a function that modifies a repository context when applied. For example, a patch $(s1 \leftrightarrow s2 \, @ \, l)$, which replaces string s1 with s2 at line l, when applied to a repository context with string s1 at line l results in a repository context with string s2 at line l. In homotopical patch theory \cite{Angiuli-2014}, the patches are modeled as paths in a higher inductive type. The higher inductive type representation of patches automatically satisfy groupoid laws such as the composition of patches is associative, and inverse composes to identity. Domain-specific laws related to the patches such as two swaps at independent lines commute are designed as higher dimensional paths. The computation content of the patches is extracted by mapping them to bijections in the universe with the help of univalence. Due to the functoriality of mappings in type theory, the functions preserve the path structures in their mapping to the universe.

We developed the patch theory application in Agda using Dan Licata's method \cite{Licata-2011}. We implemented basic patches like the insertion of a string as line l1 in a file and deletion of a line l2 from a file. The functions implementing insertion and deletion in the universe are not bijective. So, to map the paths representing the patches insert and delete into the universe, we used the patch history approach \cite{Angiuli-2014}. According to this approach, we developed a separate higher inductive type $History$ which serves as the types of patches. In addition to basic patches, we also implemented patches of encryption using cryptosystems like rsa \cite{Rivest-1978} and paillier \cite{Paillier-1999}.

We used the automation tool described in this paper to generate code for the higher inductive type definition representing $History$ and the repository context $cryptR$ for the patches. We also automated the code generation for the elimination and the computation rules for the higher inductive types $History$ and $cryptR$. In addition to abstracting the implementation difficulties of higher inductive types, the automation tool helped us to achieve an extensive reduction in the code size of the original application. We were able to automate the generation of approximately 1500 lines of code with just about 70 lines of automation code. The automation massively reduced the code size of the application which is about 2500 lines resulting in 60\% reduction in the original code size.

\subsection{Cryptography}
\label{crypto}
The work of \cite{Paventhan-2018} applies the tools of homotopy type theory for cryptographic protocol implementation. It introduces a new approach for the formal specification of cryptographic schemes using types. The work discusses modeling $cryptDB$ \citep{Popa-2011} using a framework similar to patch theory. CryptDB employs layered encryption techniques and demonstrates computation on top of encrypted data. We can implement cryptDB by modeling the database queries as paths in a higher inductive type and mapping the paths to the universe using singleton types \cite{Angiuli-2014}. The automation tool can be applied to generate code for the higher inductive type representing cryptDB and its corresponding elimination and computation rules. By using the automation tool, we can abstract the convolutions of homotopy type theory thus making it more accessible to the broad community of cryptography.

A formal specification of a cryptographic construction promises correctness of properties related to security and implementation. The downside of formal specification is that it introduces a framework which requires expert knowledge on theorem proving and a strong mathematical background. By automating the code constructions for the mathematical part such as the higher inductive type implementation, we simplify theorem proving and formal specification to a considerable extent and make it more accessible to regular programmers without a strong mathematical background.

\section{Conclusion and Future Work}
We presented an automation tool developed using the new reflection library of Agda extended with support for elaborator reflection. Our automation tool handles code generation for inductive types with constructors taking zero arguments, one or more arguments, and type being defined itself as an argument. We simplified the syntax for defining higher inductive types through the mechanized construction of the boiler-plate code segments. By automating the generation of the elimination and the computation rules associated with a higher inductive type, we demonstrated an extensive reduction in code size and abstraction of difficulties involved in implementing and using the higher inductive type. Next, we intend to extend the support to include more categories of the inductive type such as the inductive-inductive type and the inductive-recursive type.


\bibliographystyle{ACM-Reference-Format}
\bibliography{sigproc} 

\end{document}
