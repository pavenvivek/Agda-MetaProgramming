\documentclass[sigplan,10pt]{acmart}
\settopmatter{printfolios=true,printccs=false,printacmref=false}

\usepackage{booktabs} % For formal tables
%\usepackage{breqn}


% Copyright
%\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
\setcopyright{none}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}


\acmConference[TyDe'18]{ACM SIGPLAN Workshop on Type-Driven Development}{September 27, 2018}{St. Louis, MO, USA}
\acmYear{2018}
%\acmISBN{} % \acmISBN{978-x-xxxx-xxxx-x/YY/MM}
%\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption

\usepackage{bbm}
\usepackage[greek,english]{babel}

% This handles the translation of unicode to latex:
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{autofe}
\usepackage{fixltx2e}
\usepackage{hyphenat}

\DeclareUnicodeCharacter{8988}{\ensuremath{\ulcorner}}
\DeclareUnicodeCharacter{8989}{\ensuremath{\urcorner}}
\DeclareUnicodeCharacter{8803}{\ensuremath{\overline{\equiv}}}
%\DeclareUnicodeCharacter{11820}{\ensuremath{\urcorner}}
%\DeclareUnicodeCharacter{8759}{\ensuremath{\urcorner}}

\usepackage{amsmath}
\usepackage{fancyvrb}
\usepackage[euler]{textgreek}
\usepackage{textcomp}
\usepackage{relsize}
\usepackage{mathabx}
\usepackage{amssymb}
\usepackage{mathtools}

\usepackage[belowskip=-5pt,aboveskip=3pt]{caption}
\usepackage{todonotes}

\renewcommand{\theFancyVerbLine}{%
  \sffamily
  \textcolor[rgb]{0,0.7,0}{%
    \tiny{%
      \arabic{FancyVerbLine}%
    }
  }%
}


\begin{document}
\title{Encoding Higher Inductive Types Without Boilerplate}
                                        %% when present, will be used in
                                        %% header instead of Full Title.
%\titlenote{with title note}             %% \titlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'
\subtitle{A Study in Agda Metaprogramming}                     %% \subtitle is optional
%\subtitlenote{with subtitle note}       %% \subtitlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{Paventhan Vivekanandan}
%\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  %\position{Position1}
  \department{School of Informatics, Computing and Engineering}  %% \department is recommended
  \institution{Indiana University} %% \institution is required
  %\streetaddress{Street1 Address1}
  \city{Bloomington}
  \state{Indiana}
  %\postcode{Post-Code1}
  \country{USA}                    %% \country is recommended
}
\email{pvivekan@indiana.edu}          %% \email is recommended

%% Author with two affiliations and emails.
\author{David Thrane Christiansen}
%\authornote{with author2 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
%  \position{Position2a}
  \institution{Galois, Inc.} %% \institution is required
  %\streetaddress{Street2a Address2a}
  \city{Portland}
  \state{Oregon}
  %\postcode{Post-Code2a}
  \country{USA}                   %% \country is recommended
}
\email{dtc@galois.com}         %% \email is recommended
%\affiliation{
%  \position{Position2b}
%  \department{Department2b}             %% \department is recommended
%  \institution{Institution2b}           %% \institution is required
%  \streetaddress{Street3b Address2b}
%  \city{City2b}
%  \state{State2b}
%  \postcode{Post-Code2b}
%  \country{Country2b}                   %% \country is recommended
%}
%\email{first2.last2@inst2b.org}         %% \email is recommended



% The default list of authors is too long for headers}
%\renewcommand{\shortauthors}{B. Trovato et al.}


\begin{abstract}
Higher inductive types are inductive types that include nontrivial higher-dimensional structure, represented as identifications at the type that are not reflexivity. While work proceeds on type theories with a computational interpretation of univalence and higher inductive types, it is convenient to encode these structures in more traditional type theories. However, these encodings involve a great deal of error-prone additional syntax. We present a library that uses Agda's metaprogramming facilities to automate this process, allowing higher inductive types to be specified with minimal additional syntax.
\end{abstract}

%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below.
%
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003456.10003457.10003521.10003525</concept_id>
<concept_desc>Social and professional topics~History of programming languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~General programming languages}
\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code

\keywords{Higher inductive type, Elaboration, Elimination rules, Computation rules}

\maketitle

\section{Introduction}
\label{sec:intro}

A metaprogram is a program used to create other programs. In dependently-typed programming languages like Agda and Coq, a reflection library provides metaprogramming interfaces to support code generation for proofs and programs. Elaborator reflection \cite{David-2016}, a new paradigm for metaprogramming, provides the language users with a powerful set of interfaces for efficient code generation. An $elaborator$ is a metaprogram that converts a high-level language syntax in its abstract representation to a core language which is then type checked independently. By exposing a primitive monad to elaboration framework in Idris, Christiansen \cite{David-2016} showed how to write termination proofs for general recursive functions by automating Bove-Capretta \cite{Bove-2005} transformation, and how to generate data types matching schemas of external data sources based on Idris’s type providers \cite{David-2013}.

Agda is a proof-assistant based on Martin-Löf’s intensional type theory. Unlike Idris, which has a dedicated elaborator to convert the high-level syntax to its core language, Agda’s elaboration mechanism is a part of its type checker. Inspired by Idris’s elaborator reflection, Agda development team extended the reflection library of Agda by exposing its elaboration monad to its high-level metaprogramming instructions. The elaboration monad provides an interface to the Agda type checker through a set of primitive operations which can be used to retrieve static type information regarding various code segments. The primitive operations can also be used to build code fragments using constructs of an abstract syntax tree, and to convert an abstract syntax tree to its concrete syntax.

In this paper, we discuss metaprogramming using elaborator reflection in Agda. By using the elaboration monad, we performed code generation for the elimination and computation rules of inductive types and higher inductive types. We also automated the code generation for the boiler-plate code segment used to define the higher inductive type. We discuss the construction process in detail and introduce new metaprogramming interfaces which build the code segments using elaborator reflection. The interfaces extensively use Agda’s reflection primitives and build the abstract syntax tree of the code segments with static type information obtained using the reflection primitives. The generated code is then brought into scope by another top-level reflection primitive.\todo{Insert a mention of Licata's method that we're automating}

Elaborator reflection is a powerful mechanism which allows us to create more interesting metaprograms. By performing the above automation, we abstracted the difficulties involved in implementing and using inductive types and higher inductive types by automating the construction of their corresponding elimination and computation rules. We also achieved an extensive reduction in code size, and we demonstrated how to extend a language without modifying the compiler or depending on the language implementers. More specifically, we discuss the following contributions in this paper.\todo{Rewrite contributions list to focus on actually novel things - many people have automated eliminator generation before}

\begin{itemize}
\item We automate the construction of the recursion and the induction principles for inductive types with constructors taking zero arguments, one or more arguments, and the type being defined itself as an argument.

\item We discuss the automation of code generation of boiler-plate code for a higher inductive type defined inside a module. The boiler-plate code depends on a base type defined as private inside the module. The constructors of the private base type are not accessible outside the module.

\item We discuss the automation of code generation of the elimination and the computation rules for a higher inductive type with point and path constructors. We demonstrate the code generation of the reduction rules, specified as postulates, for the path constructors of the higher inductive type.

\item We discuss the automation of code generation for patch theory \cite{Angiuli-2014} implementation enriched with patches of encryption. We also examine the usage of the automation tool in a cryptography application \cite{Paventhan-2018}.
\end{itemize}

The automation tool abstracts the implementation difficulties of a higher inductive type and its recursion and induction principles. We automated the code generation of approximately 1500 lines of code of the patch theory implementation with just 70 lines of automation code. The automation code extensively uses the static type information queried from the type checker using the reflection primitives.

\section{Background}
\label{sec:sec2}

\subsection{Agda Reflection}
\label{sec:sec2.1}
Agda's reflection library enables compile-time metaprogramming.
This reflection library directly exposes parts of the implementation of Agda's type checker and elaborator for use by metaprograms, in a manner that is similar to Idris's elaborator reflection~\citep{davidphd,David-2016} and Lean's tactic metaprogramming~\citep{Ebner2017}.
The type checker's implementation is exposed as effects in a monad called \texttt{TC}.

Agda exposes a representation of its syntax to metaprograms, including datatypes for expressions (called \texttt{Term}) and definitions (called \texttt{Definition}).
The primitives exposed in \texttt{TC} include declaring new metavariables, unifying two \texttt{Term}s, declaring new definitions, adding new postulates, computing the normal form or weak head normal form of a \texttt{Term}, inspecting the current context, and constructing fresh names.
This section describes the primitives that are used in our code generation library; more information on the reflection library can be found in the Agda documentation \cite{Agda-doc-2017}.

\texttt{TC} computations can be invoked in three ways: by macros, which work in expression positions, using the \texttt{unquoteDecl} operator in a declaration position, which can bring new names into scope, and using the \texttt{unquoteDef} operator in a declaration position, which can automate constructions using names that are already in scope.
This preserves the principle in Agda's design that the system never invents a name.

An Agda \emph{macro} is a function of type {\tt $t_1$ → $t_2$ → $\ldots$ → Term → TC ⊤} that is defined inside a \texttt{macro} block.
Macros are special: their last argument is automatically supplied by the type checker, and consists of a \texttt{Term} that represents the metavariable to be solved by the macro.
If the remaining arguments are quoted names or \texttt{Term}s, then the type checker will automatically quote the arguments at the macro's use site.
At some point, the macro is expected to unify the provided metavariable with some other term, thus solving it.


\begin{figure}
\begin{Verbatim}
macro
  mc1 : Term → Term → TC ⊤
  mc1 exp hole =
    do exp' ← quoteTC exp
       unify hole exp'

sampleTerm : Term
sampleTerm = mc1 (λ (n : Nat) → n)
\end{Verbatim}
  \caption{A macro that quotes its argument}
  \label{fig:macro1}
\end{figure}


Figure~\ref{fig:macro1} demonstrates a macro that quotes its argument.
The first step is to quote the quoted expression argument again, using \texttt{quoteTC}, yielding a quotation of a quotation.
The result of this double-quotation is passed, using Agda's new support for Haskell-style do-notation, into a function that unifies it with the hole.
Because unification removes one layer of quotation, \texttt{unify} inserts the original quoted term into the hole.
The value of {\tt sampleTerm} is
\begin{center}
\begin{BVerbatim}
lam visible (abs "n" (var 0 []))
\end{BVerbatim}
\end{center}
The constructor \texttt{lam} represents a lambda, and its body is formed by the abstraction constructor \texttt{abs} that represents a scope in which a new name \texttt{"n"} is bound.
The body of the abstraction is a reference back to the abstracted name using de~Bruijn index \texttt{0}.

\begin{figure}
  \centering
\begin{Verbatim}
macro
  mc2 : Term → Term → TC ⊤
  mc2 exp hole =
    do exp' ← unquoteTC exp
       unify hole exp'

sampleSyntax : Nat → Nat
sampleSyntax =
  mc2 (lam visible (abs "n" (var 0 [])))
\end{Verbatim}
  \caption{A macro that unquotes its argument}
  \label{fig:macro2}
\end{figure}

The {\tt unquoteTC} primitive removes one level of quotation.
Figure~\ref{fig:macro2} demonstrates the use of \texttt{unquoteTC}.
The macro {\tt mc2} expects a quotation of a quotation, and substitutes its unquotation for the current metavariable.


The {\tt unquoteDecl} and {\tt unquoteDef} primitives, which run \texttt{TC} computations in a declaration context, will typically introduce new declarations by side effect.
A function of a given type is declared using {\tt declareDef}, and it can be given a definition using {\tt defineFun}.
Similarly, a postulate of a given type is defined using {\tt declarePostulate}.
Figure~\ref{fig:plus} shows an Agda implementation of addition on natural numbers, while figure~\ref{fig:plusmeta} demonstrates an equivalent metaprogram that adds the same definition to the context.


\begin{figure}[h]
\begin{Verbatim}
plus : Nat → Nat → Nat
plus zero b = b
plus (suc n) b = suc (plus n b)
\end{Verbatim}
  \caption{Addition on natural numbers}
  \label{fig:plus}
\end{figure}



\begin{figure}
\begingroup
\fontsize{9pt}{10pt}\selectfont
\begin{Verbatim}
pattern vArg x = arg (arg-info visible relevant) x
pattern _`⇒_ a b = pi (vArg a) (abs "_" b)
pattern `Nat = def (quote Nat) []

unquoteDecl plus =
  do declareDef (vArg plus) (`Nat `⇒ `Nat `⇒ `Nat)
     defineFun plus
       (clause (vArg (con (quote zero) []) ::
                vArg (var "y") ::
                [])
          (var 0 []) ::
        clause (vArg (con (quote suc)
                       (vArg (var "x") :: [])) ::
                vArg (var "y") ::
                [])
          (con (quote suc)
            (vArg (def plus
                    (vArg (var 1 []) ::
                     vArg (var 0 []) :: [])) ::
             [])) ::
        [])
\end{Verbatim}
\endgroup
\caption{Addition, defined by metaprogramming}
\label{fig:plusmeta}
\end{figure}

In Figure~\ref{fig:plusmeta}, {\tt declareDef} declares the type of {\tt plus}.
The constructor {\tt pi} represents dependent function types, but a pattern synonym is used to make it shorter.
Similarly, \texttt{def} constructs references to defined names, and the pattern synonym \Verb|`Nat| abbreviates references to the defined name \texttt{Nat}, and {\tt vArg} represents the desired visibility and relevance settings of the arguments.
Once declared, \texttt{plus} is defined using {\tt defineFun}, which takes a name and a list of clauses, defining the function by side effect.
Each clause consists of a pattern and a right-hand side.
Patterns have their own datatype, while right-hand sides are \texttt{Term}s.
The name \texttt{con} is overloaded: in patterns, it denotes a pattern that match a particular constructor, while in \texttt{Term}s, it denotes a reference to a constructor.


\subsection{Higher Inductive Types}
\label{sec:sec2.2}

Homotopy type theory~\cite{HoTT-2013} is a research program that aims to develop univalent, higher-dimensional type theories.
A type theory is \emph{univalent} when equivalences between types are considered equivalent to equalities between types; it is \emph{higher-dimensional} when we allow non-trivial identifications that every structure in the theory must nevertheless respect.
Identifications between elements of a type are considered to be at the lowest dimension, while identifications between identifications at dimension $n$ are at dimension $n+1$.
Voevodsky added univalence  to type theories as an axiom, asserting new identifications without providing a means to compute with them.
While more recent work arranges the computational mechanisms of the type theory such that univalence can be derived, as is done in cubical type theories,\todo{cite Coquand's group, Mörtberg, and Harper's group} we are concerned with modeling concepts from homotopy type theory in existing, mature implementations of type theory, so we follow \citet{HoTT-2013} in modeling paths using Martin-Löf's identity type.
Higher-dimensional structure can arise from univalence, but it can also be introduced by defining new type formers that introduce not only introduction and elimination principles, but also new non-trivial identifications.

In homotopy type theories, one tends to think of types not as collections of distinct elements, but rather through the metaphor of topological spaces.
The individual elements of the type correspond with points in the topological space, and identifications correspond to paths in this space.


% In homotopy type theory, an element of an \emph{identity type} is used to model the notion of a path in a topological space or a morphism in a groupoid. An element of an identity type $a =_A b$ states that $a$ and $b$ are propositionally equal. In type theory, \emph{propositional equality} is a proof-relevant notion of equality, internal to the theory, expressed by identity types. We also have a proof-irrelevant notion of equality, external to the theory, known as \emph{judgmental equality} or \emph{definitional equality}. Definitional equality is used to express equality by definition. For instance, when we have a function $f : Nat \rightarrow Nat$ defined as $f(x) = x^2$ then the expression $f(3)$ is definitionally equal to $3^2$.

While there is not yet a general schematic characterization of a broad class of higher inductive types along the lines of Dybjer's inductive families,\todo{cite 1994 paper} it is convenient to syntactically represent the higher inductive types that we know are acceptable as if we had such a syntax.
Thus, we sometimes specify a higher inductive type similarly to a traditional inductive type by providing its constructors (\textit{i.e.} its points); we additionally specify the higher-dimensional structure by providing additional constructors for paths. For example, figure~\ref{fig:circle} describes \Verb|Circle|, which is a higher inductive type with one point constructor \Verb|base| and one non-trivial path constructor \Verb|loop|.

\begin{figure}[h]
\begin{center}
\begingroup
%\fontsize{7pt}{9pt}\selectfont
\begin{BVerbatim}
data Circle : Set where
  base : Circle
  loop : base ≡ base
\end{BVerbatim}
\endgroup
\end{center}

\caption{A specification of a higher inductive type}
\label{fig:circle}
\end{figure}
\normalsize


Agda \todo{Cite Ulf's thesis + official wiki page} is a programming language that was originally an implementation of Luo's UTT \todo{cite Luo's book} extended with primitive dependent pattern matching, itself a derivative of the Calculus of Constructions and Martin-Löf's intensional type theory.
Agda's type theory has since gained a number of new features, among them the ability to restrict pattern matching to that subset that does not imply Streicher's Axiom K \todo{Cite Cockx et al}, which is inconsistent with univalence.
The convenience of programming in Agda, combined with the ability to avoid axiom K, makes it a good laboratory for experimenting with the idioms and techniques of univalent programming while more practical implementations of univalent type theories are under development.



In Agda, we don't have built-in primitives to support the definition of higher inductive type such as {\tt Circle}. One approach is to use Agda's rewrite rules \todo{cite Cockx and Abel, extended abstract at TYPES 2016} mechanism to define higher inductive types. In this approach, we define the dependent and non-dependent eliminators of a higher inductive type as paramterized modules inside which we declare the computation rules for points as rewrite rules using \Verb|{-# REWRITE , ...#-}| pragma. However, Agda's reflection library do not have interfaces to support introducing new pragmas and defining new modules. Another approach to define higher inductive types is to use Dan Licata's method \cite{Licata-2011}. According to this method, a higher inductive type is defined using type abstraction inside a module. The module consists of a boiler-plate code segment which defines the higher inductive type using a private base type. Inside the module, the recursion and the induction principles acts on the constructors of the private base type. The abstract type is then exported allowing the reduction rules for point constructors to hold definitionally. For example, {\tt Circle} is defined using Dan Licata's method as follows.

\begin{figure}
\begin{center}
\begingroup
%\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}
module Circle where
  private
    data S* : Set where
      base* : S*

  S : Set
  S = S*

  base : S
  base = base*

  postulate
    loop : base ≡ base

  recS : {C : Set} →
    (cbase : C) →
    (cloop : cbase ≡ cbase) →
    S → C
  recS cbase cloop base* = cbase

  postulate
    βrecS : {C : Set} →
      (cbase : C) →
      (cloop : cbase ≡ cbase) →
      ap (recS cbase cloop) loop ≡ cloop

  indS : {C : S → Set} →
    (cbase : C base) →
    (cloop : transport C loop cbase ≡ cbase) →
    (circle : S) → C circle
  indS cbase cloop base* = cbase

  postulate
    βindS : {C : S → Set} →
      (cbase : C base) →
      (cloop : transport C loop cbase ≡ cbase) →
      apd (indS {C} cbase cloop) loop ≡ cloop
\end{Verbatim}
\endgroup
\end{center}

\caption{An example of a higher inductive type using Licata's encoding}
\label{fig:circle-hit}
\end{figure}
\normalsize


Inside the module {\tt Circle}, the type {\tt S} is defined using a private datatype {\tt S*}.
The constructor {\tt base} is defined using {\tt base*} and the path {\tt loop} is given as a postulated propositional equality.
The recursion and induction principles are defined by pattern matching on the constructor {\tt base*} of the type {\tt S*}, and thus compute as expected.
The clients of {\tt Circle} will not have access to the constructor {\tt base*} of the private type {\tt S*}, as it is not visible outside the module, which prevents them from writing functions that distinguish between multiple constructors of a higher inductive type that may be identified by additional path constructors.
The client's \emph{only} access to the constructor is through the provided elimination rules. The following code gives the non-dependent eliminator (sometimes called the \emph{recursion rule}) {\tt recS}.

{\tt recS} ignores the path argument and simply computes to the appropriate answer for the point constructor. The computational behavior for the path constructor loop is postulated using reduction rule {\tt βrecS}.
The operator \texttt{ap}\texttt{Perhaps we should move the discussion of ap earlier, so that we don't need the digression} is frequently referred to as \texttt{cong}, because it expresses that propositional equality is a congruence.
However, when viewed through a homotopy type theory lens, it is often called \texttt{ap}, as it describes the action of a function on paths.
In a higher inductive type, \texttt{ap} should compute new paths from old ones.
\begin{center}
\begin{BVerbatim}
ap : {A B : Set} {x y : A}
     (f : A → B) (p : x ≡ y) → f x ≡ f y
\end{BVerbatim}
\end{center}

The following code gives the dependent eliminator or the induction rule {\tt indS} and its computational rules.
The dependent eliminator relies on another operation on identifications, called \texttt{transport}, that coerces an inhabitant of a family of types at a particular index into an inhabitant at another index.
Outside of homotopy type theory, \texttt{transport} is typically called \texttt{subst} or \texttt{replace}, because it also expresses that substituting equal elements for equal elements is acceptable.
\begin{center}
\begin{Verbatim}
transport : {A : Set} {x y : A} → 
  (P : A → Set) → (p : x ≡ y) → P x → P y
\end{Verbatim}

\end{center}


In the postulated computation rule for \texttt{indS}, the function {\tt apd} is the dependent version of \texttt{ap}: it expresses the action of dependent functions on paths.
\begin{center}
\begingroup
\begin{Verbatim}
apd : {A : Set} {B : A → Set} {x y : A} → 
  (f : (a : A) → B a) → 
  (p : x ≡ y) → (transport B p (f x) ≡ f y)
\end{Verbatim}
\endgroup
\end{center}

\todo{This sentence does not clarify anything for me. What is a "total space"? No reader who knows what that is won't know what "ap" is. Can it be made more clear?}In the above type, the point {\tt (transport B p (f x))} lying in space {\tt B(y)} can be thought of as an endpoint of a path obtained by lifting the path p from {\tt f(x)} to a path in the total space $\sum_{(x:A)} B(x) \rightarrow A$. 


The next section introduces the necessary automation features by describing the automatic generation of eliminators for a variant on Dybjer's inductive families.\todo{Check whether this is right - it might be a variation on Luo's inductive types instead.} Section 4 then generalizes this feature to automate the production of eliminators for higher inductive types using Licata's technique. Section 5 revisits \citeauthor{Angiuli-2014}'s encoding of Darcs's patch theory \citep{Angiuli-2014} and demonstrates that the higher inductive types employed in that paper can be generated succinctly using our library.

\section{Code Generation for Inductive Types}
\label{sec:sec3}
An inductive type $X$ is a type that is freely generated by a finite collection of constructors. The constructors of $X$ accept zero or more arguments, and result in an $X$. The constructors can also take an element of type $X$ itself as an argument, but only \emph{strictly positively}: any occurrences of the type constructor $X$ in the type of an argument to a constructor of $X$ must not be to the left of any arrows.

Type constructors can have a number of \emph{parameters}, which may not vary between the constructors, as well as \emph{indices}, which may.


In Agda, constructors are given a function type. In Agda's reflection library, the constructor {\tt data-type} of the datatype {\tt Definition} stores the constructors of an inductive type as a list of \texttt{Name}s. The type of a constructor can be retrieved by giving its {\tt Name} as an input to the {\tt getType} primitive. In the following subsections, we will discuss how to use list of constructors and their types to generate code for the elimination rules of an inductive type.

\subsection{Non-dependent Eliminators}
\label{sec:sec3.1}

In Agda, we define an inductive type using {\tt data} keyword. The {\tt data} literal characterize a data type by declaring its type and specifying its constructors. Consider the following generic form for the definition of an inductive type \emph{D} with constructors $g_1 \ldots g_n$.
\begin{center}
\begingroup
\fontsize{7.9pt}{0pt}\selectfont
\begin{align}
& data \hspace{0.2cm} D \hspace{0.2cm} (x_1:P_1)\ldots(x_n:P_n) : Q_1 \rightarrow\ldots\rightarrow Q_n \rightarrow Set \, \, where \nonumber \\
& \hspace{0.3cm} g_1 : \{i_1 : Q_1\} \ldots \{i_n : Q_n\} \rightarrow A_1\rightarrow D \, x_1 \ldots x_n \, i_1 \ldots i_n \nonumber \\
& \hspace{3.5cm} \vdots \nonumber \\
& \hspace{0.3cm} g_n : \{j_1 : Q_1\} \ldots \{j_n : Q_n\} \rightarrow A_n\rightarrow D \, x_1 \dots x_n \, j_1 \ldots j_n \nonumber \\ \nonumber
\end{align}
\endgroup
\end{center}
\normalsize

The type of $A_i$ can take one of the three forms: a constant type {\tt B}, the inductive type $D$, or a function $B_1 \rightarrow \ldots \rightarrow B_n \rightarrow D$ with co-domain $D$. The parameters $(x_1:P_1)\ldots(x_n:P_n)$ are common to all the constructors, and the type of each constructor implicitly encodes the parameter references. However, the indices are different for each constructor. So, the type of each constructor explicitly exhibits the index declaration.

While inductive datatypes are defined by their constructors, it must also be possible to \emph{eliminate} them. This section describes how to generate a non-dependent recursion principle for an inductive type; section~\ref{sec:sec3.2} generalizes this technique to fully-dependent induction principles.

Based on the generic form of the inductive type given above, we can define the following schematic representation for the non-dependent eliminator.

\begin{center}
\begingroup
\fontsize{7.9pt}{0pt}\selectfont
\begin{align}
& f \, : \, \{x_1:P_1\}\ldots\{x_n:P_n\} \rightarrow \{k_1:Q_1\} \rightarrow\ldots\rightarrow \{k_n:Q_n\} \rightarrow \nonumber \\
& \hspace{0.4cm} D \, x_1 \dots x_n \, k_1 \ldots k_n \rightarrow (C : Set) \rightarrow \nonumber \\
& \hspace{0.4cm} (c_1 : \{i_1:Q_1\} \rightarrow\ldots\rightarrow \{i_n:Q_n\} \rightarrow A{_1}^* \rightarrow C) \rightarrow \ldots \nonumber \\
& \hspace{0.4cm} (c_n : \{j_1:Q_1\} \rightarrow\ldots\rightarrow \{j_n:Q_n\} \rightarrow A{_n}^* \rightarrow C) \rightarrow C \nonumber \\ \nonumber 
\end{align}
\endgroup
\end{center}
\normalsize

The type of $A{_i}^*$ in constructor $c_i$ depends on the type of $A_i$ in the  constructor $g_i$. If $A_i$ is a constant type $B$, the automation tool replaces $A{_i}^*$ with $B$. For inductive type $D$, the automation tool replaces $A{_i}^*$ with type $D \rightarrow C$. For function type $(B_1 \rightarrow\ldots\rightarrow B_n \rightarrow D)$, the automation tool replaces $A{_i}^*$ with $(B_1 \rightarrow\ldots\rightarrow B_n \rightarrow D) \rightarrow (B_1 \rightarrow\ldots\rightarrow B_n \rightarrow C)$. The parameter and the index to type $D$ must be reflected in the type of function $f$. We can retrieve information about the parameter and the index of $D$ from its type. The constructors refer to the parameter and the index using de~Bruijn indices. The general schema for the computation rules corresponding to $f$ and constructors $g_1, \ldots, g_n$ is given as follows.

\begin{center}
\begingroup
\fontsize{8.9pt}{2pt}\selectfont
\begin{align}
& f \, (g_1 \, a_1 ... a_n) \, C \, c_1 \ldots c_n = c_1 ... \nonumber \\
& \hspace{0.5cm} \vdots \nonumber \\
& f \, (g_n \, a_1 ... a_n) \, C \, c_1 \ldots c_n = c_n ... \nonumber \\ \nonumber
\end{align}
\endgroup
\end{center}
\normalsize

The value of $c_i$ on the right-hand side of the above computation rules depends on the type of $g_i$. If $g_i$ takes zero arguments, then the corresponding computation rule for $g_i$ evaluates to $c_i$. If $g_i$ takes one or more arguments $(g_i \, a_1 \ldots a_n)$, then the computation rule evaluates to $(c_i \, a_1 \ldots a_n)$. If $g_i$ takes the inductive type $D$ as an argument $(g_i \, \ldots \, d_i \, \ldots)$, then the computation rule evaluates to $(c_i \, \ldots \, (f \, \ldots) \ldots)$, encoding the recursor $f$ to evaluate the value for the substructure $d_i$ of $D$. If $g_i$ takes a function with co-domain $D$ as an argument such as $(g_i \, \ldots \, d{_i}^* \, \ldots)$, we need a composite function $(f \circ d{_i}^*)$ to evaluate the value for the substructure $d{_i}^*$. The automation tool handles composites by using a lambda function $(\lambda \, a \, \ldots \, \rightarrow (f \ldots (d{_i}^* a \ldots) \ldots))$.

The Agda datatype \texttt{Vec} represents lists of a known length. It is defined in figure~\ref{fig:vec}. For {\tt Vec}, the recursion principle says that to define a mapping {\tt f : Vec A n → C}, it suffices to define the action of \emph{f} on inputs {\tt []} and {\tt \_::\_}.

\begin{figure}
\begin{center}
\begingroup
\begin{BVerbatim}
data Vec (A : Set) : Nat → Set where
  []   : Vec A zero
  _::_ : {n : Nat} →
         (x : A) → (xs : Vec A n) → 
         Vec A (suc n)
\end{BVerbatim}
\endgroup
\end{center}
\caption{Length-indexed lists}
\label{fig:vec}
\end{figure}

To define the action of \emph{f} on inputs {\tt []} and {\tt \_::\_}, we need elements {\tt c1} and {\tt c2} of the following type.\todo{The usual presentation instead quantifies the parameters over the entire eliminator, and then the index separately over the motive, instantiating the index as necessary for each method, and then quantifies once more for the target of elimination.}

\begin{center}
\begingroup
%\fontsize{9pt}{2pt}\selectfont
\begin{BVerbatim}
c1 : C
c2 : {m : Nat} → (x : A) → (xs : Vec A m) → 
     C → C
\end{BVerbatim}
\endgroup
\end{center}
\normalsize

%\begin{equation}
%d : (A \rightarrow W) \rightarrow (A \rightarrow P) \rightarrow B \rightarrow W \rightarrow P \rightarrow P \nonumber
%\end{equation}

The recursor {\tt f} maps the constructor {\tt []}, which takes zero arguments, to {\tt c1}. The constructor {\tt \_::\_} takes a constant argument {\tt x} and an argument {\tt xs} of the inductive type {\tt Vec}. {\tt f} maps {\tt (x :: xs)} to {\tt (c2 x xs (f xs C c1 c2))}. To construct the type of the recursion rule for {\tt Vec}, we need to build the type of {\tt c1} and {\tt c2}. Since {\tt []} is not a function type, we can map it directly to {\tt c1 : C}. We can retrieve the static type information of {\tt \_::\_} using reflection primitives, and use that to construct the type of {\tt c2}. The constructor {\tt pi} of type {\tt Term} encodes the abstract syntax tree (AST) representation of {\tt \_::\_} (fig.~\ref{fig:ast-g}). We can retrieve and traverse the AST of {\tt \_::\_}, and add new type information into it to build a new type representing {\tt c2}.

\begin{figure}
\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = single]
pattern _[_v]⇒_ a s b = pi (vArg a) (abs s b)
pattern _[_h]⇒_ a s b = pi (hArg a) (abs s b)

(agda-sort (lit 0) [ "A" h]⇒               -- A
 (def (quote Nat) [] [ "n" h]⇒             -- n
  (var 1 [] [ "x" v]⇒                      -- x
   (def (quote Vec)                         -- xs : Vec A n
        (vArg (var 2 []) ::
         vArg (var 1 []) :: [])
         [ "xs" v]⇒
    def (quote Vec)                         -- Vec A (suc n)
        (vArg (var 3 []) ::
         vArg (con (quote suc)
                (vArg (var 2 []) :: []))
         :: [])))))
\end{Verbatim}
\endgroup
\end{center}
\caption{Abstract syntax tree for constructor {\tt \_::\_}}
\label{fig:ast-g}
\end{figure}

\normalsize

During the traversal of abstract syntax tree of the type of {\tt \_::\_}, when the type {\tt Vec} occurs directly in a non-codomain position, we add the type {\tt C} next to it. For example, in figure~\ref{fig:ast-g}, a new function is built from the argument {\tt (xs : Vec A n)} by modifying it to {\tt (Vec A n) → C} (fig.~\ref{fig:ast-d}). Constant types require no modifications. Therefore, we copy {\tt (x : A)} into the new type without any changes. Finally, we change the codomain {Vec A (suc n)} of {\tt \_::\_} to \emph{C} resulting in an abstract syntax tree representation of the type {\tt c2}. We repeat this process for each of the constructors.

\begin{figure}
\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = single]
(agda-sort (lit 0) [ "A" h]⇒                    -- A
 (def (quote Nat) [] [ "n" h]⇒                  -- n
  (def (quote Vec) (vArg (var 1 []) ::           -- Vec A n
     vArg (var 0 []) :: []) [ "_" v]⇒
   (agda-sort (lit 0) [ "C" v]⇒                 -- C
    (var 0 [] [ "_" v]⇒                         -- c1
     ((def (quote Nat) [] [ "m" h]⇒             -- c2
       (var 5 [] [ "x" v]⇒                      -- x
        (def (quote Vec) (vArg (var 6 []) ::     -- xs : Vec A m
           vArg (var 1 []) :: []) [ "xs" v]⇒  
             (var 4 [] [ "_" v]⇒ var 5 []))))   -- C → C
      [ "_" v]⇒ var 2 []))))))                  -- C
\end{Verbatim}
\endgroup
\end{center}
\caption{Abstract syntax tree for recursor {\tt f} on Vec}
\label{fig:ast-d}
\end{figure}

\normalsize

The variable {\tt c2} refers to the parameter and the index using de~Bruijn indices. During the construction of the output type {\tt c2}, the automation tool updates the de~Bruijn indices accordingly. The constructor {\tt data-type} contains the count \emph{cp} of parameters occurring in a defined type. It also encodes the constructors of the type as a list of \texttt{Name}s. Metaprograms can retrieve the index count by finding the difference between \emph{cp} and the length of the constructor list. Some constructors might not take the same number of indices as the parent type. For example, in the case of {\tt Vec}, the constructor {\tt []} excludes the index {\tt Nat} from its type. We do not have any reflection primitive to retrieve the index count from a constructor name. A workaround is to pass the index count of each constructor explicitly to the automation tool.\todo{This paragraph is doing two things at once: discussing fragments of the schematic presentation of the eliminator type that should have been at the beginning of the section, and talking about how to find those things in Agda. First give the idea, then give it's implementation.}

Once we have the AST of {\tt c2}, we can build the type of the recursion rule {\tt f} for {\tt Vec} (fig.\ref{fig:ast-d}). To encode the mapping {\tt Vec A n → C} in the recursion type, we need to declare {\tt C}. We can use the constructor {\tt agda-sort} to introduce the type {\tt (C : Set)}. The type of the recursion rule \emph{f} is given as follows.

\begin{center}
\begingroup
%\fontsize{8pt}{2pt}\selectfont
\begin{BVerbatim}
f : {A : Set} → {n : Nat} → Vec A n → 
  (C : Set) → 
  (c1 : C) → 
  (c2 : {m : Nat} → (x : A) → 
        (xs : Vec A m) → C → C) → 
  C
\end{BVerbatim}
\endgroup
\end{center}

\normalsize

%\begin{align}
%& f : (P : Set) \rightarrow  \nonumber \\
%& \hspace {0.5cm} (d : (A \rightarrow W) \rightarrow (A \rightarrow P) \rightarrow B \rightarrow W \rightarrow P \rightarrow P) \rightarrow \nonumber \\
%& \hspace {0.5cm} W \rightarrow P \nonumber
%\end{align}

The above type is declared using {\tt declareDef}. We can build the computation rule representing the action of function \emph{f} on {\tt []} and {\tt \_::\_} using {\tt clause} (fig.~\ref{fig:ast-cdef}). The first argument to {\tt clause} encodes variables corresponding to the above type, and it also includes the abstract representation of {\tt []},{\tt \_::\_} on which the pattern matching should occur. The second argument to clause, which is of type {\tt Term}, refers to the variables in the first argument using de~Bruijn indices, and it encodes the output of the action of function \emph{f} on {\tt []},{\tt \_::\_}. The constructor {\tt var} in {\tt Pattern} is used to introduce new variables in the {\tt clause} definition. The type {\tt Pattern} also has another constructor {\tt con} used to represent the pattern matching term. The type {\tt Term} has similar constructors {\tt var} and {\tt con}, but with different types, used to encode the output of the recursion rule. The computation rules corresponding to the above type is given as follows.\todo{This paragraph is also doing double duty: first extract the general description of the computation rules for an eliminator, put that earlier; and the talk about it's Agda realization as pattern matching, then how to write those patterns in metaprograms, goes here}

\begin{center}
\begingroup
%\fontsize{7pt}{2pt}\selectfont
\begin{BVerbatim}
f [] C c1 c2 = c1
f (x :: xs) C c1 c2 = c2 x xs (f xs C c1 c2)
\end{BVerbatim}
\endgroup
\end{center}

\normalsize


%\begin{equation}
%f (P, d, g (\alpha, \beta, \omega)) \equiv d (\alpha, f \circ \alpha, \beta, \omega, f (\omega)) \nonumber
%\end{equation}

\begin{figure}
\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = single]
(clause
  (vArg (con (quote _::_)                      -- _::_
          (vArg (var "x") ::                   -- x
           vArg (var "xs") :: []))             -- xs
   vArg (var "C") ::                           -- C
   vArg (var "c1") ::                          -- c1
   vArg (var "c2") :: [])                      -- c2
  (var 0                                       
    (vArg (var 4 []) ::                        -- x
     vArg (var 3 []) ::                        -- xs
     vArg (def f                               -- (f xs C c1 c2)
       (vArg (var 3 [])                        -- xs
        vArg (var 2 []) ::                     -- C
        vArg (var 1 []) ::                     -- c1
        vArg (var 0 []) :: [])))))             -- c2

\end{Verbatim}
\endgroup
\end{center}
\caption{Clause definition for the computation rule of \texttt{\_::\_}}
\label{fig:ast-cdef}
\end{figure}

\normalsize

A clause definition, which evaluates to the above computation rule of {\tt Vec} pattern matching on {\tt \_::\_}, is given in figure~\ref{fig:ast-cdef}. The de~Bruijn index reference increments right to left starting from the last argument.  The above clause definition is defined using {\tt defineFun} primitive, and the function \emph{f} is brought into scope by {\tt unquotedecl}.
\begin{figure}
\begin{center}
\begingroup
\begin{BVerbatim}
data W (A : Set) (B : A → Set) : Set where
  sup : (a : A) → (B a → W A B) → W A B
\end{BVerbatim}
\endgroup
\end{center}
\caption{W-Type}
\label{fig:W-type}
\end{figure}

Lets consider another example, the {\tt W}-type, to review the automation process for the recursion principle. {\tt W}-type has a constructor {\tt sup} given by the following type.

\begin{center}
\begingroup
\begin{BVerbatim}
sup : (a : A) → (B a → W A B) → W A B
\end{BVerbatim}
\endgroup
\end{center}

To define the action of a function {\tt f : W A B → C} on input {\tt sup}, we need a function {\tt d} of the following type.
\begin{center}
\begingroup
\begin{BVerbatim}
d : (a : A) → (B a → W A B) → (B a → C) → C
\end{BVerbatim}
\endgroup
\end{center}

The type of {\tt d} is built by traversing the AST of {\tt sup}. During the traversal of the AST of {\tt sup}, the first argument to {\tt sup}, which is a constant type {\tt A}, is copied directly into the AST of {\tt d}. The second argument {\tt (B a  → W A B)}, which is a function with co-domain {\tt W A B}, is modified to {\tt (B a  → W A B) → (B a → C)}. Finally, the co-domain {\tt W A B} of {\tt sup} is replaced by {\tt C}. The computation rule corresponding to {\tt sup} is given as follows.
\begin{center}
\begingroup
\begin{BVerbatim}
f (sup a b) C d = d a b (λ v → f (b v) C d)
\end{BVerbatim}
\endgroup
\end{center}

In the above computation rule, the third argument to {\tt d} is a composition of functions {\tt f} and {\tt b}. The automation tool composes functions inside a lambda directly, using the \texttt{Term} constructor {\tt lam}. The arguments to {\tt lam} are referenced using de~Bruijn indices inside the lambda body. So, the de~Bruijn indices for referring variables outside the lambda body are updated accordingly. For example, inside the lambda body, the reference {\tt 0} refers to the lambda argument {\tt v}, and the index references to the variables outside the lambda body start from 1 and increment towards the left.

In the automation tool, {\tt generateRec} interface is used to generate the recursion rule $f$. The implementation of {\tt generateRec} is given as follows.

\begin{center}
\begingroup
%\fontsize{7pt}{9pt}\selectfont
\begin{BVerbatim}
generateRec : Arg Name → Name → 
  (indexList : List Nat) → TC ⊤
generateRec (arg i f) t indLs =
  do indLs' ← getIndex t indLs
     cns ← getConstructors t
     lcons ← getLength cns
     cls ← getClause lcons zero t f indLs cns
     RTy ← getType t
     funType ← getRtype t indLs' zero RTy
     declareDef (arg i f) funType
     defineFun f cls
\end{BVerbatim}
\endgroup
\end{center}

\normalsize

{\tt generateRec} uses {\tt getClause} and {\tt getRtype} to build the computation and elimination rules respectively. It takes three arguments: the name of the function to be defined (represented by an element of type {\tt Arg Name}), the quoted {\tt Name} of the type and a list containing the index count of the individual constructors. {\tt generateRec} can be used to automate the generation of recursion rules for inductive types having the general schema given at the beginning of this section. The recursion rule generated by {\tt generateRec} is brought into scope using {\tt unquoteDecl} as follows.

\begin{center}
\begingroup
%\fontsize{8pt}{9pt}\selectfont
\begin{BVerbatim}
unquoteDecl f = generateRec (vArg f)
                  (quote Vec) 
                  (0 :: 1 :: [])
\end{BVerbatim}
\endgroup
\end{center}

\normalsize

The third argument to {\tt generateRec} is a list consisting of the index count for the constructors. It is required to pass the index count for each constructor explicitly as the Agda reflection library does not have built-in primitives to retrieve the index value.

\subsection{Dependent Eliminators}
\label{sec:sec3.2}

The dependent eliminator for a datatype, also known as the \emph{induction principle}, is used to eliminate elements of a datatype when the type resulting from the elimination mentions the very element being eliminated. We can define the general schema for the induction principle as follows.
\begin{center}
\begingroup
\fontsize{7.9pt}{2pt}\selectfont
\begin{align}
& f' \, : \, \{x_1:P_1\}\ldots\{x_n:P_n\} \rightarrow \{k_1:Q_1\} \rightarrow\ldots\rightarrow \{k_n:Q_n\} \rightarrow \nonumber \\
& \hspace{0.4cm} (d : D \, x_1 \dots x_n \, k_1 \ldots k_n) \rightarrow (C : D \rightarrow Set) \rightarrow \nonumber \\
& \hspace{0.4cm} (c_1 : \{i_1:Q_1\} \rightarrow\ldots\rightarrow \{i_n:Q_n\} \rightarrow A{_1}^* \rightarrow C (g_1 ...)) \rightarrow \nonumber \\
& \hspace{0.4cm} (c_n : \{j_1:Q_1\} \rightarrow\ldots\rightarrow \{j_n:Q_n\} \rightarrow A{_n}^* \rightarrow C (g_n ...)) \rightarrow C \, d \nonumber \\ \nonumber 
\end{align}
\endgroup
\end{center}
\normalsize

For the inductive type $W$, the induction principle says that to define a mapping $f' : (w : W A B) \rightarrow P(w)$, it suffices to define the action of $f'$ on $g$. To define the action of $f'$ on $g$, we need an element of the following type.\todo{This is totally opaque to me - is this Martin-Löf's W, or is it something generic? And why is it in math notation?}
\begin{equation}
d' : \prod_{\alpha : A \rightarrow W} (\prod_{a : A} P(\alpha (a))) \rightarrow  \prod_{\beta : B} \prod_{\omega : W} P(\omega) \rightarrow P (g(\alpha, \beta, \omega)) \nonumber
\end{equation}

In the first argument of $d'$, the type $P$ depends on the action of the function $\alpha$\todo{This is usually reserved for paths - better not to use it here} on input $a : A$. In the second argument, it depends on the input element $\omega : W$. The output of function $d'$ depends on the action of constructor $g$ on inputs $\alpha$, $\beta$, and $\omega$.

To build the dependent eliminator, we need the type of the function $d'$. We can construct the abstract syntax tree of $d'$ using the static type information obtained from $g$. To construct $d'$, during the traversal of the abstract syntax tree of $g$, when we identify a function $\alpha$ with codomain \emph{W}, we add a new function with the same argument {\tt A} as in $\alpha$ and codomain \emph{P}, which depends on the action of $\alpha$ on {\tt (a : A)}. We copy the constant \emph{B} directly without any changes as in the case of the non-dependant eliminator. When we see $(\omega : W)$ in a non-codomain position, we add the type \emph{P}, which depends on the element $\omega$, next to it. Finally, the output type \emph{W} of the constructor $g$ is changed to \emph{P}, which depends on the action of the constructor $g$ on inputs $\alpha$, $\beta$ and $\omega$ (fig.~\ref{fig:ast-d'}).

%%% For readability, the contents of a parenthesis should never be indented less than the opening paren. That makes it really hard to follow it with your eye and see the nesting structure. I rearranged this one, but it got longer, and should probably be rearranged better than I did - DTC

\begin{figure}
\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = single]
(pi (vArg
     (pi (vArg `A) (abs "_" `W)))                -- α : A → W
 (abs "_"
  (pi (vArg                          -- A → P(α(a))
       (pi (vArg `A)                               -- a : A
        (abs "_"
         (var 2                             -- P(α(a))
          (vArg
           (var 1                                -- α ref
            (vArg (var 0 []) :: [])) :: [])))))         -- a ref
   (abs "_"
    (pi (vArg `B)                      -- β : B
     (abs "_"
      (pi (vArg `W)                      -- ω : W
       (abs "_"
        (pi (vArg
             (var 4                   -- P(ω)
              (vArg (var 0 []) :: [])))                   -- ω ref
         (abs "_"
          (var 5                             -- P(g i β ω)
           (vArg
            (con (quote g)                        -- g ref
             (vArg (var 4 []) ::                         -- α ref
              vArg (var 2 []) ::                         -- β ref
              vArg (var 1 []) :: [])) :: []))))))))))))  -- ω ref
\end{Verbatim}
\endgroup
\end{center}
\caption{Abstract syntax tree for constructor $d'$}
\label{fig:ast-d'}
\end{figure}

\normalsize

We can construct the type of the induction principle $f'$\texttt{Why should it be called f'? That seems needlessly opaque.} using $d'$ . The type \emph{P} \todo{Pick a consistent name for the motive - C or P, but not switching between them without a good reason} in the mapping $f'$ depends on the element of the input type \emph{W}. The following equation\todo{this is not an equation} gives the type of the induction principle $f'$.
\begin{align}
& f' : (P : W \rightarrow Set) \rightarrow \nonumber \\
& \hspace {0.6cm} (d' : \prod_{\alpha : A \rightarrow W} (\prod_{a : A} P(\alpha (a))) \rightarrow \prod_{\beta : B} \prod_{\omega : W} P(\omega) \rightarrow \nonumber \\
& \hspace {1.6cm} P (g(\alpha, \beta, \omega))) \rightarrow \nonumber \\
& \hspace {0.6cm} (w : W) \rightarrow P (w) \nonumber
\end{align}

The computation rule corresponding to the above type is the same as the computation rule of the recursion principle of \emph{W}, except that the function \emph{f} and $d$ are changed to \emph{f'} and $d'$ respectively. It is constructed using {\tt clause} definitions following the same approach as the recursion principle. The computation rule corresponding to \emph{f'} is given as follows.
\begin{equation}
f' (P, d', g (\alpha, \beta, \omega)) \equiv d' (\alpha, f' \circ \alpha, \beta, \omega, f' (\omega)) \nonumber
\end{equation}

We can automate the generation of the induction rule $f'$ and its corresponding computation rules for the type \emph{W} using {\tt generateInd} interface. The following code gives the implementation of {\tt generateInd}.

\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}
generateInd : Arg Name → Name → (indexList : List Nat) → TC ⊤
generateInd (arg i f) t indLs =
  do indLs' ← getIndex t indLs
     cns ← getConstructors t
     lcons ← getLength cns
     cls ← getClauseDep lcons zero t f indLs' cns
     RTy ← getType t
     funType ← getRtypeInd t zero indLs' RTy
     declareDef (arg i f) funType
     defineFun f cls
\end{Verbatim}
\endgroup
\end{center}

\normalsize

{\tt generateInd} uses {\tt getClauseDep} to generate the {\tt clause} definitions representing the computation rule of the type \emph{W}. The abstract representation of the type of \emph{W} is provided by {\tt getRtypeInd}. $f'$ generated by {\tt generateInd} is brought into scope by {\tt unquoteDecl} as follows.
\begin{center}
\begingroup
\fontsize{8pt}{9pt}\selectfont
\begin{Verbatim}
unquoteDecl f' = generateInd (vArg f') (quote W) []
\end{Verbatim}
\endgroup
\end{center}
\normalsize

We pass an empty list to {\tt generateInd}, because the type \emph{W} has no index. We can also pass an empty list if all the constructors of a type has the same number of index as the parent type. But if any one constructor has an index count different from the index count of the parent type, then we have to explicitly pass the index count of all the constructors.\todo{Remove the use of ``we'' from this paragraph.}

\section{Code Generation for Higher Inductive Types}
\label{sec:sec4}

In Agda, there are no built-in primitives to support the definition of higher inductive types. However, we can still define a higher inductive type with a base type using Dan Licata's \citep{Licata-2011} method as discussed in section 2.1. In this section, we discuss the automation of code generation for the boiler-plate code segments defining the higher inductive type. We also describe how to automate the code generation for the elimination and the computation rules of the higher inductive type using static type information obtained from the base type.


\subsection{Higher Inductive Type Definition}
\label{sec:sec4.1}

In Agda, we define an inductive type using {\tt data} keyword. The {\tt data} literal characterize a data type by declaring its type and specifying its constructors. Consider the following generic form for the definition of an inductive type \emph{W} with constructors $g_1 \ldots g_n$.
\begin{center}
\begingroup
\fontsize{7.9pt}{0pt}\selectfont
\begin{align}
& data \hspace{0.2cm} W^* \hspace{0.2cm} (x_1:P_1)\ldots(x_n:P_n) : Q_1 \rightarrow\ldots\rightarrow Q_n \rightarrow Set \, \ell \, \, where \nonumber \\
& \hspace{0.3cm} g_1^* : \{i_1 : Q_1\} \ldots \{i_n : Q_n\} \rightarrow Type_1\rightarrow W^* x_1 \ldots x_n \, i_1 \ldots i_n \nonumber \\
& \hspace{3.5cm} \vdots \nonumber \\
& \hspace{0.3cm} g_n^* : \{j_1 : Q_1\} \ldots \{j_n : Q_n\} \rightarrow Type_n\rightarrow W^* x_1 \dots x_n \, j_1 \ldots j_n \nonumber \\ \nonumber
\end{align}
\endgroup
\end{center}
\normalsize

The parameters $(x_1:P_1)\ldots(x_n:P_n)$ are common to all the constructors, and the type of each constructor implicitly encodes the parameter references. However, the indices are different for each constructor. So, the type of each constructor explicitly exhibits the index declaration. During the construction of a higher inductive type, we have to represent the parameters and the indices as explicit arguments in the type of the constructors. We define a higher inductive type $W$ as a top-level definition using a base type $W^*$ similar to the module {\tt Circle} in section 2.1. The reflection type {\tt Definition} provides us the type and the constructors of the base type $W^*$. We copy the type of $W^*$ to $W$ and for the constructors $g_1 \ldots g_n$ of $W$, we traverse the abstract representation of the type of $g_1^* \ldots g_n^*$ respectively replacing the occurrence of $W^*$ to $W$ in every strict positive position. Consider a constructor $g_i^*$ having the following type.
\begin{equation}
g_i^* : (A \rightarrow W^*) \rightarrow (B \rightarrow W^*) \rightarrow C \rightarrow W^* \rightarrow W^* \nonumber
\end{equation}

We built the type of $g_i$ by traversing the abstract syntax tree of $g_i^*$ and replacing the base type $W^*$ with the higher inductive type $W$. The abstract syntax tree of $g_i^*$ incorporates the type of the parameters and the indices if present. We have to retain the parameters and the indices explicitly during the construction of $g_i$. The following equation \todo{This is not an equation.} represents the type of the constructor $g_i$.
\begin{equation}
g_i : (A \rightarrow W) \rightarrow (B \rightarrow W) \rightarrow C \rightarrow W \rightarrow W \nonumber
\end{equation}

We explicitly pass the type of the path constructors to the automation tool. The higher inductive type definition of {\tt Circle} in section 2.1 represents the path constructors as propositional equalities. The automation tool takes the path types as input and declares them as propositional equalities using the reflection primitive {\tt declarePostulate}. We introduce a new data type {\tt ArgPath} to input the path types to the automation tool.
\begin{center}
\begingroup
\fontsize{7.9pt}{0pt}\selectfont
\begin{align}
& data \hspace {0.1cm} ArgPath \hspace {0.1cm} \{\ell_1\} : Set \hspace {0.1cm} (lsuc \hspace {0.1cm} \ell_1) \hspace {0.1cm} where \nonumber \\
& \hspace {0.4cm} argPath : Set \hspace {0.1cm} \ell_1 \rightarrow ArgPath \nonumber \\ \nonumber
\end{align}
\endgroup
\end{center}
\normalsize

The constructor $argPath$ takes the type of a path constructor as input. We define the generic form of a higher inductive type as follows.
\begin{center}
\begingroup
\fontsize{7.9pt}{0pt}\selectfont
\begin{align}
& data{\text -}hit \hspace {0.1cm} (quote \hspace {0.1cm} W^*) \hspace {0.1cm} W \nonumber \\
  & \hspace {0.3cm} Wpoints \hspace {0.2cm} (g_1 ::  \ldots :: g_n :: []) \nonumber \\
  & \hspace {0.3cm} Wpaths  \hspace {0.2cm} (p_1 :: \ldots :: p_n :: []) \nonumber \\
  & \hspace {0.3cm} (argPath \nonumber \\
  & \hspace {0.6cm} (\{x_1:P_1\} \rightarrow \ldots \rightarrow \{x_n:P_n\} \rightarrow \nonumber \\
  & \hspace {0.7cm} \{i_1:Q_1\} \rightarrow \ldots \rightarrow \{i_n:Q_n\} \rightarrow Type_1 \rightarrow \nonumber \\
  & \hspace {0.7cm} (g_i \{x_1\} \ldots \{x_n\} \{i_1\} \ldots \{i_n\} \ldots) \equiv (g_j \ldots)) :: \nonumber \\
  & \hspace {3cm} \vdots \nonumber \\
  & \hspace {0.4cm} argPath \nonumber \\
  & \hspace {0.6cm} (\{x_1:P_1\} \rightarrow \ldots \rightarrow \{x_n:P_n\} \rightarrow \nonumber \\
  & \hspace {0.7cm} \{j_1:Q_1\} \rightarrow \ldots \rightarrow \{j_n:Q_n\} \rightarrow Type_n \rightarrow \nonumber \\
  & \hspace {0.7cm} (g_i \{x_1\} \ldots \{x_n\} \{j_1\} \ldots \{j_n\} \ldots) \equiv (g_j \ldots)) :: [])\nonumber \\ \nonumber
\end{align}
\endgroup
\end{center}
\normalsize

We define holders $Wpoints$ for point constructors and $Wpaths$ for path constructors as part of the higher inductive type definition of $W$. We cannot retrieve the constructors of the higher inductive type $W$ using {\tt Definition}. Therefore, $Wpoints$ and $Wpaths$ act as the only references for the constructors of $W$. The elements of the $argPath$ list represent the type of the path constructors $p_1 \ldots p_n$ respectively. We explicitly include the parameter references $\{x_1 : P_1\} \ldots \{x_n : P_n\}$ and the index references $\{k_1 : Q_1\} \ldots \{k_n : Q_n\}$ in the type of the arguments to $argPath$. The points $g_1 \ldots g_n$ are not in scope when used in the identity type passed to $argPath$. The automation tool uses the base type constructors $g_1^* \ldots g_n^*$ as dummy arguments in the place of $g_1 \ldots g_n$ respectively. The automation tool implements the interface {\tt data-hit} as follows.

\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}
data-hit : ∀{ℓ₁} (baseType : Name) → (indType : Name) →
  (pointHolder : Name) → (lcons : List Name) →
  (pathHolder : Name) → (lpaths : List Name) →
  (lpathTypes : (List (ArgPath {ℓ₁}))) → TC ⊤
data-hit baseType indType pointHolder lcons pathHolder lpaths lpathTypes =
  do defineHindType baseType indType
     lcons' ← getConstructors baseType
     defineHitCons baseType indType lcons' lcons
     lpathTypes' ← getPathTypes baseType indType lcons' lcons lpathTypes
     defineHitPathCons lpaths lpathTypes'
     definePointHolder pointHolder lcons
     definePathHolder pathHolder lpaths
\end{Verbatim}
\endgroup
\end{center}

The higher inductive type $W$, the points $g_1 \ldots g_n$, the paths $p_1 \ldots p_n$, and the holders $Wpoints$ and $Wpaths$ are brought into scope by {\tt unquoteDecl}. In the above implementation of {\tt data-hit}, {\tt defineHindType} defines the higher inductive type as a top-level definition using the base type. {\tt defineHitCons} specifies the point constructors of the higher inductive type using the type information obtained from the constructors of the base type, and {\tt defineHitPathCons} builds the paths constructors of the higher inductive type using the {\tt argPath} list. The following code automates the generation of the higher inductive type definition for {\tt Circle} given in section 2.1.
\begin{center}
\begingroup
\fontsize{8pt}{9pt}\selectfont
\begin{Verbatim}

  unquoteDecl S Spoints base Spaths loop =
    data-hit (quote S*) S
      Spoints (base :: []) -- point constructors
      Spaths (loop :: [])  -- path constructors
      (argPath (base* ≡ base*) :: []) -- base replaces base*

\end{Verbatim}
\endgroup
\end{center}

The identity type input {\tt (base* ≡ base*)} to argPath represents the type of the path {\tt loop}, and it uses the inductive type constructor {\tt base*} as a dummy argument in the place of the higher inductive type constructor {\tt base}. The constructor {\tt base} comes into scope only during the execution of {\tt unquoteDecl}, and so cannot be used in the identity type reference in {\tt argPath}. We use the constructor {\tt base*} of type {\tt S*} as dummy argument because the type of {\tt base*} is similar to {\tt base}, and has the same references for the common arguments. The automation tool traverses the abstract syntax tree of {\tt loop} and replaces the occurrences of {\tt base*} with {\tt base}.

\subsection{Non-dependent Eliminator}
\label{sec:sec4.2}

Non-dependent eliminator or the recursion principle of a higher inductive type $W$ maps the points and paths of $W$ to an output type $P$. Let $g_1 : A \rightarrow W$ and $g_2 : B \rightarrow W$ be the point constructors, and $l : (\alpha : A) \rightarrow (\beta : B) \rightarrow (g_1 \, \alpha) \equiv (g_2 \, \beta)$ be the path constructor of $W$. To define a mapping $f : W \rightarrow P$, we need points $d_1 : A \rightarrow P$ and $d_2 : B \rightarrow P$ and a path $h : (\alpha : A) \rightarrow (\beta : B) \rightarrow (d_1 \, \alpha) \equiv (d_2 \, \beta)$ in the space $P$. The path constructor $l$ can take arguments of any type including the higher inductive type $W$ but for simplicity we will consider only arguments of constant type.

To construct the recursion principle $f$, we need to build the type of points $d1, d2$ and path $h$. The type of $d1$ and $d2$ are built from the abstract syntax tree of points $g1$ and $g2$ respectively using the approach described in section \eqref{sec:sec3.1}. We build the type of $h$ by traversing the abstract syntax tree of $l$. During the traversal, we replace the points $g_1$ and $g_2$, which are arguments to the identity type, in the co-domain of the path $l$ by the points $d_1$ and $d_2$ respectively. In figure \eqref{fig:ast-f}, the arguments of the identity type in the abstract syntax tree of $h$ references the points $d_1$ and $d_2$ using de~Bruijn index 3 and 2 respectively. We copy the other two arguments of $l$, which are of constant type $A$ and $B$, without any changes into the type of $h$.

\begin{figure}
\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = single]

   (pi (vArg (agda-sort (lit 0)))                  -- P
      (abs "P"
   (pi (vArg (pi (vArg (def (quote A) []))         -- d₁ : A → P
      (abs "_" (var 1 []))))                       -- P ref
      (abs "d₁"
   (pi (vArg (pi (vArg (def (quote B) []))         -- d₂ : B → P
      (abs "_" (var 2 []))))                       -- P ref
      (abs "d₂"
   (pi (vArg                                       -- h
      (pi (vArg (def (quote A) []))                -- α : A
      (abs "α"
      (pi (vArg (def (quote B) []))                -- β : B
      (abs "β"
      (def (quote _≡_)
         vArg (var 3                               -- d₁ ref
            (vArg (var 1 []) :: [])) ::            -- α ref
         vArg (var 2                               -- d₂ ref
            (vArg (var 0 []) :: [])) :: []))))))   -- β ref
      (abs "h"
   (pi (vArg (def (quote W) []))                   -- W → P
      (abs "_" (var 4 [])))))))))))

\end{Verbatim}
\endgroup
\end{center}
\caption{Abstract syntax tree for constructor $f$}
\label{fig:ast-f}
\end{figure}

The recursion rule $f$ corresponding to figure \eqref{fig:ast-f} is given by the following equation\todo{This is not an equation}.
\begin{align}
& f : (P : Set) \rightarrow (d_1 : A \rightarrow P) \rightarrow (d_2 : B \rightarrow P) \rightarrow \nonumber \\
& \hspace {0.4cm} (h : (\alpha : A) \rightarrow (\beta : B) \rightarrow (d_1 \, \alpha) \equiv (d_2 \, \beta)) \rightarrow \nonumber \\
& \hspace {0.4cm} W \rightarrow P \nonumber
\end{align}
The computation rules for constructors $g_1$ and $g_2$ give the action of eliminator $f$ on input $g_1 (\alpha)$ and $g_2 (\beta)$ respectively. The computation rules say that the function $f$ maps the points $g_1 (\alpha)$ and $g_2 (\beta)$ to the points $d_1 (\alpha)$ and $d_2 (\beta)$ respectively in the output type $P$. We specify the clause definition to build the computation rules for $g_1$ and $g_2$ in the same way as for a regular inductive type (sec.~\ref{sec:sec3.1}) except that the clause definition for the higher inductive type $W$ has an additional reference variable to the path $h$. The following definitional equalities give the computation rules for $g_1$ and $g_2$.
\begin{align}
f (P, d_1, d_2, h, g_1 (\alpha)) \equiv d_1 (\alpha) \nonumber \\
f (P, d_1, d_2, h, g_2 (\beta)) \equiv d_2 (\beta) \nonumber
\end{align}

The computation rule for the path constructor $l$ defines the action of function $f$ on the path $(l \, \alpha \, \beta)$. In type theory, the functions are functorial, and they preserve the path structures in their mapping to the output type \citep{HoTT-2013}. The function $ap_f$ \eqref{eq:ap} defines the action of the non-dependent eliminator $f$ on the path $l$. Using \eqref{eq:ap}, we can build the computation rule for the path $l$ as follows.
\begin{align}
& \beta_f : (P : Set) \rightarrow (d_1 : A \rightarrow P) \rightarrow (d_2 : B \rightarrow P) \rightarrow \nonumber \\
& \hspace {0.4cm} (h : (\alpha : A) \rightarrow (\beta : B) \rightarrow (d_1 \,  \alpha) \equiv (d_2 \, \beta)) \rightarrow \nonumber \\
& \hspace {0.4cm} \{\alpha : A\} \rightarrow \{\beta : B\} \rightarrow \nonumber \\
& \hspace {0.4cm} ap_{(\lambda x \rightarrow f(P, d_1, d_2, h, x))}(l \, \alpha \, \beta) \equiv (h \, \alpha \, \beta) \nonumber
\end{align}

The computation rule $\beta_f$ exists only as propositional equality. We build the type of $\beta_f$ using the same approach as for the recursion rule $f$. The type of $f$ and $\beta_f$ is identical except for the mapping $W \rightarrow P$ in $f$ which is replaced by the term representing the action of function $f$ on the path $(l \, \alpha \, \beta)$. The function $ap$ applies $f$, which is nested inside a lambda function, on the arguments $(g_1 \, \alpha)$ and $(g_2 \, \beta)$ of the path $(l \, \alpha \, \beta)$. We use the constructor {\tt lam} of {\tt Term} to introduce the lambda function with argument {\tt x} (fig.~\ref{fig:ast-beta-f}). Inside the lambda body, the argument {\tt x} gets a de~Bruijn index reference of zero and we update the remaining de~Bruijn indices accordingly. The application of function $f$ to the path $(l \, \alpha \, \beta)$ substitutes the points $(g_1 \, \alpha)$ and $(g_2 \, \beta)$ for the lambda argument {\tt x}, and it evaluates to the path $(h \, \alpha \, \beta)$ in the output type $P$. We implement the {\tt generateRecHit} interface as follows.

\begin{figure}
\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = single]

   (def (quote _≡_)
      (vArg (def (quote ap)                        -- ap
         (vArg (lam visible (abs "x"               -- x
            (def (quote f)                         -- f
               (vArg (var 6 []) ::                 -- P ref
                vArg (var 5 []) ::                 -- d₁ ref
                vArg (var 4 []) ::                 -- d₂ ref
                vArg (var 3 []) ::                 -- h ref
                vArg (var 0 []) :: [])))) ::       -- x ref
          vArg (def (quote l)                      -- l
             (vArg (var 1 []) ::                   -- α ref
              vArg (var 0 []) :: [])) :: [])) ::   -- β ref
          vArg (var 2                              -- h ref
             (vArg (var 1 []) ::                   -- α ref
              vArg (var 0 []) :: [])) :: []))      -- β ref

\end{Verbatim}
\endgroup
\end{center}
\caption{Abstract syntax tree for the term representing the action of function $f$ on path $l$}
\label{fig:ast-beta-f}
\end{figure}

\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = lines, rulecolor=\color{blue}, numbers = left, numbersep = 0pt]
generateRecHit : Arg Name → List (Arg Name) →
  (baseType : Name) → (indexList : List Nat) →
  (baseRec : Name) → (indType : Name) →
  (points : List Name) → (paths : List Name) → TC ⊤
generateRecHit (arg i f) argD baseType indLs baseRec indType points paths =
  do lcons ← getConstructors baseType
     lpoints ← getLength points
     lpaths ← getLength paths
     clauses ← getPathClause lpoints lpaths baseRec
     RTy ← getType baseType
     funTypePath ← getRtypePath baseType indType baseRec indLs paths zero RTy
     declareDef (arg i f) funTypePath
     defineFun f clauses
     generateβRecHit argD baseType indLs baseRec indType f points paths
\end{Verbatim}
\endgroup
\end{center}

{\tt generateRecHit} takes the base type recursion rule as input and uses that to map the points $g_1 (\alpha)$ and $g_2 (\beta)$ to $d_1 (\alpha)$ and $d_2 (\beta)$ respectively in the abstract syntax tree of the path $(l \, \alpha \, \beta)$. The second argument {\tt argD} is a list of terms representing the computation rules for the path constructors. The {\tt generateβRecHit} interface takes {\tt argD} as input and builds the computation rule for the path constructor $l$. Other inputs to {\tt generateRecHit} are the point and path holders declared during the higher inductive type definition of $W$. The following automation code generates the recursion rule and the computation rules for {\tt Circle}.

\begin{center}
\begingroup
\fontsize{8pt}{9pt}\selectfont
\begin{Verbatim}

  unquoteDecl recS₁* = generateRec (vArg recS₁*)
                          (quote S₁*) (0 :: [])

  unquoteDecl recS₁ βrecS₁ = generateRecHit (vArg recS₁)
                                ((vArg βrecS₁) :: [])
                                (quote S₁*) (0 :: [])
                                (quote recS₁*)
                                (quote S₁) S₁points S₁paths

\end{Verbatim}
\endgroup
\end{center}

The term {\tt βrecS₁} represents the computation rule for the path constructor {\tt loop} and is brought into scope by {\tt unquoteDecl}.

\subsection{Dependent Eliminator}
\label{sec:sec4.3}

Dependent eliminator or the induction principle of a higher inductive type $W$ is a dependent function that maps an element $\omega$ of $W$ to an output type $P \, \omega$. For the type $W$ with point constructors $g_1 : A \rightarrow W$ and $g_2 : B \rightarrow W$ and path constructor $l : (\alpha \rightarrow A) \rightarrow (\beta \rightarrow B) \rightarrow (g_1 \, \alpha) \equiv (g_2 \, \beta)$, to define a mapping $f' : (\omega : W) \rightarrow P \, \omega$, we need $d_1 : (\alpha : A) \rightarrow P \, \alpha$, $d_2 : (\beta : B) \rightarrow P \, \beta$, and $h : (\alpha \rightarrow A) \rightarrow (\beta : B) \rightarrow transport \, P \, (l \, \alpha \, \beta) \, (d_1 \, \alpha) \equiv (d_2 \, \beta)$, where $(h \, \alpha \, \beta)$ is a heterogeneous path transported over $(l \, \alpha \, \beta)$ lying in the space $P \, \beta$. Equation\todo{Not an equation, just do a page ref} \eqref{eq:transport} gives the type of $transport$.

\begin{figure}
\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = single]

  (pi (vArg (`W `⇒ agda-sort (lit 0)))
     (abs "P"
  (pi (vArg
     (pi (vArg `A)
     (abs "α"
     (var 1 (vArg (con (quote g₁)
              (vArg (var 0 []) :: [])) :: [])))))
     (abs "d₁"
  (pi (vArg
     (pi (vArg `B)
     (abs "β"
     (var 2 (vArg (con (quote g₂)
              (vArg (var 0 []) :: [])) :: [])))))
     (abs "d₂"
  (pi (vArg
     (pi (vArg `A)
     (abs "α"
     (pi (vArg `B)
     (abs "β"
     (def (quote _≡_)
       (vArg (def (quote transport)
         (vArg (var 4 []) ::
          vArg (def (quote l) (vArg (var 1 []) ::
          vArg (var 0 []) :: [])) ::
          vArg (var 3 (vArg (var 1 []) :: [])) :: [])) ::
       vArg (var 2 (vArg (var 0 []) :: [])) :: [])))))))
     (abs "h"
  (pi (vArg `W)
     (abs "ω" (var 4 (vArg (var 0 []) :: [])))))))))))

\end{Verbatim}
\endgroup
\end{center}
\caption{Abstract syntax tree of function $f'$}
\label{fig:ast-ind-f'}
\end{figure}

In the abstract syntax tree of $f'$ (fig. \ref{fig:ast-ind-f'}), the type of constructors $d_1$ and $d_2$ are built from the type of $g_1$ and $g_2$ respectively using the same approach as in section \eqref{sec:sec3.2}. When building the type of $d_1$, we copy the constant argument $A$ directly into the abstract syntax tree of $d_1$, and for the codomain P, which depends on the action of constructor $g_1$ on the constant argument $\alpha : A$, we pass the de~Bruijn index reference of $\alpha$ as an argument to the constructor $g_1$ built using the reflection construct {\tt con}. Similarly, for $d_2$, we copy the type $B$ directly into the abstract syntax tree of $d_2$ and pass the de~Bruijn index of $\beta : B$ to the constructor $g_2$ in the co-domain. We build the type of path $h$ by traversing the abstract syntax tree of $l$ and adding relevant type information into it. We copy the constant arguments of type $A$ and $B$ without modification. For the codomain of $l$, which is the identity type $(g_1 \, \alpha) \equiv (g_2 \, \beta)$, we insert the quoted {\tt name} of function $transport$ with arguments $P$, the path $(l \, \alpha \, \beta)$ and $(d_1 \, \alpha)$. We apply the base eliminator to the arguments of the path $(l \, \alpha \, \beta)$ to form the elements $(d_1 \, \alpha)$ and $(d_2 \, \beta)$. The following declaration gives the type of $f'$ corresponding to figure \eqref{fig:ast-ind-f'}.
\begin{align}
& f' : (P : W \rightarrow Set) \rightarrow \nonumber \\
& \hspace {0.6cm} (d_1 : (\alpha : A) \rightarrow P (g_1 \, \alpha)) \rightarrow (d_2 : (\beta : B) \rightarrow P (g_2 \, \beta)) \rightarrow \nonumber \\
& \hspace {0.6cm} (h : (\alpha : A) \rightarrow (\beta : B) \rightarrow \nonumber \\
& \hspace {1.2cm} transport \, P \, (l \, \alpha \, \beta) (d_1 \, \alpha) \equiv (d_2 \, \beta)) \rightarrow \nonumber \\
& \hspace {0.6cm} (\omega : W) \rightarrow P (\omega) \nonumber
\end{align}

We build the computation rules corresponding to the mapping $f'$ for the point constructors $g_1$ and $g_2$ using the same approach as for the non-dependent eliminator $f$. The following equations give the computation rules for the point constructors $g_1$ and $g_2$.
\begin{align}
f' (P, d_1, d_2, h, g_1 (\alpha)) \equiv d_1 (\alpha) \nonumber \\
f' (P, d_1, d_2, h, g_2 (\beta)) \equiv d_2 (\beta) \nonumber
\end{align}

The computation rule $\beta_{f'}$ for the heterogeneous path $h$ depends on $apd$ \eqref{eq:apd} which gives the action of dependent function $f'$ on the path $h$. We build the type of $\beta_{f'}$ using \eqref{eq:apd} as follows.
\begin{align}
&\beta_{f'} : (P : W \rightarrow Set) \rightarrow \nonumber \\
& \hspace {0.6cm} (d_1 : (\alpha : A) \rightarrow P (g_1 \, \alpha)) \rightarrow (d_2 : (\beta : B) \rightarrow P (g_2 \, \beta)) \rightarrow \nonumber \\
& \hspace {0.6cm} (h : (\alpha : A) \rightarrow (\beta : B) \rightarrow \nonumber \\
& \hspace {1.2cm} transport \, P \, (l \, \alpha \, \beta) (d_1 \, \alpha) \equiv (d_2 \, \beta)) \rightarrow \nonumber \\
& \hspace {0.6cm} apd_{(\lambda x \rightarrow f'(P, d_1, d_2, h, x))}(l \, \alpha \, \beta) \equiv (h \, \alpha \, \beta) \nonumber
\end{align}

\begin{figure}
\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = single]

   (def (quote _≡_)
      (vArg (def (quote apd)                       -- apd
         (vArg (lam visible (abs "x"               -- x
            (def (quote f')                        -- f
               (vArg (var 6 []) ::                 -- P ref
                vArg (var 5 []) ::                 -- d₁ ref
                vArg (var 4 []) ::                 -- d₂ ref
                vArg (var 3 []) ::                 -- h ref
                vArg (var 0 []) :: [])))) ::       -- x ref
          vArg (def (quote l)                      -- l
             (vArg (var 1 []) ::                   -- α ref
              vArg (var 0 []) :: [])) :: [])) ::   -- β ref
          vArg (var 2                              -- h ref
             (vArg (var 1 []) ::                   -- α ref
              vArg (var 0 []) :: [])) :: []))      -- β ref

\end{Verbatim}
\endgroup
\end{center}
\caption{Abstract syntax tree for the term representing the action of dependent function $f'$ on path $l$}
\label{fig:ast-beta-f'}
\end{figure}

We build the abstract syntax tree for the computation rule $\beta_{f'}$ in the same way as for induction principle $f'$. In the codomain of $\beta_{f'}$ (fig.~\ref{fig:ast-beta-f'}), which is an identity type, we insert the abstract representation of the function $apd$ with arguments $f'$, nested inside a lambda body, and the path $(l \, \alpha \, \beta)$. We pass the path $(h \, \alpha \, \beta)$, built using de~Bruijn indices, as the second argument to the identity type. The following code gives the implementation of the {\tt generateIndHit} interface in the automation tool.

\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}
generateIndHit : Arg Name → List (Arg Name) →
  (baseType : Name) → (indLs : List Nat) →
  (baseElm : Name) → (indType : Name) →
  (points : List Name) → (paths : List Name) → TC ⊤
generateIndHit (arg i f) argD baseType indLs baseRec indType points paths =
  do indLs' ← getIndex baseType indLs
     lcons ← getConstructors baseType
     lpoints ← getLength points
     lpaths ← getLength paths
     clauses ← getPathClauseDep lpoints lpaths baseType baseRec indLs' lcons
     RTy ← getType baseType
     funTypePath ← getRtypePathDep baseType indType baseRec points paths zero indLs' RTy
     declareDef (arg i f) funTypePath
     defineFun f clauses
     generateβIndHit argD baseType indLs baseRec indType f points paths
\end{Verbatim}
\endgroup
\end{center}

The interface {\tt generateIndHit} takes the base eliminator as an argument and uses that to map the point constructors $g_1$ and $g_2$ to output $d_1$ and $d_2$ when building the codomain of the path constructor $h$. {\tt generateβIndHit} builds the computation rule for the path constructor $h$. The following code builds the induction principle and the computation rules for {\tt Circle}.

\begin{center}
\begingroup
\fontsize{8pt}{9pt}\selectfont
\begin{Verbatim}

  unquoteDecl indS₁* = generateInd (vArg indS₁*)
                          (quote S₁*) []

  unquoteDecl indS₁ βindS₁ = generateIndHit (vArg indS₁)
                                ((vArg βindS₁) :: [])
                                (quote S₁*) []
                                (quote indS₁*)
                                (quote S₁) S₁points S₁paths

\end{Verbatim}
\endgroup
\end{center}

The primitive {\tt unquoteDecl} declares {\tt βindS₁} as a postulate. {\tt βindS₁} gives the action of dependent function {\tt indS₁} on the path constructor {\tt loop}.

\section{Application}

The field of homotopy type theory is less well-developed on the programming side. There are only few programming applications of homotopy type theory, and the role of computationally relevant equality proofs on programming is an area of active research. Applications such as homotopical patch theory \cite{Angiuli-2014} discuss the implementation of Darcs \cite{Darcs-2005} version control system using patch theory \cite{Mimram-2013} \cite{Jason-2009} in the context of homotopy type theory. Containers in homotopy type theory \cite{Altenkirch-2014} \cite{Abbott-2005} implement data structures such as multisets and cycles. The automation tool discussed in this paper abstracts away the difficulties involved in the implementation of a higher inductive type and its elimination rules. It introduces interfaces which simplify the intricacies of a higher inductive type definition and usage by automating the generation of the code segments defining the higher inductive type and its elimination rules. The automation tool is significant in reducing the development effort for existing applications, and it can also attract new programming applications in homotopy type theory.

In the next section, we discuss the implementation of patch theory application in Agda and exhibit a tremendous reduction in code size using the automation tool. In section \ref{crypto}, we present a cryptography application and discuss how to abstract the implementation difficulties of a higher inductive type making it more accessible to the cryptographers.

\subsection{Patch Theory Revisited}
\label{patch-theory}
A patch is a syntactic representation of a function that modifies a repository context when applied. For example, a patch $(s1 \leftrightarrow s2 \, @ \, l)$, which replaces string s1 with s2 at line l, when applied to a repository context with string s1 at line l results in a repository context with string s2 at line l. In homotopical patch theory \cite{Angiuli-2014}, the patches are modeled as paths in a higher inductive type. The higher inductive type representation of patches automatically satisfy groupoid laws such as the composition of patches is associative, and inverse composes to identity. Domain-specific laws related to the patches such as two swaps at independent lines commute are designed as higher dimensional paths. The computation content of the patches is extracted by mapping them to bijections in the universe with the help of univalence. Due to the functoriality of mappings in type theory, the functions preserve the path structures in their mapping to the universe.

We developed the patch theory application in Agda using Dan Licata's method \cite{Licata-2011}. We implemented basic patches like the insertion of a string as line l1 in a file and deletion of a line l2 from a file. The functions implementing insertion and deletion in the universe are not bijective. So, to map the paths representing the patches insert and delete into the universe, we used the patch history approach \cite{Angiuli-2014}. According to this approach, we developed a separate higher inductive type $History$ which serves as the types of patches. In addition to basic patches, we also implemented patches of encryption using cryptosystems like rsa \cite{Rivest-1978} and paillier \cite{Paillier-1999}.

We used the automation tool described in this paper to generate code for the higher inductive type definition representing $History$ and the repository context $cryptR$ for the patches. We also automated the code generation for the elimination and the computation rules for the higher inductive types $History$ and $cryptR$. In addition to abstracting the implementation difficulties of higher inductive types, the automation tool helped us to achieve an extensive reduction in the code size of the original application. We were able to automate the generation of approximately 1500 lines of code with just about 70 lines of automation code. The automation massively reduced the code size of the application which is about 2500 lines resulting in 60\% reduction in the original code size.

\subsection{Cryptography}
\label{crypto}
The work of \cite{Paventhan-2018} applies the tools of homotopy type theory for cryptographic protocol implementation. It introduces a new approach for the formal specification of cryptographic schemes using types. The work discusses modeling $cryptDB$ \citep{Popa-2011} using a framework similar to patch theory. CryptDB employs layered encryption techniques and demonstrates computation on top of encrypted data. We can implement cryptDB by modeling the database queries as paths in a higher inductive type and mapping the paths to the universe using singleton types \cite{Angiuli-2014}. The automation tool can be applied to generate code for the higher inductive type representing cryptDB and its corresponding elimination and computation rules. By using the automation tool, we can abstract the convolutions of homotopy type theory thus making it more accessible to the broad community of cryptography.

A formal specification of a cryptographic construction promises correctness of properties related to security and implementation. The downside of formal specification is that it introduces a framework which requires expert knowledge on theorem proving and a strong mathematical background. By automating the code constructions for the mathematical part such as the higher inductive type implementation, we simplify theorem proving and formal specification to a considerable extent and make it more accessible to regular programmers without a strong mathematical background.

\section{Conclusion and Future Work}
We presented an automation tool developed using the new reflection library of Agda extended with support for elaborator reflection. Our automation tool handles code generation for inductive types with constructors taking zero arguments, one or more arguments, and type being defined itself as an argument. We simplified the syntax for defining higher inductive types through the mechanized construction of the boiler-plate code segments. By automating the generation of the elimination and the computation rules associated with a higher inductive type, we demonstrated an extensive reduction in code size and abstraction of difficulties involved in implementing and using the higher inductive type. Next, we intend to extend the support to include more categories of the inductive type such as the inductive-inductive type and the inductive-recursive type.


\bibliographystyle{ACM-Reference-Format}
\bibliography{sigproc}

\end{document}
