\documentclass[sigplan,10pt]{acmart}
\settopmatter{printfolios=true,printccs=false,printacmref=false}

\usepackage{booktabs} % For formal tables
%\usepackage{breqn}


% Copyright
%\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
\setcopyright{none}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}


\acmConference[TyDe'18]{ACM SIGPLAN Workshop on Type-Driven Development}{September 27, 2018}{St. Louis, MO, USA}
\acmYear{2018}
%\acmISBN{} % \acmISBN{978-x-xxxx-xxxx-x/YY/MM}
%\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption

\usepackage{bbm}
\usepackage[greek,english]{babel}

% This handles the translation of unicode to latex:
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{autofe}
\usepackage{fixltx2e}
\usepackage{hyphenat}

\DeclareUnicodeCharacter{8988}{\ensuremath{\ulcorner}}
\DeclareUnicodeCharacter{8989}{\ensuremath{\urcorner}}
\DeclareUnicodeCharacter{8803}{\ensuremath{\overline{\equiv}}}
%\DeclareUnicodeCharacter{11820}{\ensuremath{\urcorner}}
%\DeclareUnicodeCharacter{8759}{\ensuremath{\urcorner}}

\usepackage{amsmath}
\usepackage{fancyvrb}
\usepackage[euler]{textgreek}
\usepackage{textcomp}
\usepackage{relsize}
\usepackage{mathabx}
\usepackage{amssymb}
\usepackage{mathtools}

\usepackage[belowskip=-5pt,aboveskip=3pt]{caption}
\usepackage{todonotes}

%\usepackage{titlesec}
%\titlespacing*{\section}{0pt}{1.1\baselineskip}{\baselineskip}


\renewcommand{\theFancyVerbLine}{%
  \sffamily
  \textcolor[rgb]{0,0.7,0}{%
    \tiny{%
      \arabic{FancyVerbLine}%
    }
  }%
}


\begin{document}
\title{Encoding Higher Inductive Types Without Boilerplate}
                                        %% when present, will be used in
                                        %% header instead of Full Title.
%\titlenote{with title note}             %% \titlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'
\subtitle{A Study in Agda Metaprogramming}                     %% \subtitle is optional
%\subtitlenote{with subtitle note}       %% \subtitlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{Paventhan Vivekanandan}
%\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  %\position{Position1}
  \department{School of Informatics, Computing and Engineering}  %% \department is recommended
  \institution{Indiana University} %% \institution is required
  %\streetaddress{Street1 Address1}
  \city{Bloomington}
  \state{Indiana}
  %\postcode{Post-Code1}
  \country{USA}                    %% \country is recommended
}
\email{pvivekan@indiana.edu}          %% \email is recommended

%% Author with two affiliations and emails.
\author{David Thrane Christiansen}
%\authornote{with author2 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
%  \position{Position2a}
  \institution{Galois, Inc.} %% \institution is required
  %\streetaddress{Street2a Address2a}
  \city{Portland}
  \state{Oregon}
  %\postcode{Post-Code2a}
  \country{USA}                   %% \country is recommended
}
\email{dtc@galois.com}         %% \email is recommended
%\affiliation{
%  \position{Position2b}
%  \department{Department2b}             %% \department is recommended
%  \institution{Institution2b}           %% \institution is required
%  \streetaddress{Street3b Address2b}
%  \city{City2b}
%  \state{State2b}
%  \postcode{Post-Code2b}
%  \country{Country2b}                   %% \country is recommended
%}
%\email{first2.last2@inst2b.org}         %% \email is recommended



% The default list of authors is too long for headers}
%\renewcommand{\shortauthors}{B. Trovato et al.}


\begin{abstract}
Higher inductive types are inductive types that include nontrivial higher-dimensional structure, represented as identifications at the type that are not reflexivity. While work proceeds on type theories with a computational interpretation of univalence and higher inductive types, it is convenient to encode these structures in more traditional type theories. However, these encodings involve a great deal of error-prone additional syntax. We present a library that uses Agda's metaprogramming facilities to automate this process, allowing higher inductive types to be specified with minimal additional syntax.
\end{abstract}

%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below.
%
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003456.10003457.10003521.10003525</concept_id>
<concept_desc>Social and professional topics~History of programming languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~General programming languages}
\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code

\keywords{Higher inductive type, Elaboration, Elimination rules, Computation rules}

\maketitle

\section{Introduction}
\label{sec:intro}

A metaprogram is a program used to create other programs. In dependently-typed programming languages like Agda and Coq, a reflection library provides metaprogramming interfaces to support code generation for proofs and programs. Elaborator reflection \cite{David-2016}, a new paradigm for metaprogramming, provides the language users with a powerful set of interfaces for efficient code generation. An $elaborator$ is a metaprogram that converts a high-level language syntax in its abstract representation to a core language which is then type checked independently. By exposing a primitive monad to elaboration framework in Idris, Christiansen \cite{David-2016} showed how to write termination proofs for general recursive functions by automating Bove-Capretta \cite{Bove-2005} transformation, and how to generate data types matching schemas of external data sources based on Idris’s type providers \cite{David-2013}.

Agda is a proof-assistant based on Martin-Löf’s intensional type theory. Unlike Idris, which has a dedicated elaborator to convert the high-level syntax to its core language, Agda’s elaboration mechanism is a part of its type checker. Inspired by Idris’s elaborator reflection, Agda development team extended the reflection library of Agda by exposing its elaboration monad to its high-level metaprogramming instructions. The elaboration monad provides an interface to the Agda type checker through a set of primitive operations which can be used to retrieve static type information regarding various code segments. The primitive operations can also be used to build code fragments using constructs of an abstract syntax tree, and to convert an abstract syntax tree to its concrete syntax.

In this paper, we discuss metaprogramming using elaborator reflection in Agda. By using the elaboration monad, we performed code generation for the elimination and computation rules of inductive types and higher inductive types. We also automated the code generation for the boiler-plate code segment used to implement the higher inductive type defined using Dan Licata's method \cite{Licata-2011}. We discuss the construction process in detail and introduce new metaprogramming interfaces which build the code segments using elaborator reflection. The interfaces extensively use Agda’s reflection primitives and build the abstract syntax tree of the code segments with static type information obtained using the reflection primitives. The generated code is then brought into scope by another top-level reflection primitive.

Elaborator reflection is a powerful mechanism which allows us to create more interesting metaprograms. By performing the above automation, we abstracted the difficulties involved in implementing and using inductive types and higher inductive types by automating the construction of their corresponding elimination and computation rules. We also achieved an extensive reduction in code size, and we demonstrated how to extend a language without modifying the compiler or depending on the language implementers. More specifically, we discuss the following contributions in this paper.\todo{Rewrite contributions list to focus on actually novel things - many people have automated eliminator generation before}

\begin{itemize}
\item We demonstrate using the Agda's new metaprogramming library, extended with support for elaborator reflection, and show how to automate the construction of the recursion and the induction principles for inductive types using the library.

\item We discuss the automation of code generation of boiler-plate code for a higher inductive type defined inside a module. The boiler-plate code depends on a base type defined as private inside the module. The constructors of the private base type are not accessible outside the module.

\item We discuss the automation of code generation of the elimination and the computation rules for a higher inductive type with point and path constructors. We demonstrate the code generation of the reduction rules, specified as postulates, for the path constructors of the higher inductive type.

\item We discuss the automation of code generation for patch theory \cite{Angiuli-2014} implementation enriched with patches of encryption. We also examine the usage of the automation tool in a cryptography application \cite{Paventhan-2018}.
\end{itemize}

The automation tool abstracts the implementation difficulties of a higher inductive type and its recursion and induction principles. We automated the code generation of approximately 1500 lines of code of the patch theory implementation with just 70 lines of automation code. The automation code extensively uses the static type information queried from the type checker using the reflection primitives.

\section{Background}
\label{sec:sec2}

\subsection{Agda Reflection}
\label{sec:sec2.1}
Agda's reflection library enables compile-time metaprogramming.
This reflection library directly exposes parts of the implementation of Agda's type checker and elaborator for use by metaprograms, in a manner that is similar to Idris's elaborator reflection~\citep{davidphd,David-2016} and Lean's tactic metaprogramming~\citep{Ebner2017}.
The type checker's implementation is exposed as effects in a monad called \texttt{TC}.

Agda exposes a representation of its syntax to metaprograms, including datatypes for expressions (called \texttt{Term}) and definitions (called \texttt{Definition}).
The primitives exposed in \texttt{TC} include declaring new metavariables, unifying two \texttt{Term}s, declaring new definitions, adding new postulates, computing the normal form or weak head normal form of a \texttt{Term}, inspecting the current context, and constructing fresh names.
This section describes the primitives that are used in our code generation library; more information on the reflection library can be found in the Agda documentation \cite{Agda-doc-2017}.

\texttt{TC} computations can be invoked in three ways: by macros, which work in expression positions, using the \texttt{unquoteDecl} operator in a declaration position, which can bring new names into scope, and using the \texttt{unquoteDef} operator in a declaration position, which can automate constructions using names that are already in scope.
This preserves the principle in Agda's design that the system never invents a name.

An Agda \emph{macro} is a function of type {\tt $t_1$ → $t_2$ → $\ldots$ → Term → TC ⊤} that is defined inside a \texttt{macro} block.
Macros are special: their last argument is automatically supplied by the type checker, and consists of a \texttt{Term} that represents the metavariable to be solved by the macro.
If the remaining arguments are quoted names or \texttt{Term}s, then the type checker will automatically quote the arguments at the macro's use site.
At some point, the macro is expected to unify the provided metavariable with some other term, thus solving it.


\begin{figure}
\begin{Verbatim}
macro
  mc1 : Term → Term → TC ⊤
  mc1 exp hole =
    do exp' ← quoteTC exp
       unify hole exp'

sampleTerm : Term
sampleTerm = mc1 (λ (n : Nat) → n)
\end{Verbatim}
\caption{A macro that quotes its argument}
\label{fig:macro1}
\end{figure}

Figure~\ref{fig:macro1} demonstrates a macro that quotes its argument.
The first step is to quote the quoted expression argument again, using \texttt{quoteTC}, yielding a quotation of a quotation.
The result of this double-quotation is passed, using Agda's new support for Haskell-style do-notation, into a function that unifies it with the hole.
Because unification removes one layer of quotation, \texttt{unify} inserts the original quoted term into the hole.
The value of {\tt sampleTerm} is
\begin{center}
\begin{BVerbatim}
lam visible (abs "n" (var 0 []))
\end{BVerbatim}
\end{center}
The constructor \texttt{lam} represents a lambda, and its body is formed by the abstraction constructor \texttt{abs} that represents a scope in which a new name \texttt{"n"} is bound.
The body of the abstraction is a reference back to the abstracted name using de~Bruijn index \texttt{0}.

\begin{figure}
\centering
\begin{Verbatim}
macro
  mc2 : Term → Term → TC ⊤
  mc2 exp hole =
    do exp' ← unquoteTC exp
       unify hole exp'

sampleSyntax : Nat → Nat
sampleSyntax =
  mc2 (lam visible (abs "n" (var 0 [])))
\end{Verbatim}
\caption{A macro that unquotes its argument}
\label{fig:macro2}
\end{figure}

The {\tt unquoteTC} primitive removes one level of quotation.
Figure~\ref{fig:macro2} demonstrates the use of \texttt{unquoteTC}.
The macro {\tt mc2} expects a quotation of a quotation, and substitutes its unquotation for the current metavariable.

The {\tt unquoteDecl} and {\tt unquoteDef} primitives, which run \texttt{TC} computations in a declaration context, will typically introduce new declarations by side effect.
A function of a given type is declared using {\tt declareDef}, and it can be given a definition using {\tt defineFun}.
Similarly, a postulate of a given type is defined using {\tt declarePostulate}.
Figure~\ref{fig:plus} shows an Agda implementation of addition on natural numbers, while figure~\ref{fig:plusmeta} demonstrates an equivalent metaprogram that adds the same definition to the context.

\begin{figure}[h]
\begin{Verbatim}
plus : Nat → Nat → Nat
plus zero b = b
plus (suc n) b = suc (plus n b)
\end{Verbatim}
  \caption{Addition on natural numbers}
  \label{fig:plus}
\end{figure}

\begin{figure}
\begingroup
\fontsize{9pt}{10pt}\selectfont
\begin{Verbatim}
pattern vArg x = arg (arg-info visible relevant) x
pattern _`⇒_ a b = pi (vArg a) (abs "_" b)
pattern `Nat = def (quote Nat) []

unquoteDecl plus =
  do declareDef (vArg plus) (`Nat `⇒ `Nat `⇒ `Nat)
     defineFun plus
       (clause (vArg (con (quote zero) []) ::
                vArg (var "y") ::
                [])
          (var 0 []) ::
        clause (vArg (con (quote suc)
                       (vArg (var "x") :: [])) ::
                vArg (var "y") ::
                [])
          (con (quote suc)
            (vArg (def plus
                    (vArg (var 1 []) ::
                     vArg (var 0 []) :: [])) ::
             [])) ::
        [])
\end{Verbatim}
\endgroup
\caption{Addition, defined by metaprogramming}
\label{fig:plusmeta}
\end{figure}
\normalsize

In Figure~\ref{fig:plusmeta}, {\tt declareDef} declares the type of {\tt plus}.
The constructor {\tt pi} represents dependent function types, but a pattern synonym is used to make it shorter.
Similarly, \texttt{def} constructs references to defined names, and the pattern synonym \Verb|`Nat| abbreviates references to the defined name \texttt{Nat}, and {\tt vArg} represents the desired visibility and relevance settings of the arguments.
Once declared, \texttt{plus} is defined using {\tt defineFun}, which takes a name and a list of clauses, defining the function by side effect.
Each clause consists of a pattern and a right-hand side.
Patterns have their own datatype, while right-hand sides are \texttt{Term}s.
The name \texttt{con} is overloaded: in patterns, it denotes a pattern that match a particular constructor, while in \texttt{Term}s, it denotes a reference to a constructor.


\subsection{Higher Inductive Types}
\label{sec:sec2.2}

Homotopy type theory~\cite{HoTT-2013} is a research program that aims to develop univalent, higher-dimensional type theories.
A type theory is \emph{univalent} when equivalences between types are considered equivalent to equalities between types; it is \emph{higher-dimensional} when we allow non-trivial identifications that every structure in the theory must nevertheless respect.
Identifications between elements of a type are considered to be at the lowest dimension, while identifications between identifications at dimension $n$ are at dimension $n+1$.
Voevodsky added univalence  to type theories as an axiom, asserting new identifications without providing a means to compute with them.
While more recent work arranges the computational mechanisms of the type theory such that univalence can be derived, as is done in cubical type theories,\todo{cite Coquand's group, Mörtberg, and Harper's group} we are concerned with modeling concepts from homotopy type theory in existing, mature implementations of type theory, so we follow \citet{HoTT-2013} in modeling paths using Martin-Löf's identity type.
Higher-dimensional structure can arise from univalence, but it can also be introduced by defining new type formers that introduce not only introduction and elimination principles, but also new non-trivial identifications.

In homotopy type theories, one tends to think of types not as collections of distinct elements, but rather through the metaphor of topological spaces.
The individual elements of the type correspond with points in the topological space, and identifications correspond to paths in this space.


% In homotopy type theory, an element of an \emph{identity type} is used to model the notion of a path in a topological space or a morphism in a groupoid. An element of an identity type $a =_A b$ states that $a$ and $b$ are propositionally equal. In type theory, \emph{propositional equality} is a proof-relevant notion of equality, internal to the theory, expressed by identity types. We also have a proof-irrelevant notion of equality, external to the theory, known as \emph{judgmental equality} or \emph{definitional equality}. Definitional equality is used to express equality by definition. For instance, when we have a function $f : Nat \rightarrow Nat$ defined as $f(x) = x^2$ then the expression $f(3)$ is definitionally equal to $3^2$.

While there is not yet a general schematic characterization of a broad class of higher inductive types along the lines of Dybjer's inductive families,\todo{cite 1994 paper} it is convenient to syntactically represent the higher inductive types that we know are acceptable as if we had such a syntax.
Thus, we sometimes specify a higher inductive type similarly to a traditional inductive type by providing its constructors (\textit{i.e.} its points); we additionally specify the higher-dimensional structure by providing additional constructors for paths. For example, figure~\ref{fig:circle} describes \Verb|Circle|, which is a higher inductive type with one point constructor \Verb|base| and one non-trivial path constructor \Verb|loop|.

\begin{figure}[h]
\begin{center}
%\begingroup
\begin{BVerbatim}
data Circle : Set where
  base : Circle
  loop : base ≡ base
\end{BVerbatim}
%\endgroup
\end{center}
\caption{A specification of a higher inductive type}
\label{fig:circle}
\end{figure}
%\normalsize


Agda \todo{Cite Ulf's thesis + official wiki page} is a programming language that was originally an implementation of Luo's UTT \todo{cite Luo's book} extended with primitive dependent pattern matching, itself a derivative of the Calculus of Constructions and Martin-Löf's intensional type theory.
Agda's type theory has since gained a number of new features, among them the ability to restrict pattern matching to that subset that does not imply Streicher's Axiom K \todo{Cite Cockx et al}, which is inconsistent with univalence.
The convenience of programming in Agda, combined with the ability to avoid axiom K, makes it a good laboratory for experimenting with the idioms and techniques of univalent programming while more practical implementations of univalent type theories are under development.

In Agda, we don't have built-in primitives to support the definition of higher inductive type such as {\tt Circle}. One approach is to use Agda's rewrite rules \todo{cite Cockx and Abel, extended abstract at TYPES 2016} mechanism to define higher inductive types. In this approach, we define the dependent and non-dependent eliminators of a higher inductive type as paramterized modules inside which we declare the computation rules for points as rewrite rules using \Verb|{-# REWRITE , ...#-}| pragma. However, Agda's reflection library do not have interfaces to support introducing new pragmas and defining new modules. Another approach to define higher inductive types is to use Dan Licata's method \cite{Licata-2011}. According to this method, a higher inductive type is defined using type abstraction inside a module. The module consists of a boiler-plate code segment which defines the higher inductive type using a private base type. Inside the module, the recursion and the induction principles acts on the constructors of the private base type. The abstract type is then exported allowing the reduction rules for point constructors to hold definitionally. For example, {\tt Circle} is defined using Dan Licata's method as follows.

\begin{figure}
\begin{center}
\begingroup
\begin{Verbatim}
module Circle where
  private
    data S* : Set where
      base* : S*

  S : Set
  S = S*

  base : S
  base = base*

  postulate
    loop : base ≡ base

  recS : {C : Set} →
    (cbase : C) →
    (cloop : cbase ≡ cbase) →
    S → C
  recS cbase cloop base* = cbase

  postulate
    βrecS : {C : Set} →
      (cbase : C) →
      (cloop : cbase ≡ cbase) →
      ap (recS cbase cloop) loop ≡ cloop

  indS : {C : S → Set} →
    (cbase : C base) →
    (cloop : transport C loop cbase ≡ cbase) →
    (circle : S) → C circle
  indS cbase cloop base* = cbase

  postulate
    βindS : {C : S → Set} →
      (cbase : C base) →
      (cloop : transport C loop cbase ≡ cbase) →
      apd (indS {C} cbase cloop) loop ≡ cloop
\end{Verbatim}
\endgroup
\end{center}
\caption{An example of a higher inductive type using Licata's encoding}
\label{fig:circle-hit}
\end{figure}
%\normalsize

Inside the module {\tt Circle}, the type {\tt S} is defined using a private datatype {\tt S*}.
The constructor {\tt base} is defined using {\tt base*} and the path {\tt loop} is given as a postulated propositional equality.
The recursion and induction principles are defined by pattern matching on the constructor {\tt base*} of the type {\tt S*}, and thus compute as expected.
The clients of {\tt Circle} will not have access to the constructor {\tt base*} of the private type {\tt S*}, as it is not visible outside the module, which prevents them from writing functions that distinguish between multiple constructors of a higher inductive type that may be identified by additional path constructors.
The client's \emph{only} access to the constructor is through the provided elimination rules. The following code gives the non-dependent eliminator (sometimes called the \emph{recursion rule}) {\tt recS}.

{\tt recS} ignores the path argument and simply computes to the appropriate answer for the point constructor. The computational behavior for the path constructor loop is postulated using reduction rule {\tt βrecS}.
The operator \texttt{ap}\texttt{Perhaps we should move the discussion of ap earlier, so that we don't need the digression} is frequently referred to as \texttt{cong}, because it expresses that propositional equality is a congruence.
However, when viewed through a homotopy type theory lens, it is often called \texttt{ap}, as it describes the action of a function on paths.
In a higher inductive type, \texttt{ap} should compute new paths from old ones.
\begin{center}
\begin{BVerbatim}
ap : {A B : Set} {x y : A}
     (f : A → B) (p : x ≡ y) → f x ≡ f y
\end{BVerbatim}
\end{center}

The following code gives the dependent eliminator or the induction rule {\tt indS} and its computational rules.
The dependent eliminator relies on another operation on identifications, called \texttt{transport}, that coerces an inhabitant of a family of types at a particular index into an inhabitant at another index.
Outside of homotopy type theory, \texttt{transport} is typically called \texttt{subst} or \texttt{replace}, because it also expresses that substituting equal elements for equal elements is acceptable.
\begin{center}
\begin{Verbatim}
transport : {A : Set} {x y : A} → 
  (P : A → Set) → (p : x ≡ y) → P x → P y
\end{Verbatim}
\end{center}

In the postulated computation rule for \texttt{indS}, the function {\tt apd} is the dependent version of \texttt{ap}: it expresses the action of dependent functions on paths.
\begin{center}
%\begingroup
\begin{Verbatim}
apd : {A : Set} {B : A → Set} {x y : A} → 
  (f : (a : A) → B a) → 
  (p : x ≡ y) → (transport B p (f x) ≡ f y)
\end{Verbatim}
%\endgroup
\end{center}

The next section introduces the necessary automation features by describing the automatic generation of eliminators for a variant on Dybjer's inductive families.\todo{Check whether this is right - it might be a variation on Luo's inductive types instead.} Section 4 then generalizes this feature to automate the production of eliminators for higher inductive types using Licata's technique. Section 5 revisits \citeauthor{Angiuli-2014}'s encoding of Darcs's patch theory \citep{Angiuli-2014} and demonstrates that the higher inductive types employed in that paper can be generated succinctly using our library.

\section{Code Generation for Inductive Types}
\label{sec:sec3}
An inductive type $X$ is a type that is freely generated by a finite collection of constructors. The constructors of $X$ accept zero or more arguments, and result in an $X$. The constructors can also take an element of type $X$ itself as an argument, but only \emph{strictly positively}: any occurrences of the type constructor $X$ in the type of an argument to a constructor of $X$ must not be to the left of any arrows.

Type constructors can have a number of \emph{parameters}, which may not vary between the constructors, as well as \emph{indices}, which may.


In Agda, constructors are given a function type. In Agda's reflection library, the constructor {\tt data-type} of the datatype {\tt Definition} stores the constructors of an inductive type as a list of \texttt{Name}s. The type of a constructor can be retrieved by giving its {\tt Name} as an input to the {\tt getType} primitive. In the following subsections, we will discuss how to use list of constructors and their types to generate code for the elimination rules of an inductive type.

\subsection{Non-dependent Eliminators}
\label{sec:sec3.1}

\newcommand*{\KW}[1]{\textsf{\textbf{#1}}}
\newcommand*{\SET}{\textsf{Set}}

In Agda, we define an inductive type using {\tt data} keyword. A definition of an inductive datatype declares its type and specifies its constructors.
While Agda supports a variety of ways to define new datatypes, we will restrict our attention to the subset that correspond closely to Dyber's inductive families\todo{cite 1994 paper}. In general, the definition of an inductive datatype $D$ with constructors $c_1 \ldots c_n$ has the following form:
\begin{center}
\begingroup
\fontsize{7.9pt}{0pt}\selectfont
\begin{align*}
&\KW{data}\ D\ (a_1 : A_1) \ldots (a_n:A_n) : (i_1 : I_1) \rightarrow\ldots\rightarrow (i_m : I_m) \rightarrow \SET{}\ \KW{where}  \\
&\hspace{0.3cm} c_1 : \Delta_1 \rightarrow D \, a_1 \ldots a_n \, e_{11} \ldots e_{1m}  \\
&\hspace{3.5cm} \vdots  \\
&\hspace{0.3cm} c_r : \Delta_n \rightarrow D \, a_1 \ldots a_n \, e_{r1} \ldots e_{rm}  \\
\end{align*}
\endgroup
\end{center}
\normalsize
where the index instantiations $e_{k1} \ldots e_{km}$ are expressions in the scope induced by the telescope $\Delta_k$. Every expression in the definition must also be well-typed according to the provided declarations.


%The type of $A_i$ can take one of the three forms: a constant type {\tt B}, the inductive type $D$, or a function $B_1 \rightarrow \ldots \rightarrow B_n \rightarrow D$ with co-domain $D$. The parameters $(x_1:P_1)\ldots(x_n:P_n)$ are common to all the constructors, and the type of each constructor implicitly encodes the parameter references. However, the indices are different for each constructor. So, the type of each constructor explicitly exhibits the index declaration.

While inductive datatypes are defined by their constructors, it must also be possible to \emph{eliminate} them. This section describes how to generate a non-dependent recursion principle for an inductive type; section~\ref{sec:sec3.2} generalizes this technique to fully-dependent induction principles.

Based on the generic form of the inductive type given above, we can define the following schematic representation for the non-dependent eliminator.
\begin{align*}
D_{\mathit{rec}} :\ & (a_1 : A_1) \to \ldots \to (a_n : A_n) \to\\
& (i_1 : I_1) \to \ldots \to (i_m : I_m) \to\\
& (\mathit{tgt} : D\ a_1 \ldots a_n\ i_1\ \ldots\ i_n) \to\\
& (\mathit{C} : \SET{}) \to \\
& (\mathit{f_1} : \Delta_1^\prime \to \mathit{C}) \to \ldots \to (\mathit{f_r} : \Delta_r^\prime \to \mathit{C}) \to \\
& \mathit{C}
\end{align*}

The type of $f_i$, which is the method for fulfilling the desired type $C$ when eliminating the constructor $c_i$ in $D_\mathit{rec}$, is determined by the type of $c_i$.
The telescope $\Delta_i^\prime$ is the same as $\Delta_i$ for non-recursive constructor arguments.
However, $\Delta_i^\prime$ binds additional variables when there are recursive occurrences of $D$ in the arguments.
If $\Delta_i$ has an argument $(y : B)$, where $B$ is not an application of $D$ or a function returning such an application, $\Delta_i^\prime$ binds $(y : B)$ directly.
If $B$ is an application of $D$, then an additional binding $(y^\prime : C)$ is inserted following $y$.
Finally, if $B$ is a function type $\Psi \to D$, the additional binding is $(y^\prime : \Psi \to C)$. 

When automating the production of $D_{\mathit{rec}}$, all the information that is needed to produce the type signature is available in the \texttt{TC} monad by looking up $D$'s definition.
The constructor {\tt data-type} contains the count \emph{cp} of parameters occurring in a defined type. It also encodes the constructors of the type as a list of \texttt{Name}s. Metaprograms can retrieve the index count by finding the difference between \emph{cp} and the length of the constructor list. The constructors of $D$ refer to the parameter and the index using de~Bruijn indices.

The general schema for the computation rules corresponding to $D_{\mathit{rec}}$ and constructors $c_1, \ldots, c_n$ is given as follows.

\newcommand*{\RHSap}[2]{\ensuremath{\mathsf{RHS}\left(#1, #2\right)}}
\newcommand*{\RHS}[1]{\RHSap{f_{#1}}{\Delta_{#1}^\prime}}


\begin{center}
\begingroup
\fontsize{8.9pt}{2pt}\selectfont
\begin{align*}
& D_\mathit{rec}\ a_1\ \ldots\ a_n\ i_1\ \ldots\ i_m\ (c_1\ {\Delta_1}) \, C \, f_1 \ldots f_r = \\
&\hspace{0.5cm}\RHS{1}\\
& \vdots  \\
& D_\mathit{rec}\ a_1\ \ldots\ a_n\ i_1\ \ldots\ i_m\ (c_r\ {\Delta_r}) \, C \, f_1 \ldots f_r = \\
&\hspace{0.5cm}\RHS{r}\\ 
\end{align*}
\endgroup
\end{center}
\normalsize

Here, $\overline{\Delta_j}$ is the sequence of variables bound in $\Delta_j$.
$\mathsf{RHS}$ constructs the application of the method $f_j$ to the arguments of $c_j$, such that $C$ is satisfied.
It is defined by recursion on $\Delta_j$.
$\RHSap{f_j}{\cdot}$ is $f_j$, because all arguments have been accounted for.
$\RHSap{f_j}{(y : B)\Delta_k}$ is $\RHSap{f_j\ y}{\Delta_k}$ when $B$ does not mention $D$.
$\RHSap{f_j}{(y : D) (y^\prime : C)\Delta_k}$ is $\RHSap{f_j\ y\ \left(D_{\mathit{rec}}\ \ldots y \ldots\right)}{\Delta_k}$, where the recursive use of $D_{\mathit{rec}}$ is applied to the recursive constructor argument as well as the appropriate indices, and the parameters, result type, and methods remain constant.
Higher-order recursive arguments are a generalization of first-order arguments.
Finally,
\begin{displaymath}
\RHSap{f_j}{(y : \Psi \to D) (y^\prime : \Psi \to C)\Delta_k}
\end{displaymath}
is
\begin{displaymath}
\RHSap{f_j\ y\ \left(\lambda \overline{\Psi} . D_{\mathit{rec}}\ \ldots \left(y\ \overline{\Psi} \right) \ldots\right)}{\Delta_k}
\end{displaymath}
where the recursive use of $D_{\mathit{rec}}$ is as before.

The Agda datatype \texttt{Vec} represents lists of a known length. It is defined in figure~\ref{fig:vec}. For {\tt Vec}, the recursion principle says that, in order to eliminate a \texttt{Vec A n}, one must provide a result for the empty \texttt{Vec} and a means for transforming the head and tail of a non-empty \texttt{Vec} combined with the result of recursion onto a tail into the desired answer for the entire \texttt{Vec}.

\begin{figure}
\begin{center}
%\begingroup
\begin{BVerbatim}
data Vec (A : Set) : Nat → Set where
  []   : Vec A zero
  _::_ : {n : Nat} →
         (x : A) → (xs : Vec A n) → 
         Vec A (suc n)
\end{BVerbatim}
%\endgroup
\end{center}
\caption{Length-indexed lists}
\label{fig:vec}
\end{figure}

To define the action of {\tt f} on inputs {\tt []} and {\tt \_::\_}, we need elements {\tt c1} and {\tt c2} of the following type.

\begin{center}
%\begingroup
%\fontsize{9pt}{2pt}\selectfont
\begin{BVerbatim}
c1 : C
c2 : {m : Nat} → (x : A) → (xs : Vec A m) → 
     C → C
\end{BVerbatim}
%\endgroup
\end{center}
%\normalsize

The recursor {\tt f} maps the constructor {\tt []}, which takes zero arguments, to {\tt c1}. The constructor {\tt \_::\_} takes a constant argument {\tt x} and an argument {\tt xs} of the inductive type {\tt Vec}. {\tt f} maps {\tt (x :: xs)} to {\tt (c2 x xs (f xs C c1 c2))}. To construct the type of the recursion rule for {\tt Vec}, we need to build the type of {\tt c1} and {\tt c2}. Since {\tt []} is not a function type, we can map it directly to {\tt c1 : C}. We can retrieve the static type information of {\tt \_::\_} using reflection primitives, and use that to construct the type of {\tt c2}. The constructor {\tt pi} of type {\tt Term} encodes the abstract syntax tree (AST) representation of {\tt \_::\_} (fig.~\ref{fig:ast-g}). We can retrieve and traverse the AST of {\tt \_::\_}, and add new type information into it to build a new type representing {\tt c2}.

\begin{figure}
\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}
pattern _[_v]⇒_ a s b = pi (vArg a) (abs s b)
pattern _[_h]⇒_ a s b = pi (hArg a) (abs s b)

(agda-sort (lit 0) [ "A" h]⇒               -- A
 (def (quote Nat) [] [ "n" h]⇒             -- n
  (var 1 [] [ "x" v]⇒                      -- x
   (def (quote Vec)                         -- xs : Vec A n
        (vArg (var 2 []) ::
         vArg (var 1 []) :: [])
         [ "xs" v]⇒
    def (quote Vec)                         -- Vec A (suc n)
        (vArg (var 3 []) ::
         vArg (con (quote suc)
                (vArg (var 2 []) :: []))
         :: [])))))
\end{Verbatim}
\endgroup
\end{center}
\caption{Abstract syntax tree for constructor {\tt \_::\_}}
\label{fig:ast-g}
\end{figure}
\normalsize

During the traversal of abstract syntax tree of the type of {\tt \_::\_}, when the type {\tt Vec} occurs directly in a non-codomain position, we add the type {\tt C} next to it. For example, in figure~\ref{fig:ast-g}, a new function is built from the argument {\tt (xs : Vec A n)} by modifying it to {\tt (Vec A n) → C} (fig.~\ref{fig:ast-d}). Constant types require no modifications. Therefore, we copy {\tt (x : A)} into the new type without any changes. Finally, we change the codomain {Vec A (suc n)} of {\tt \_::\_} to \emph{C} resulting in an abstract syntax tree representation of the type {\tt c2}. We repeat this process for each of the constructors.

\begin{figure}
\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}
(agda-sort (lit 0) [ "A" h]⇒                    -- A
 (def (quote Nat) [] [ "n" h]⇒                  -- n
  (def (quote Vec) (vArg (var 1 []) ::           -- Vec A n
     vArg (var 0 []) :: []) [ "_" v]⇒
   (agda-sort (lit 0) [ "C" v]⇒                 -- C
    (var 0 [] [ "_" v]⇒                         -- c1
     ((def (quote Nat) [] [ "n" h]⇒             -- c2
       (var 5 [] [ "x" v]⇒                      -- x
        (def (quote Vec) (vArg (var 6 []) ::     -- Vec A n → C
           vArg (var 1 []) :: []) [ "xs" v]⇒  
             (var 4 [] [ "_" v]⇒ 
              var 5 []))))                       -- C
      [ "_" v]⇒ var 2 []))))))                  -- C
\end{Verbatim}
\endgroup
\end{center}
\caption{Abstract syntax tree for recursor {\tt f} on Vec}
\label{fig:ast-d}
\end{figure}
\normalsize

The element {\tt c2}, which represents the method for the constructor {\tt \_::\_} in {\tt Vec}, refers to the parameter and the index using de~Bruijn indices. During the construction of the type of {\tt c2}, the automation tool updates the de~Bruijn indices accordingly. Some constructors might not take the same number of indices as the parent type. For example, in the case of {\tt Vec}, the constructor {\tt []} excludes the index {\tt Nat} from its type. We do not have any reflection primitive to retrieve the index count from a constructor name. A workaround is to pass the index count of each constructor explicitly to the automation tool.

Once we have the AST of {\tt c2}, we can build the type of the recursion rule {\tt f} for {\tt Vec} (fig.\ref{fig:ast-d}). To encode the mapping {\tt Vec A n → C} in the recursion type, we need to declare {\tt C}. We can use the constructor {\tt agda-sort} to introduce the type {\tt (C : Set)}. The type of the recursion rule \emph{f} is given as follows.

\begin{center}
%\begingroup
%\fontsize{8pt}{2pt}\selectfont
\begin{BVerbatim}
f : {A : Set} → {n : Nat} → Vec A n → 
  (C : Set) → 
  (c1 : C) → 
  (c2 : {n : Nat} → (x : A) → 
        (xs : Vec A n) → C → C) → 
  C
\end{BVerbatim}
%\endgroup
\end{center}
%\normalsize

The above type is declared using {\tt declareDef}. We can build the computation rule representing the action of function \emph{f} on {\tt []} and {\tt \_::\_} using {\tt clause} (fig.~\ref{fig:ast-cdef}). The first argument to {\tt clause} encodes variables corresponding to the above type, and it also includes the abstract representation of {\tt []},{\tt \_::\_} on which the pattern matching should occur. The second argument to clause, which is of type {\tt Term}, refers to the variables in the first argument using de~Bruijn indices, and it encodes the output of the action of function \emph{f} on {\tt []},{\tt \_::\_}. The constructor {\tt var} in {\tt Pattern} is used to introduce new variables in the {\tt clause} definition. The type {\tt Pattern} also has another constructor {\tt con} used to represent the pattern matching term. The type {\tt Term} has similar constructors {\tt var} and {\tt con}, but with different types, used to encode the output of the recursion rule. The computation rules corresponding to the above type is given as follows.

\begin{center}
%\begingroup
%\fontsize{7pt}{2pt}\selectfont
\begin{BVerbatim}
f [] C c1 c2 = c1
f (x :: xs) C c1 c2 = c2 x xs (f xs C c1 c2)
\end{BVerbatim}
%\endgroup
\end{center}

\begin{figure}
\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}
(clause
  (vArg (con (quote _::_)                      -- _::_
          (vArg (var "x") ::                   -- x
           vArg (var "xs") :: []))             -- xs
   vArg (var "C") ::                           -- C
   vArg (var "c1") ::                          -- c1
   vArg (var "c2") :: [])                      -- c2
  (var 0                                       
    (vArg (var 4 []) ::                        -- x
     vArg (var 3 []) ::                        -- xs
     vArg (def f                               -- (f xs C c1 c2)
       (vArg (var 3 [])                        -- xs
        vArg (var 2 []) ::                     -- C
        vArg (var 1 []) ::                     -- c1
        vArg (var 0 []) :: [])))))             -- c2

\end{Verbatim}
\endgroup
\end{center}
\caption{Clause definition for the computation rule of \texttt{\_::\_}}
\label{fig:ast-cdef}
\end{figure}
\normalsize

\begin{figure}
\begin{center}
%\begingroup
\begin{BVerbatim}
data W (A : Set) (B : A → Set) : Set where
  sup : (a : A) → (B a → W A B) → W A B
\end{BVerbatim}
%\endgroup
\end{center}
\caption{W-Type}
\label{fig:W-type}
\end{figure}

A clause definition, which evaluates to the above computation rule of {\tt Vec} pattern matching on {\tt \_::\_}, is given in figure~\ref{fig:ast-cdef}. The de~Bruijn index reference increments right to left starting from the last argument.  The above clause definition is defined using {\tt defineFun} primitive, and the function \emph{f} is brought into scope by {\tt unquotedecl}.

Lets consider another example, the {\tt W}-type (fig.\ref{fig:W-type}), to review the automation process for the recursion principle. {\tt W}-type has a constructor {\tt sup} given by the following type.

\begin{center}
\begingroup
\begin{BVerbatim}
sup : (a : A) → (B a → W A B) → W A B
\end{BVerbatim}
\endgroup
\end{center}

To define the action of a function {\tt f : W A B → C} on input {\tt sup}, we need a function {\tt d} of the following type.
\begin{center}
\begingroup
\begin{BVerbatim}
d : (a : A) → (B a → W A B) → (B a → C) → C
\end{BVerbatim}
\endgroup
\end{center}

The type of {\tt d} is built by traversing the AST of {\tt sup}. During the traversal of the AST of {\tt sup}, the first argument to {\tt sup}, which is a constant type {\tt A}, is copied directly into the AST of {\tt d}. The second argument {\tt (B a  → W A B)}, which is a function with co-domain {\tt W A B}, is modified to {\tt (B a  → W A B) → (B a → C)}. Finally, the co-domain {\tt W A B} of {\tt sup} is replaced by {\tt C}. The computation rule corresponding to {\tt sup} is given as follows.
\begin{center}
\begingroup
\begin{BVerbatim}
f (sup a b) C d = d a b (λ v → f (b v) C d)
\end{BVerbatim}
\endgroup
\end{center}

In the above computation rule, the third argument to {\tt d} is a composition of functions {\tt f} and {\tt b}. The automation tool composes functions inside a lambda directly, using the \texttt{Term} constructor {\tt lam}. The arguments to {\tt lam} are referenced using de~Bruijn indices inside the lambda body. So, the de~Bruijn indices for referring variables outside the lambda body are updated accordingly. For example, inside the lambda body, the reference {\tt 0} refers to the lambda argument {\tt v}, and the index references to the variables outside the lambda body start from 1 and increment towards the left.

In the automation tool, {\tt generateRec} interface is used to generate the recursion rule $f$. The implementation of {\tt generateRec} is given in fig.\eqref{fig:generateRec}.

\begin{figure}
\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}
generateRec : Arg Name → Name → 
  (indexList : List Nat) → TC ⊤
generateRec (arg i f) t indLs =
  do indLs' ← getIndex t indLs
     cns ← getConstructors t
     lcons ← getLength cns
     cls ← getClause lcons zero t f indLs cns
     RTy ← getType t
     funType ← getRtype t indLs' zero RTy
     declareDef (arg i f) funType
     defineFun f cls
\end{Verbatim}
\endgroup
\end{center}
\caption{Implementation for {\tt generateRec}}
\label{fig:generateRec}
\end{figure}
\normalsize

{\tt generateRec} uses {\tt getClause} and {\tt getRtype} to build the computation and elimination rules respectively. It takes three arguments: the name of the function to be defined (represented by an element of type {\tt Arg Name}), the quoted {\tt Name} of the type and a list containing the index count of the individual constructors. {\tt generateRec} can be used to automate the generation of recursion rules for inductive types having the general schema given at the beginning of this section. The recursion rule generated by {\tt generateRec} is brought into scope using {\tt unquoteDecl} as follows.

\begin{center}
\begingroup
%\fontsize{8pt}{9pt}\selectfont
\begin{BVerbatim}
unquoteDecl f = generateRec (vArg f)
                  (quote Vec) 
                  (0 :: 1 :: [])
\end{BVerbatim}
\endgroup
\end{center}
%\normalsize

The third argument to {\tt generateRec} is a list consisting of the index count for the constructors. It is required to pass the index count for each constructor explicitly as the Agda reflection library does not have built-in primitives to retrieve the index value.

\subsection{Dependent Eliminators}
\label{sec:sec3.2}

The dependent eliminator for a datatype, also known as the \emph{induction principle}, is used to eliminate elements of a datatype when the type resulting from the elimination mentions the very element being eliminated. We can define the general schema for the induction principle as follows.
\begin{align*}
D_{\mathit{ind}} : &\ (a_1 : A_1) \to \ldots \to (a_n : A_n) \to\\
& (i_1 : I_1) \to \ldots \to (i_m : I_m) \to\\
& (\mathit{tgt} : D\ a_1 \ldots a_n\ i_1\ \ldots\ i_m) \to\\
& \begin{array}{@{}l@{}l}(\mathit{C} :\ & (i_1 : I_1) \to \ldots \to (i_m : I_m) \to\\  & D\ a_1 \ldots a_n\ i_1\ \ldots\ i_n \to\\ &\SET{})\to\end{array} \\
& (\mathit{f_1} : \Delta_1^\prime \to \mathit{C}\ e_{11} \ldots e_{1p}\ (c_1\ \overline{\Delta_1})) \to \\
& (\mathit{f_r} : \Delta_r^\prime \to \mathit{C}\ e_{r1} \ldots e_{rp}\ (c_r\ \overline{\Delta_r})) \to \\
& \mathit{C}\ i_1\ \ldots\ i_n\ \mathit{tgt}
\end{align*}

Similarly to the non-dependent recursion principle $D_{\mathit{rec}}$, the type of each method $f_i$ is derived from the type of the constructor $c_i$---the method argument telescope $\Delta_k^\prime$ is similar, except the arguments that represent the result of recursion now apply the motive $C$ to appropriate arguments.
If $\Delta_i$ has an argument $(y : B)$, where $B$ is not an application of $D$ or a function returning such an application, $\Delta_i^\prime$ still binds $(y : B)$ directly.
If $B$ is an application of $D$ to parameters $a\ldots$ and indices $e\ldots$, then an additional binding $(y^\prime : C\ e\ldots\ y)$ is inserted following $y$.
Finally, if $B$ is a function type $\Psi \to D\ a\ldots\ e\ldots$, the additional binding is $(y^\prime : \Psi \to C\ e\ldots (y\ \overline{\Psi}))$. 

The computation rules for the induction principle are the same as for the recursion principle.

For the inductive type {\tt W}, the induction principle says that to define a mapping {\tt f : (w : W A B) → C w}, it suffices to define the action of {\tt f} on the constructor {\tt sup}. To define the action of {\tt f} on {\tt sup}, we need an element {\tt d} of the following type.

\begin{center}
\begingroup
\begin{BVerbatim}
d : (a : A) → (y : B a → W A B) → 
    (z : (v : B a) → C (y v)) → 
    C (sup a y)
\end{BVerbatim}
\endgroup
\end{center}

To build the dependent eliminator, we need the type of the function {\tt d}. We can construct the AST of {\tt d} using the static type information obtained from {\tt sup}. To construct {\tt d}, during the traversal of the AST of {\tt sup}, we copy the constant {\tt (a : A)} directly without any changes as in the case of the non-dependant eliminator. When we identify a function {\tt y : B a → W A B} with codomain {\tt W A B}, we add a new function {\tt (z : (v : B a) → C (y v))} with the same arguments as in {\tt y} and codomain {\tt C (y v)}, which depends on the action of {\tt y} on {\tt v}. Finally, the co-domain \emph{W A B} of the constructor {\tt sup} is changed to {\tt C (sup a y)}, which depends on the action of the constructor {\tt sup} on inputs {\tt a} and {\tt y} (fig.~\ref{fig:ast-d'}).

\begin{figure}
\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}
(agda-sort (lit 0) [ "A" h]⇒                  -- A
 ((var 0 [] [ "_" v]⇒                         -- B : A → Set
     agda-sort (lit 0)) [ "B" h]⇒
  (def (quote W) (vArg (var 1 []) ::          -- c : W A B
     vArg (var 0 []) :: []) [ "c" v]⇒
   ((def (quote W) (vArg (var 2 []) ::        -- C : W A B → Set
       vArg (var 1 []) :: []) [ "_" v]⇒
     agda-sort (lit 0)) [ "C" v]⇒
    ((var 3 [] [ "a" v]⇒                      -- a : A
      ((var 3 (vArg (var 0 []) :: [])         -- y : B a → W A B
        [ "_" v]⇒
        def (quote W) (vArg (var 5 []) :: 
          vArg (var 4 []) :: [])) [ "y" v]⇒
       ((var 4 (vArg (var 1 []) :: [])        -- z : B a → C (y v)
         [ "v" v]⇒
         var 3 (vArg (var 1 (vArg (var 0 []) 
         :: [])) :: []))
        [ "z" v]⇒
        var 3                                 -- C (sup a y)
        (vArg
         (con (quote sup)
          (vArg (var 2 []) :: 
           vArg (var 1 []) :: []))
         :: []))))
     [ "_" v]⇒ var 1 (vArg (var 2 []) :: []))))))  -- C c
\end{Verbatim}
\endgroup
\end{center}
\caption{Abstract syntax tree for the dependent eliminator of {\tt W}}
\label{fig:ast-d'}
\end{figure}
\normalsize

We can construct the type of the induction principle {\tt f} using {\tt d}. The type {\tt C} in the mapping {\tt f} depends on the element of the input type {\tt W A B}. The type of the induction principle {\tt f} (fig.~\ref{fig:ast-d'}) is given as follows.
\begin{center}
\begingroup
\begin{BVerbatim}
f : {A : Set} {B : A → Set} → 
    (c : W A B) → (C : W A B → Set) → 
    ((a : A) → (y : B a → W A B) → 
     (z : (v : B a) → C (y v)) → 
     C (sup x y)) → C c
\end{BVerbatim}
\endgroup
\end{center}
The computation rule corresponding to the above type is the same as the computation rule of the recursion principle of {\tt W}. It is constructed using {\tt clause} definitions following the same approach as the recursion principle.  We can automate the generation of the induction rule {\tt f} and its corresponding computation rules using {\tt generateInd} interface. The implementation of {\tt generateInd} can be found in fig.\eqref{fig:generateInd}.

%The following code gives the implementation of {\tt generateInd}.

%\begin{center}
%\begingroup
%\begin{BVerbatim}
\begin{figure}
\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}
generateInd : Arg Name → Name → 
  (indexList : List Nat) → TC ⊤
generateInd (arg i f) t indLs =
  do id' ← getIndex t indLs
     cns ← getConstructors t
     lcns ← getLength cns
     cls ← getClauseDep lcns zero t f id' cns
     RTy ← getType t
     funType ← getRtypeInd t zero id' RTy
     declareDef (arg i f) funType
     defineFun f cls
\end{Verbatim}
\endgroup
\end{center}
\caption{Implementation for {\tt generateInd}}
\label{fig:generateInd}
\end{figure}
\normalsize

%\end{BVerbatim}
%\endgroup
%\end{center}

{\tt generateInd} uses {\tt getClauseDep} to generate the {\tt clause} definitions representing the computation rules. The abstract representation of the type is provided by {\tt getRtypeInd}. The function {\tt f} generated by {\tt generateInd} is brought into scope by {\tt unquoteDecl} as follows.
\begin{center}
\begingroup
\begin{BVerbatim}
unquoteDecl f = generateInd (vArg f) 
                  (quote W) []
\end{BVerbatim}
\endgroup
\end{center}

An empty list is passed to {\tt generateInd} as {\tt W} has no index. An empty list can also be passed if all the constructors of a type has the same number of index as the parent type. But if any one constructor has an index count different from the index count of the parent type, then the index count of all the constructors should be passed explicitly.

\section{Code Generation for Higher Inductive Types}
\label{sec:sec4}

In Agda, there are no built-in primitives to support the definition of higher inductive types. However, we can still define a higher inductive type with a base type using Dan Licata's \citep{Licata-2011} method as discussed in section 2.1. In this section, we discuss the automation of code generation for the boiler-plate code segments defining the higher inductive type. We also describe how to automate the code generation for the elimination and the computation rules of the higher inductive type using static type information obtained from the base type.


\subsection{Higher Inductive Type Definition}
\label{sec:sec4.1}

The automation tool defines a higher inductive type $G$ as a top-level definition using a base type $D$ similar to the module {\tt Circle} in section 2.1. The reflection type {\tt Definition} provides the tool with the type and the constructors of the base type $D$. The tool then copies the type of $D$ to $G$ and for the constructors $g_1 \ldots g_n$ of $G$, it traverses the AST of the constructors $c_1 \ldots c_n$ of $D$ respectively replacing the occurrences of $D$ to $G$ in every strictly positive position. Consider a constructor $c_i$ that has the following type.
\begin{equation}
c_i : (A \rightarrow D) \rightarrow (B \rightarrow D) \rightarrow C \rightarrow D \rightarrow D \nonumber
\end{equation}

The automation tool builts the type of $g_i$ by traversing the AST of $c_i$ and replacing the base type $D$ with the higher inductive type $G$. The AST of $c_i$ incorporates the type of the parameters and the indices if present. The tool retains the parameters and the indices explicitly during the construction of $g_i$. The following represents the type of the constructor $g_i$.
\begin{equation}
g_i : (A \rightarrow G) \rightarrow (B \rightarrow G) \rightarrow C \rightarrow G \rightarrow G \nonumber
\end{equation}

We explicitly pass the types of the path constructors to the automation tool. The higher inductive type definition of {\tt Circle} in section 2.1 represents the path constructors as propositional equalities. The automation tool takes the path types as input and declares them as propositional equalities using the reflection primitive {\tt declarePostulate}. We introduce a new data type {\tt ArgPath} (fig.\ref{fig:argPath}) to input the path types to the automation tool. The constructor {\tt argPath} takes the type of a path constructor as input.

\begin{figure}
\begin{center}
\begingroup
\begin{BVerbatim}
data ArgPath {ℓ₁} : Set (lsuc ℓ₁) where
  argPath : Set ℓ₁ → ArgPath
\end{BVerbatim}
\endgroup
\end{center}
\caption{Definition of ArgPath}
\label{fig:argPath}
\end{figure}

We define the generic form of a higher inductive type as follows.
\begin{center}
\begingroup
\fontsize{7.9pt}{0pt}\selectfont
\begin{align}
& data{\text -}hit \hspace {0.1cm} (quote \hspace {0.1cm} D) \hspace {0.1cm} G \nonumber \\
  & \hspace {0.3cm} Gpoints \hspace {0.2cm} (g_1 ::  \ldots :: g_n :: []) \nonumber \\
  & \hspace {0.3cm} Gpaths  \hspace {0.2cm} (p_1 :: \ldots :: p_n :: []) \nonumber \\
  & \hspace {0.3cm} (argPath \nonumber \\
  & \hspace {0.6cm} (\{x_1:P_1\} \rightarrow \ldots \rightarrow \{x_n:P_n\} \rightarrow \nonumber \\
  & \hspace {0.7cm} \{i_1:Q_1\} \rightarrow \ldots \rightarrow \{i_n:Q_n\} \rightarrow \Delta_1 \rightarrow \nonumber \\
  & \hspace {0.7cm} (c_i \{x_1\} \ldots \{x_n\} \{i_1\} \ldots \{i_n\} \ldots) \equiv (c_j \ldots)) :: \nonumber \\
  & \hspace {3cm} \vdots \nonumber \\
  & \hspace {0.4cm} argPath \nonumber \\
  & \hspace {0.6cm} (\{x_1:P_1\} \rightarrow \ldots \rightarrow \{x_n:P_n\} \rightarrow \nonumber \\
  & \hspace {0.7cm} \{j_1:Q_1\} \rightarrow \ldots \rightarrow \{j_n:Q_n\} \rightarrow \Delta_n \rightarrow \nonumber \\
  & \hspace {0.7cm} (c_i \{x_1\} \ldots \{x_n\} \{j_1\} \ldots \{j_n\} \ldots) \equiv (c_j \ldots)) :: [])\nonumber \\ \nonumber
\end{align}
\endgroup
\end{center}
\normalsize

We define holders $Gpoints$ for point constructors and $Gpaths$ for path constructors as part of the higher inductive type definition of $G$. We cannot retrieve the constructors of the higher inductive type $G$ using {\tt Definition}. Therefore, $Gpoints$ and $Gpaths$ act as the only references for the constructors of $G$. The elements of the {\tt argPath} list represent the type of the path constructors $p_1 \ldots p_n$ respectively. We explicitly include the parameter references $\{x_1 : P_1\} \ldots \{x_n : P_n\}$ and the index references $\{k_1 : Q_1\} \ldots \{k_n : Q_n\}$ in the type of the arguments to {\tt argPath}. The constructor $g_i$ is not in scope when used in the path type passed to {\tt argPath}. Therefore, we use the base type constructor $c_i$ as a dummy argument in the place of $g_i$. The automation tool implements the interface {\tt data-hit} as given in fig.\eqref{fig:data-hit}.

%\begin{center}
%\begingroup
%\begin{BVerbatim}
\begin{figure}
\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}
data-hit : ∀{ℓ₁} 
  (baseType : Name) → (indType : Name) →
  (pointHolder : Name) → (lcons : List Name) →
  (pathHolder : Name) → (lpaths : List Name) →
  (lpathTypes : (List (ArgPath {ℓ₁}))) → TC ⊤
data-hit base ind h1 lcons h2 lpaths pTy =
  do defineHindType base ind
     cns ← getConstructors base
     defineHitCons base ind cns lcons
     pTy' ← getPathTypes base ind cns lcons pTy
     defineHitPathCons lpaths pTy'
     definePointHolder h1 lcons
     definePathHolder h2 lpaths
\end{Verbatim}
\endgroup
\end{center}
\caption{Implementation for {\tt data-hit}}
\label{fig:data-hit}
\end{figure}
\normalsize

%\end{BVerbatim}
%\endgroup
%\end{center}

The higher inductive type \emph{G}, the points $g_1 \ldots g_n$, the paths $p_1 \ldots p_n$, and the holders \emph{Gpoints} and \emph{Gpaths} are brought into scope by {\tt unquoteDecl}. In the implementation of {\tt data-hit} in fig.\eqref{fig:data-hit}, {\tt defineHindType} defines the higher inductive type as a top-level definition using the base type. The interface {\tt defineHitCons} specifies the point constructors of the higher inductive type using the type information obtained from the constructors of the base type, and the interface {\tt defineHitPathCons} builds the paths constructors of the higher inductive type using the {\tt argPath} list. The following code automates the generation of the higher inductive type definition for {\tt Circle} given in section 2.1.
\begin{center}
\begingroup
\begin{BVerbatim}

unquoteDecl S Spoints base Spaths loop =
  data-hit (quote S*) S
    Spoints (base :: []) -- point constructors
    Spaths (loop :: [])  -- path constructors
    (argPath (base* ≡ base*) :: []) 
    -- base replaces base*

\end{BVerbatim}
\endgroup
\end{center}

The identity type input {\tt (base* ≡ base*)} to argPath represents the type of the path {\tt loop}, and it uses the inductive type constructor {\tt base*} as a dummy argument in the place of the higher inductive type constructor {\tt base}. The constructor {\tt base} comes into scope only during the execution of {\tt unquoteDecl}, and so cannot be used in the identity type reference in {\tt argPath}. We use the constructor {\tt base*} of type {\tt S*} as dummy argument because the type of {\tt base*} is similar to {\tt base}, and has the same references for the common arguments. The automation tool traverses the abstract syntax tree of {\tt loop} and replaces the occurrences of {\tt base*} with {\tt base}.

\subsection{Non-dependent Eliminator}
\label{sec:sec4.2}

Non-dependent eliminator or the recursion principle of a higher inductive type $G$ maps the points and paths of $G$ to an output type $C$. We extend the general schema of the recursion principle given in section \eqref{sec:sec3.1} by adding methods for path constructors as follows.
\begin{align*}
G_{\mathit{rec}} : & (a_1 : A_1) \to \ldots \to (a_n : A_n) \to\\
& (i_1 : I_1) \to \ldots \to (i_m : I_m) \to\\
& (\mathit{tgt} : G\ a_1 \ldots a_n\ i_1\ \ldots\ i_n) \to\\
& (\mathit{C} : \SET{}) \to \\
& (\mathit{f_1} : \Delta_1 \to  \Delta_1^\prime \to \mathit{C}) \to \\
& (\mathit{f_r} : \Delta_r \to  \Delta_r^\prime \to \mathit{C}) \to \\
& (\mathit{k_1} : \Delta_1 \to  \Delta_1^\prime \to (f_i \ldots) \equiv (f_j \ldots)) \to \\
& (\mathit{k_r} : \Delta_r \to  \Delta_r^\prime \to (f_i \ldots) \equiv (f_j \ldots)) \to \\
& \mathit{C}
\end{align*}
 
In the schema definition above, we have given only one-dimensional paths. The automation tool currently supports one-dimensional paths, and we are planning to improve the tool to support higher-dimensional paths in the future. 

The type of $f_i$, method for the point constructor $g_i$ in $G_{rec}$, is built the same way as for the normal inductive type $D$. The automation tool builds the type of $k_i$, method for path constructor $p_i$ in $G_{rec}$, by traversing the AST of $p_i$. During the traversal, the references to point constructors $g_i$ of $G$ in the co-domain of $p_i$ are replaced by $f_i$. The arguments of $k_i$ are handled the same way as for $f_i$. The schema for the computation rules corresponding to points $g_i$ is similar to the computation rules corresponding to constructors $c_i$ of the inductive type $D$ except that it has additional variables to represent paths. The schema for the computation rules corresponding to paths $p_i$ is given as follows.
\begin{align*}
\beta G_{rec} :  & (a_1 : A_1) \to \ldots \to (a_n : A_n) \to\\
& (\mathit{C} : \SET{}) \to \\
& (\mathit{f_1} : \Delta_1 \to  \Delta_1^\prime \to \mathit{C}) \to \\
& (\mathit{f_r} : \Delta_r \to  \Delta_r^\prime \to \mathit{C}) \to \\
& (\mathit{k_1} : \Delta_1 \to  \Delta_1^\prime \to (f_i \ldots) \equiv (f_j \ldots)) \to \\
& (\mathit{k_r} : \Delta_r \to  \Delta_r^\prime \to (f_i \ldots) \equiv (f_j \ldots)) \to \\
& \mathit{ap} \, (\lambda \, x \to G_{rec} \, x \, C \, f_1 \, f_r \, k_1 \, k_r) \, (p_i \ldots) \equiv (k_i \ldots)
\end{align*}

The computation rule $\beta G_{rec}$ exists only as propositional equality. The automation tool builds the type of $\beta G_{rec}$ using the same approach as for the recursion rule $G_{rec}$. The type of $G_{rec}$ and $\beta G_{rec}$ is similar except for the mapping $G \to C$ in $G_{rec}$ which is replaced by the term representing the action of function $G_{rec}$ on the path $(p_i \, \ldots)$. The function {\tt ap} (sec. \ref{sec:sec2.2}) applies $G_{rec}$, which is nested inside a lambda function, on the path $(p_i \ldots)$. The tool uses the constructor {\tt lam} of {\tt Term} to introduce a lambda function.

Lets consider the higher inductive type {\tt S} (sec \ref{sec:sec2.1}), which represents the {\tt Circle}. To define a mapping {\tt recS : S → C}, we need a point {\tt cbase : C} and a path {\tt cloop : C ≡ C} in the space {\tt C}. To construct the recursion principle {\tt recS}, we need to build the type of point {\tt cbase} and path {\tt cloop}. The type of {\tt cbase} is built from the AST of points {\tt base} using the approach described in section \eqref{sec:sec3.1}. The automation tool builds the type of {\tt cloop} by traversing the AST of {\tt loop}. During the traversal, the tool replaces the point {\tt base}, which forms the two arguments to the identity type, in the co-domain of the path {\tt loop} by the point {\tt cbase}.

\begin{figure}
\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}
(def (quote S) [] [ "_" v]⇒                 -- S
 (agda-sort (lit 0) [ "C" v]⇒               -- C : Set
  (var 0 [] [ "cbase" v]⇒                   -- cbase
   (def (quote _≡_)                         -- cloop
    (vArg (var 0 []) ::
     vArg (var 0 []) :: [])
    [ "cloop" v]⇒ var 2 []))))
\end{Verbatim}
\endgroup
\end{center}
\caption{Abstract syntax tree for {\tt recS}}
\label{fig:ast-f}
\end{figure}
\normalsize

The recursion rule {\tt recS} corresponding to figure \eqref{fig:ast-f} is given as follows.
\begin{center}
\begingroup
\begin{BVerbatim}
  recS : S → 
    (C : Set) →
    (cbase : C) →
    (cloop : cbase ≡ cbase) →
    C
\end{BVerbatim}
\endgroup
\end{center}

The automation tool builds the computation rule for the point constructor {\tt base} using the same approach as described in sec.~\ref{sec:sec3.1}. Additionally, it includes variables in the {\tt clause} definition for the path constructor {\tt loop}. The tool builds the computation rule for the path constructor {\tt loop} using {\tt ap} as follows.

\begin{center}
\begingroup
\begin{BVerbatim}

    βrecS : (C : Set) → (cbase : C) → 
      (cloop : cbase ≡ cbase) → 
      ap (λ x → recS x C cbase cloop) loop 
      ≡ cloop
\end{BVerbatim}
\endgroup
\end{center}

The application of function {\tt recS} to the path {\tt loop} substitutes the point {\tt base} for the lambda argument {\tt x}, and it evaluates to the path {\tt cloop} in the output type {\tt C}. The automation tool uses {\tt declarePostulate} primitive to introduce {\tt βrecS} as a postulate. We implement the {\tt generateRecHit} interface as given in fig.\eqref{fig:generateRecHit}.

\begin{figure}
\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}
(agda-sort (lit 0) [ "C" v]⇒
 (var 0 [] [ "cbase" v]⇒
  (def (quote _≡_)
   (vArg (var 0 []) :: vArg (var 0 []) :: [])
   [ "cloop" v]⇒
   def (quote _≡_)
   (vArg
    (def (quote ap)
     (vArg
      (lam visible
       (abs "x"
        (def (quote recS)
         (vArg (var 0 []) ::
          vArg (var 3 []) :: vArg (var 2 []) :: 
          vArg (var 1 []) :: []))))
      :: vArg (def (quote loop) []) :: []))
    :: vArg (var 0 []) :: []))))
\end{Verbatim}
\endgroup
\end{center}
\caption{AST representing the action of function {\tt recS} on path {\tt loop}}
\label{fig:ast-beta-f}
\end{figure}
\normalsize

\begin{figure}
\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}
generateRecHit : 
  Arg Name → List (Arg Name) →
  (baseType : Name) → (indexList : List Nat) →
  (baseRec : Name) → (indType : Name) →
  (points : List Name) → 
  (paths : List Name) → TC ⊤
generateRecHit (arg i f) argD b il br i p1 p2 =
  do lcons ← getConstructors b
     lpoints ← getLength p1
     lpaths ← getLength p2
     clauses ← getPathClause lpoints lpaths br
     RTy ← getType baseType
     fTy ← getRtypePath b i br il p2 zero RTy
     declareDef (arg i f) fTy
     defineFun f clauses
     generateβRecHit argD b il br i f p1 p2
\end{Verbatim}
\endgroup
\end{center}
\caption{Implementation for {\tt generateRecHit}}
\label{fig:generateRecHit}
\end{figure}
\normalsize

{\tt generateRecHit} takes the base type recursion rule as input and uses that to eliminate the points in the AST of the path methods in the recursor $G_{rec}$. The second argument {\tt argD} is a list of terms representing the computation rules for the path constructors. The {\tt generateβRecHit} interface takes {\tt argD} as input and builds the computation rule for the path constructors. Other inputs to {\tt generateRecHit} are the point and path holders declared during the higher inductive type definition.

\subsection{Dependent Eliminator}
\label{sec:sec4.3}

Dependent eliminator or the induction principle of a higher inductive type $G$ is a dependent function that maps an element $g$ of $G$ to an output type $C \, g$. The general schema for the induction principle of $G$ is given as follows.
\begin{align*}
G_{\mathit{ind}} : & (a_1 : A_1) \to \ldots \to (a_n : A_n) \to\\
& (i_1 : I_1) \to \ldots \to (i_m : I_m) \to\\
& (\mathit{tgt} : G\ a_1 \ldots a_n\ i_1\ \ldots\ i_n) \to\\
& \begin{array}{@{}l@{}l}(\mathit{C} :\ & (i_1 : I_1) \to \ldots \to (i_m : I_m) \to\\  & G\ a_1 \ldots a_n\ i_1\ \ldots\ i_n \to\\ &\SET{})\to\end{array} \\
& (\mathit{f_1} : \Delta_1 \to  \Delta_1^\prime \to \mathit{C}\ j_{11} \ldots j_{1p}\ (c_1\ \overline{\Delta_1})) \to \\
& (\mathit{f_r} : \Delta_r \to  \Delta_r^\prime \to \mathit{C}\ j_{r1} \ldots j_{rp}\ (c_r\ \overline{\Delta_r})) \to \\
& (\mathit{k_1} : \Delta_1 \to  \Delta_1^\prime \to transport \, \mathit{C} \, p_1 \, (f_i \ldots) \equiv (f_j \ldots)) \to \\
& (\mathit{k_r} : \Delta_r \to  \Delta_r^\prime \to transport \, \mathit{C} \, p_r \, (f_i \ldots) \equiv (f_j \ldots)) \to \\
& \mathit{C}\ i_1\ \ldots\ i_n\ \mathit{tgt}
\end{align*}

Similar to $G_{rec}$, the type of $f_i$ is built the same way as for the normal inductive type $D$. The automation tool builds the type of $k_i$, method for path constructor $p_i$ in $G_{ind}$, by traversing the AST of $p_i$. During the traversal, the references to point constructors $g_i$ of $G$ in the co-domain of $p_i$ are replaced by $f_i$. In the first argument to the identity type in the co-domain of $k_i$, the automation tool adds the quoted {\tt name} of {\tt transport}, reference to the motive {\tt C}, and the path $p_i$. The arguments of $k_i$ are handled the same way as for $f_i$. The schema for the computation rules corresponding to paths $p_i$ is given as follows.
\begin{align*}
\beta G_i : & (a_1 : A_1) \to \ldots \to (a_n : A_n) \to\\
& \begin{array}{@{}l@{}l}(\mathit{C} :\ & (i_1 : I_1) \to \ldots \to (i_m : I_m) \to\\  & G\ a_1 \ldots a_n\ i_1\ \ldots\ i_n \to\\ &\SET{})\to\end{array} \\
& (\mathit{f_1} : \Delta_1 \to  \Delta_1^\prime \to \mathit{C}\ j_{11} \ldots j_{1p}\ (c_1\ \overline{\Delta_1})) \to \\
& (\mathit{f_r} : \Delta_r \to  \Delta_r^\prime \to \mathit{C}\ j_{r1} \ldots j_{rp}\ (c_r\ \overline{\Delta_r})) \to \\
& (\mathit{k_1} : \Delta_1 \to  \Delta_1^\prime \to transport \, \mathit{C} \, p_1 \, (f_i \ldots) \equiv (f_j \ldots)) \to \\
& (\mathit{k_r} : \Delta_r \to  \Delta_r^\prime \to transport \, \mathit{C} \, p_r \, (f_i \ldots) \equiv (f_j \ldots)) \to \\
& \mathit{apd} \, (\lambda \, x \to G_{ind} \, x \, C \, f_1 \, f_r \, k_1 \, k_r) \, (p_i \ldots) \equiv (k_i \ldots)
\end{align*}

The automation tool builds the type of $\beta G_{ind}$ using the same approach as for the induction rule $G_{ind}$. The type of $G_{ind}$ and $\beta G_{ind}$ is similar except for the mapping $(g : G) \to C g$ in $G_{ind}$ which is replaced by the term representing the action of function $G_{ind}$ on the path $(p_i \, \ldots)$. The function {\tt apd} (sec. \ref{sec:sec2.2}) applies $G_{ind}$, which is nested inside a lambda function, on the path $(p_i \ldots)$.

For the type {\tt S} with point constructor {\tt base} and path constructor {\tt loop}, to define a mapping {\tt indS : (x : S) → C x}, we need {\tt cbase : C} and {\tt cloop : C}, where {\tt cloop} is a heterogeneous path transported over {\tt loop}. The automation tool builds the type of {\tt cloop} by traversing the abstract syntax tree of {\tt loop} and adding relevant type information into it. For the codomain of {\tt cloop}, which is an identity type, we insert the quoted {\tt name} of {\tt transport} with arguments {\tt C}, {\tt loop} and {\tt cbase}. The automation tool applies the base eliminator to the arguments of the path {\tt loop} during the construction of the co-domain of {\tt cloop}. The following declaration gives the type of {\tt indS}.
\begin{center}
\begin{BVerbatim}

indS : (circle : S) → 
  (C : S → Set) →
  (cbase : C base) →
  (cloop : transport C loop cbase ≡ cbase) →
  C circle
\end{BVerbatim}
\end{center}

The computation rule for {\tt base}, which defines the action of {\tt indS} on {\tt base}, is built using the same approach as for the non-dependent eliminator {\tt recS}. The computation rule {\tt βindS} for the path {\tt loop} is built using {\tt apd} which gives the action of dependent function {\tt indS} on the path {\tt loop}.
\begin{center}
\begin{BVerbatim}
βindS : (C : S → Set) → 
  (cbase : C base) → 
  (cloop : transport C loop cbase ≡ cbase) → 
  apd (λ x → indS x C cbase cloop) loop ≡ cloop

\end{BVerbatim}
\end{center}

Fig.\eqref{fig:generateIndHit} gives the implementation of {\tt generateIndHit} interface in the automation tool. {\tt generateβIndHit} builds the computation rule for the path constructors.

\begin{figure}
\begin{center}
%\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}
generateIndHit : Arg Name → List (Arg Name) →
  (baseType : Name) → (indLs : List Nat) →
  (baseElm : Name) → (indType : Name) →
  (points : List Name) → 
  (paths : List Name) → TC ⊤
generateIndHit (arg i f) argD b il br i p1 p2 =
  do il' ← getIndex b il
     lcons ← getConstructors b
     lp1 ← getLength p1
     lp2 ← getLength p2
     clauses ← (getPathClauseDep lp1 lp2 b br il' lcons)
     RTy ← getType b
     fTy ← (getRtypePathDep b i br p1 p2 zero il' RTy)
     declareDef (arg i f) fTy
     defineFun f clauses
     generateβIndHit argD b il br i f p1 p2
\end{Verbatim}
%\endgroup
\end{center}
\caption{Implementation for {\tt generateIndHit}}
\label{fig:generateIndHit}
\end{figure}
\normalsize


\section{Application}

The field of homotopy type theory is less well-developed on the programming side. There are only few programming applications of homotopy type theory, and the role of computationally relevant equality proofs on programming is an area of active research. Applications such as homotopical patch theory \cite{Angiuli-2014} discuss the implementation of Darcs \cite{Darcs-2005} version control system using patch theory \cite{Mimram-2013} \cite{Jason-2009} in the context of homotopy type theory. Containers in homotopy type theory \cite{Altenkirch-2014} \cite{Abbott-2005} implement data structures such as multisets and cycles. The automation tool discussed in this paper abstracts away the difficulties involved in the implementation of a higher inductive type and its elimination rules. It introduces interfaces which simplify the intricacies of a higher inductive type definition and usage by automating the generation of the code segments defining the higher inductive type and its elimination rules. The automation tool is significant in reducing the development effort for existing applications, and it can also attract new programming applications in homotopy type theory.

%In the next section, we discuss the implementation of patch theory application in Agda and exhibit a tremendous reduction in code size using the automation tool. In section \ref{crypto}, we present a cryptography application and discuss how to abstract the implementation difficulties of a higher inductive type making it more accessible to the cryptographers.

\subsection{Patch Theory Revisited}
\label{patch-theory}

A patch is a syntactic representation of a function that modifies a repository context when applied. For example, a patch $(s1 \leftrightarrow s2 \, @ \, l)$, which replaces string s1 with s2 at line l, when applied to a repository context with string s1 at line l results in a repository context with string s2 at line l. In homotopical patch theory \cite{Angiuli-2014}, the patches are modeled as paths in a higher inductive type. The higher inductive type representation of patches automatically satisfy groupoid laws such as the composition of patches is associative, and inverse composes to identity. Domain-specific laws related to the patches such as two swaps at independent lines commute are designed as higher dimensional paths. The computation content of the patches is extracted by mapping them to bijections in the universe with the help of univalence. Due to the functoriality of mappings in type theory, the functions preserve the path structures in their mapping to the universe.

We developed the patch theory application in Agda using Dan Licata's method \cite{Licata-2011}. We implemented basic patches like the insertion of a string as line l1 in a file and deletion of a line l2 from a file. The functions implementing insertion and deletion in the universe are not bijective. So, to map the paths representing the patches insert and delete into the universe, we used the patch history approach \cite{Angiuli-2014}. According to this approach, we developed a separate higher inductive type $History$ which serves as the types of patches. In addition to basic patches, we also implemented patches of encryption using cryptosystems like rsa \cite{Rivest-1978} and paillier \cite{Paillier-1999}.

We used the automation tool described in this paper to generate code for the higher inductive type definition representing $History$ and the repository context $cryptR$ for the patches. We also automated the code generation for the elimination and the computation rules for the higher inductive types $History$ and $cryptR$. In addition to abstracting the implementation difficulties of higher inductive types, the automation tool helped us to achieve an extensive reduction in the code size of the original application. We were able to automate the generation of approximately 1500 lines of code with just about 70 lines of automation code. The automation massively reduced the code size of the application which is about 2500 lines resulting in 60\% reduction in the original code size.

\subsection{Cryptography}
\label{crypto}

The work of \cite{Paventhan-2018} applies the tools of homotopy type theory for cryptographic protocol implementation. It introduces a new approach for the formal specification of cryptographic schemes using types. The work discusses modeling $cryptDB$ \citep{Popa-2011} using a framework similar to patch theory. CryptDB employs layered encryption techniques and demonstrates computation on top of encrypted data. We can implement cryptDB by modeling the database queries as paths in a higher inductive type and mapping the paths to the universe using singleton types \cite{Angiuli-2014}. The automation tool can be applied to generate code for the higher inductive type representing cryptDB and its corresponding elimination and computation rules. By using the automation tool, we can abstract the convolutions of homotopy type theory thus making it more accessible to the broad community of cryptography.

A formal specification of a cryptographic construction promises correctness of properties related to security and implementation. The downside of formal specification is that it introduces a framework which requires expert knowledge on theorem proving and a strong mathematical background. By automating the code constructions for the mathematical part such as the higher inductive type implementation, we simplify formal specification to a considerable extent and make it more accessible to regular programmers without a strong mathematical background.

\section{Related Work}

There are other works which use the Agda's reflection library for performing different meta-programming tasks. \emph{Auto in Agda} \cite{Kokke-2015} implements a library for proof search using Agda's reflection primitives. It discusses implementing a \emph{Prolog} interpreter in the style of Stutterheim et al \cite{Stutterheim-2013}. It employs a \emph{hint} database, associated with a customizable depth-first traversal, with lemmas to assist in the proof search. The implementation of \emph{Auto in Agda} used an older version of Agda's reflection library which does not include the support for elaborator reflection. 

The work of \cite{Walt-2013} \cite{Walt-2012} discusses automating specific categories of proofs using \emph{proof by reflection}. It presents \emph{Autoquote}, an Agda library, for translation of a quoted expression, based on a conversion table, to a representation defined by the user using a non-dependent datatype. It gives an overview of a prior version of Agda's reflection library and also sites its limitations such as the inability to introduce top-level definitions. However, the new Agda reflection library has addressed a lot of those limitations.

\section{Conclusion and Future Work}

We presented an automation tool developed using the new reflection library of Agda extended with support for elaborator reflection. Our automation tool handles code generation for inductive types with constructors taking zero arguments, one or more arguments, and type being defined itself as an argument. We simplified the syntax for defining higher inductive types through the mechanized construction of the boiler-plate code segments. By automating the generation of the elimination and the computation rules associated with a higher inductive type, we demonstrated an extensive reduction in code size and abstraction of difficulties involved in implementing and using the higher inductive type. Next, we intend to extend the support to include more categories of the inductive type such as the inductive-inductive type and the inductive-recursive type.


\bibliographystyle{ACM-Reference-Format}
\bibliography{sigproc}

\end{document}
