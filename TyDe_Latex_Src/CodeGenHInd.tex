\documentclass[sigplan,10pt]{acmart}
\settopmatter{printfolios=true,printccs=false,printacmref=false}

\usepackage{booktabs} % For formal tables
%\usepackage{breqn}


% Copyright
%\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
\setcopyright{none}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}


\acmConference[TyDe'18]{ACM SIGPLAN Workshop on Type-Driven Development}{September 27, 2018}{St. Louis, MO, USA}
\acmYear{2018}
%\acmISBN{} % \acmISBN{978-x-xxxx-xxxx-x/YY/MM}
%\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption

\usepackage{bbm}
\usepackage[greek,english]{babel}

% This handles the translation of unicode to latex:
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{autofe}
\usepackage{fixltx2e}
\usepackage{hyphenat}

\DeclareUnicodeCharacter{8988}{\ensuremath{\ulcorner}}
\DeclareUnicodeCharacter{8989}{\ensuremath{\urcorner}}
\DeclareUnicodeCharacter{8803}{\ensuremath{\overline{\equiv}}}
%\DeclareUnicodeCharacter{11820}{\ensuremath{\urcorner}}
%\DeclareUnicodeCharacter{8759}{\ensuremath{\urcorner}}

\usepackage{amsmath}
\usepackage{fancyvrb}
\usepackage[euler]{textgreek}
\usepackage{textcomp}
\usepackage{relsize}
\usepackage{mathabx}
\usepackage{amssymb}
\usepackage{mathtools}

\usepackage[belowskip=-5pt,aboveskip=3pt]{caption}
\usepackage{todonotes}

%\usepackage{titlesec}
%\titlespacing*{\section}{0pt}{1.1\baselineskip}{\baselineskip}


\renewcommand{\theFancyVerbLine}{%
  \sffamily
  \textcolor[rgb]{0,0.7,0}{%
    \tiny{%
      \arabic{FancyVerbLine}%
    }
  }%
}


\begin{document}
\title{Encoding Higher Inductive Types Without Boilerplate}
                                        %% when present, will be used in
                                        %% header instead of Full Title.
%\titlenote{with title note}             %% \titlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'
\subtitle{A Study in Agda Metaprogramming}                     %% \subtitle is optional
%\subtitlenote{with subtitle note}       %% \subtitlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{Paventhan Vivekanandan}
%\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  %\position{Position1}
  \department{School of Informatics, Computing and Engineering}  %% \department is recommended
  \institution{Indiana University} %% \institution is required
  %\streetaddress{Street1 Address1}
  \city{Bloomington}
  \state{Indiana}
  %\postcode{Post-Code1}
  \country{USA}                    %% \country is recommended
}
\email{pvivekan@indiana.edu}          %% \email is recommended

%% Author with two affiliations and emails.
\author{David Thrane Christiansen}
%\authornote{with author2 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
%  \position{Position2a}
  \institution{Galois, Inc.} %% \institution is required
  %\streetaddress{Street2a Address2a}
  \city{Portland}
  \state{Oregon}
  %\postcode{Post-Code2a}
  \country{USA}                   %% \country is recommended
}
\email{dtc@galois.com}         %% \email is recommended
%\affiliation{
%  \position{Position2b}
%  \department{Department2b}             %% \department is recommended
%  \institution{Institution2b}           %% \institution is required
%  \streetaddress{Street3b Address2b}
%  \city{City2b}
%  \state{State2b}
%  \postcode{Post-Code2b}
%  \country{Country2b}                   %% \country is recommended
%}
%\email{first2.last2@inst2b.org}         %% \email is recommended



% The default list of authors is too long for headers}
%\renewcommand{\shortauthors}{B. Trovato et al.}


\begin{abstract}
Higher inductive types are inductive types that include nontrivial higher-dimensional structure, represented as identifications that are not reflexivity. While work proceeds on type theories with a computational interpretation of univalence and higher inductive types, it is convenient to encode these structures in more traditional type theories with mature implementations. However, these encodings involve a great deal of error-prone additional syntax. We present a library that uses Agda's metaprogramming facilities to automate this process, allowing higher inductive types to be specified with minimal additional syntax.
\end{abstract}

%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below.
%
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003456.10003457.10003521.10003525</concept_id>
<concept_desc>Social and professional topics~History of programming languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~General programming languages}
\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code

\keywords{Higher inductive type, Elaboration, Elimination rules, Computation rules}

\maketitle

\section{Introduction}
\label{sec:intro}

Type theory unites programming and mathematics in a delightful synthesis, in which we can write programs and proofs in the same language.
Work on higher-dimensional type theory has revealed a beautiful higher-dimensional structure, lurking just beyond reach.
In particular, higher inductive types provide a natural encoding of many otherwise-difficult mathematical concepts, and univalence lets us work in our type theory the way we do on paper: up to isomorphism.
Homotopy type theory, however, is not yet done.
We do not yet have a mature theory or a mature implementation.

While work proceeds on prototype implementations of higher-dimensional type theories~\todo{Cite Coquand's group and Harper's group}, much work remains before they will be as convenient for experimentation with new ideas as Coq, Agda, or Idris is today.
In the meantime, it is useful to be able to experiment with ideas from higher-dimensional type theory in our existing systems.
If one is willing to put up with some boilerplate code, it is possible to encode higher inductive types and univalence using a mixture of postulated identities and traditional datatypes.
We use a technique developed by Licata~\cite{Licata-2011}.

Boilerplate postulates, however, are not just inconvenient, they are also an opportunity to make mistakes.
Luckily, this boilerplate code can be mechanically generated using Agda's recent support for \emph{elaborator reflection}~\cite{David-2016}, a paradigm for metaprogramming in an implementation of type theory.
An elaborator is the part of the implementation that translates a convenient language designed for humans into a much simpler, more explicit, verbose language designed to be easy for a machine to process.
Elaborator reflection directly exposes the primitive components of the elaborator to metaprograms written in the language being elaborated, allowing them to put these components to new uses.


Using Agda's elaborator reflection, we automatically generate the support code for higher inductive types, including datatype definitions, postulated paths, induction principles, and their computational behavior.
\citeauthor{Angiuli-2014}'s encoding of patch theory as a higher inductive type~\citep{Angiuli-2014} requires approximately 1500 lines of code. Using our library, the encoding can be expressed in just 70 lines.


This paper makes the following contributions:
\begin{itemize}
\item We describe the design and implementation of a metaprogram that automates an encoding of higher inductive types using Agda's new metaprogramming system.
\item We demonstrate applications of this metaprogram to examples from the literature, including both standard textbook examples of higher inductive types as well as larger systems, including both patch theory and specifying cryptographic schemes.
\item This metaprogram serves as an example of the additional power available in Agda's elaborator reflection relative to earlier metaprogramming APIs.
\end{itemize}


\section{Background}
\label{sec:sec2}

\subsection{Agda Reflection}
\label{sec:sec2.1}
Agda's reflection library enables compile-time metaprogramming.
This reflection library directly exposes parts of the implementation of Agda's type checker and elaborator for use by metaprograms, in a manner that is similar to Idris's elaborator reflection~\citep{davidphd,David-2016} and Lean's tactic metaprogramming~\citep{Ebner2017}.
The type checker's implementation is exposed as effects in a monad called \texttt{TC}.

Agda exposes a representation of its syntax to metaprograms, including datatypes for expressions (called \texttt{Term}) and definitions (called \texttt{Definition}).
The primitives exposed in \texttt{TC} include declaring new metavariables, unifying two \texttt{Term}s, declaring new definitions, adding new postulates, computing the normal form or weak head normal form of a \texttt{Term}, inspecting the current context, and constructing fresh names.
This section describes the primitives that are used in our code generation library; more information on the reflection library can be found in the Agda documentation \cite{Agda-doc-2017}.

\texttt{TC} computations can be invoked in three ways: by macros, which work in expression positions, using the \texttt{unquoteDecl} operator in a declaration position, which can bring new names into scope, and using the \texttt{unquoteDef} operator in a declaration position, which can automate constructions using names that are already in scope.
This preserves the principle in Agda's design that the system never invents a name.

An Agda \emph{macro} is a function of type {\tt $t_1$ → $t_2$ → $\ldots$ → Term → TC ⊤} that is defined inside a \texttt{macro} block.
Macros are special: their last argument is automatically supplied by the type checker, and consists of a \texttt{Term} that represents the metavariable to be solved by the macro.
If the remaining arguments are quoted names or \texttt{Term}s, then the type checker will automatically quote the arguments at the macro's use site.
At some point, the macro is expected to unify the provided metavariable with some other term, thus solving it.


\begin{figure}
\begin{Verbatim}
macro
  mc1 : Term → Term → TC ⊤
  mc1 exp hole =
    do exp' ← quoteTC exp
       unify hole exp'

sampleTerm : Term
sampleTerm = mc1 (λ (n : Nat) → n)
\end{Verbatim}
\caption{A macro that quotes its argument}
\label{fig:macro1}
\end{figure}

Figure~\ref{fig:macro1} demonstrates a macro that quotes its argument.
The first step is to quote the quoted expression argument again, using \texttt{quoteTC}, yielding a quotation of a quotation.
This doubly-quoted expression is passed, using Agda's new support for Haskell-style do-notation, into a function that unifies it with the hole.
Because unification removes one layer of quotation, \texttt{unify} inserts the original quoted term into the hole.
The value of {\tt sampleTerm} is
\begin{center}
\begin{BVerbatim}
lam visible (abs "n" (var 0 []))
\end{BVerbatim}
\end{center}
The constructor \texttt{lam} represents a lambda, and its body is formed by the abstraction constructor \texttt{abs} that represents a scope in which a new name \texttt{"n"} is bound.
The body of the abstraction is a reference back to the abstracted name using de~Bruijn index \texttt{0}.

\begin{figure}
\centering
\begin{Verbatim}
macro
  mc2 : Term → Term → TC ⊤
  mc2 exp hole =
    do exp' ← unquoteTC exp
       unify hole exp'

sampleSyntax : Nat → Nat
sampleSyntax =
  mc2 (lam visible (abs "n" (var 0 [])))
\end{Verbatim}
\caption{A macro that unquotes its argument}
\label{fig:macro2}
\end{figure}

The {\tt unquoteTC} primitive removes one level of quotation.
Figure~\ref{fig:macro2} demonstrates the use of \texttt{unquoteTC}.
The macro {\tt mc2} expects a quotation of a quotation, and substitutes its unquotation for the current metavariable.

The {\tt unquoteDecl} and {\tt unquoteDef} primitives, which run \texttt{TC} computations in a declaration context, will typically introduce new declarations by side effect.
A function of a given type is declared using {\tt declareDef}, and it can be given a definition using {\tt defineFun}.
Similarly, a postulate of a given type is defined using {\tt declarePostulate}.
Figure~\ref{fig:plus} shows an Agda implementation of addition on natural numbers, while figure~\ref{fig:plusmeta} demonstrates an equivalent metaprogram that adds the same definition to the context.

\begin{figure}[h]
\begin{Verbatim}
plus : Nat → Nat → Nat
plus zero b = b
plus (suc n) b = suc (plus n b)
\end{Verbatim}
  \caption{Addition on natural numbers}
  \label{fig:plus}
\end{figure}

\begin{figure}
\begingroup
\fontsize{9pt}{10pt}\selectfont
\begin{Verbatim}
pattern vArg x = arg (arg-info visible relevant) x
pattern _`⇒_ a b = pi (vArg a) (abs "_" b)
pattern `Nat = def (quote Nat) []

unquoteDecl plus =
  do declareDef (vArg plus) (`Nat `⇒ `Nat `⇒ `Nat)
     defineFun plus
       (clause (vArg (con (quote zero) []) ::
                vArg (var "y") ::
                [])
          (var 0 []) ::
        clause (vArg (con (quote suc)
                       (vArg (var "x") :: [])) ::
                vArg (var "y") ::
                [])
          (con (quote suc)
            (vArg (def plus
                    (vArg (var 1 []) ::
                     vArg (var 0 []) :: [])) ::
             [])) ::
        [])
\end{Verbatim}
\endgroup
\caption{Addition, defined by metaprogramming}
\label{fig:plusmeta}
\end{figure}
\normalsize

In Figure~\ref{fig:plusmeta}, {\tt declareDef} declares the type of {\tt plus}.
The constructor {\tt pi} represents dependent function types, but a pattern synonym is used to make it shorter.
Similarly, \texttt{def} constructs references to defined names, and the pattern synonym \Verb|`Nat| abbreviates references to the defined name \texttt{Nat}, and {\tt vArg} represents the desired visibility and relevance settings of the arguments.
Once declared, \texttt{plus} is defined using {\tt defineFun}, which takes a name and a list of clauses, defining the function by side effect.
Each clause consists of a pattern and a right-hand side.
Patterns have their own datatype, while right-hand sides are \texttt{Term}s.
The name \texttt{con} is overloaded: in patterns, it denotes a pattern that matches a particular constructor, while in \texttt{Term}s, it denotes a reference to a constructor.


\subsection{Higher Inductive Types}
\label{sec:sec2.2}

Homotopy type theory~\cite{HoTT-2013} is a research program that aims to develop univalent, higher-dimensional type theories.
A type theory is \emph{univalent} when equivalences between types are considered equivalent to identifications between types; it is \emph{higher-dimensional} when we allow non-trivial identifications that every structure in the theory must nevertheless respect.
Identifications between elements of a type are considered to be at the lowest dimension, while identifications between identifications at dimension $n$ are at dimension $n+1$.
Voevodsky added univalence  to type theories as an axiom, asserting new identifications without providing a means to compute with them.
While more recent work arranges the computational mechanisms of the type theory such that univalence can be derived, as is done in cubical type theories,\todo{cite Coquand's group, Mörtberg, and Harper's group} we are concerned with modeling concepts from homotopy type theory in existing, mature implementations of type theory, so we follow \citet{HoTT-2013} in modeling paths using Martin-Löf's identity type.
Higher-dimensional structure can arise from univalence, but it can also be introduced by defining new type formers that introduce not only introduction and elimination principles, but also new non-trivial identifications.

In homotopy type theories, one tends to think of types not as collections of distinct elements, but rather through the metaphor of topological spaces.
The individual elements of the type correspond with points in the topological space, and identifications correspond to paths in this space.


% In homotopy type theory, an element of an \emph{identity type} is used to model the notion of a path in a topological space or a morphism in a groupoid. An element of an identity type $a =_A b$ states that $a$ and $b$ are propositionally equal. In type theory, \emph{propositional equality} is a proof-relevant notion of equality, internal to the theory, expressed by identity types. We also have a proof-irrelevant notion of equality, external to the theory, known as \emph{judgmental equality} or \emph{definitional equality}. Definitional equality is used to express equality by definition. For instance, when we have a function $f : Nat \rightarrow Nat$ defined as $f(x) = x^2$ then the expression $f(3)$ is definitionally equal to $3^2$.

While there is not yet a general schematic characterization of a broad class of higher inductive types along the lines of Dybjer's inductive families,\todo{cite 1994 paper} it is convenient to syntactically represent the higher inductive types that we know are acceptable as if we had such a syntax.
Thus, we sometimes specify a higher inductive type similarly to a traditional inductive type by providing its constructors (\textit{i.e.} its points); we additionally specify the higher-dimensional structure by providing additional constructors for paths. For example, figure~\ref{fig:circle} describes \Verb|Circle|, which is a higher inductive type with one point constructor \Verb|base| and one non-trivial path constructor \Verb|loop|.

\begin{figure}[h]
\begin{center}
%\begingroup
\begin{BVerbatim}
data Circle : Set where
  base : Circle
  loop : base ≡ base
\end{BVerbatim}
%\endgroup
\end{center}
\caption{A specification of a higher inductive type}
\label{fig:circle}
\end{figure}
%\normalsize


Agda \todo{Cite Ulf's thesis + official wiki page} is a programming language that was originally an implementation of Luo's UTT \todo{cite Luo's book} extended with primitive dependent pattern matching, itself a derivative of the Calculus of Constructions and Martin-Löf's intensional type theory.
Agda's type theory has since gained a number of new features, among them the ability to restrict pattern matching to that subset that does not imply Streicher's Axiom K \todo{Cite Cockx et al}, which is inconsistent with univalence.
The convenience of programming in Agda, combined with the ability to avoid axiom K, makes it a good laboratory for experimenting with the idioms and techniques of univalent programming while more practical implementations of univalent type theories are under development.

In Agda, we don't have built-in primitives to support the definition of higher inductive type such as {\tt Circle}. One approach is to use Agda's rewrite rules \todo{cite Cockx and Abel, extended abstract at TYPES 2016} mechanism to define higher inductive types. In this approach, we define the dependent and non-dependent eliminators of a higher inductive type as paramterized modules inside which we declare the computation rules for points as rewrite rules using \Verb|{-# REWRITE , ...#-}| pragma. However, Agda's reflection library do not have interfaces to support introducing new pragmas and defining new modules. Another approach to define higher inductive types is to use Licata's method \cite{Licata-2011}. According to this method, a higher inductive type is defined using type abstraction inside a module. The module consists of a boiler-plate code segment which defines the higher inductive type using a private base type. Inside the module, the recursion and the induction principles acts on the constructors of the private base type. The abstract type is then exported allowing the reduction rules for point constructors to hold definitionally. For example, {\tt Circle} is defined using Licata's method as follows.

\begin{figure}
\begin{center}
\begingroup
\begin{Verbatim}
module Circle where
  private
    data S* : Set where
      base* : S*

  S : Set
  S = S*

  base : S
  base = base*

  postulate
    loop : base ≡ base

  recS : {C : Set} →
    (cbase : C) →
    (cloop : cbase ≡ cbase) →
    S → C
  recS cbase cloop base* = cbase

  postulate
    βrecS : {C : Set} →
      (cbase : C) →
      (cloop : cbase ≡ cbase) →
      ap (recS cbase cloop) loop ≡ cloop

  indS : {C : S → Set} →
    (cbase : C base) →
    (cloop : transport C loop cbase ≡ cbase) →
    (circle : S) → C circle
  indS cbase cloop base* = cbase

  postulate
    βindS : {C : S → Set} →
      (cbase : C base) →
      (cloop : transport C loop cbase ≡ cbase) →
      apd (indS {C} cbase cloop) loop ≡ cloop
\end{Verbatim}
\endgroup
\end{center}
\caption{A HIT encoded using Licata's method}
\label{fig:circle-hit}
\end{figure}
%\normalsize

Inside the module {\tt Circle}, the type {\tt S} is defined using a private datatype {\tt S*}.
The constructor {\tt base} is defined using {\tt base*} and the path {\tt loop} is given as a postulated propositional equality.
The recursion and induction principles are defined by pattern matching on the constructor {\tt base*} of the type {\tt S*}, and thus compute as expected.
The clients of {\tt Circle} will not have access to the constructor {\tt base*} of the private type {\tt S*}, as it is not visible outside the module, which prevents them from writing functions that distinguish between multiple constructors of a higher inductive type that may be identified by additional path constructors.
The client's \emph{only} access to the constructor is through the provided elimination rules. The following code gives the non-dependent eliminator (sometimes called the \emph{recursion rule}) {\tt recS}.

{\tt recS} ignores the path argument and simply computes to the appropriate answer for the point constructor. The computational behavior for the path constructor loop is postulated using reduction rule {\tt βrecS}.
The operator \texttt{ap}\texttt{Perhaps we should move the discussion of ap earlier, so that we don't need the digression} is frequently referred to as \texttt{cong}, because it expresses that propositional equality is a congruence.
However, when viewed through a homotopy type theory lens, it is often called \texttt{ap}, as it describes the action of a function on paths.
In a higher inductive type, \texttt{ap} should compute new paths from old ones.
\begin{center}
\begin{BVerbatim}
ap : {A B : Set} {x y : A}
     (f : A → B) (p : x ≡ y) → f x ≡ f y
\end{BVerbatim}
\end{center}

In addition to describing the constructors of the points and paths of \texttt{S}, figure~\ref{fig:circle-hit} additionally demonstrates the dependent eliminator (that is, the induction rule) {\tt indS} and its computational meaning.
The dependent eliminator relies on another operation on identifications, called \texttt{transport}, that coerces an inhabitant of a family of types at a particular index into an inhabitant at another index.
Outside of homotopy type theory, \texttt{transport} is typically called \texttt{subst} or \texttt{replace}, because it also expresses that substituting equal elements for equal elements is acceptable.
\begin{center}
\begin{Verbatim}
transport : {A : Set} {x y : A} → 
  (P : A → Set) → (p : x ≡ y) → P x → P y
\end{Verbatim}
\end{center}

In the postulated computation rule for \texttt{indS}, the function {\tt apd} is the dependent version of \texttt{ap}: it expresses the action of dependent functions on paths.
\begin{center}
%\begingroup
\begin{Verbatim}
apd : {A : Set} {B : A → Set} {x y : A} → 
      (f : (a : A) → B a) → (p : x ≡ y) →
      transport B p (f x) ≡ f y
\end{Verbatim}
%\endgroup
\end{center}

The next section introduces the necessary automation features by describing the automatic generation of eliminators for a variant on Dybjer's inductive families.\todo{Check whether this is right - it might be a variation on Luo's inductive types instead.} Section 4 then generalizes this feature to automate the production of eliminators for higher inductive types using Licata's technique. Section 5 revisits \citeauthor{Angiuli-2014}'s encoding of Darcs's patch theory \citep{Angiuli-2014} and demonstrates that the higher inductive types employed in that paper can be generated succinctly using our library.

\section{Code Generation for Inductive Types}
\label{sec:sec3}
An inductive type $D$ is a type that is freely generated by a finite collection of constructors. The constructors of $D$ accept zero or more arguments, and result in an $D$. The constructors can also take an element of type $D$ itself as an argument, but only \emph{strictly positively}: any occurrences of the type constructor $D$ in the type of an argument to a constructor of $D$ must not be to the left of any arrows.
Type constructors can have a number of \emph{parameters}, which may not vary between the constructors, as well as \emph{indices}, which may vary.


In Agda, constructors are given a function type. In Agda's reflection library, the constructor {\tt data-type} of the datatype {\tt Definition} stores the constructors of an inductive type as a list of \texttt{Name}s. The type of a constructor can be retrieved by giving its {\tt Name} as an input to the {\tt getType} primitive. In this section, we discuss how to use the list of constructors and their types to generate code for the elimination rules of an inductive type.

\subsection{Non-dependent Eliminators}
\label{sec:sec3.1}

\newcommand*{\KW}[1]{\textsf{\textbf{#1}}}
\newcommand*{\SET}{\textsf{Set}}

In Agda, we define an inductive type using {\tt data} keyword. A definition of an inductive datatype declares its type and specifies its constructors.
While Agda supports a variety of ways to define new datatypes, we will restrict our attention to the subset that correspond closely to Dyber's inductive families\todo{cite 1994 paper}. In general, the definition of an inductive datatype $D$ with constructors $c_1 \ldots c_n$ has the following form:
\begin{center}
\begingroup
\fontsize{7.9pt}{0pt}\selectfont
\begin{align*}
&\KW{data}\ D\ (a_1 : A_1) \ldots (a_n:A_n) : (i_1 : I_1) \rightarrow\ldots\rightarrow (i_m : I_m) \rightarrow \SET{}\ \KW{where}  \\
&\hspace{0.3cm} c_1 : \Delta_1 \rightarrow D \, a_1 \ldots a_n \, e_{11} \ldots e_{1m}  \\
&\hspace{3.5cm} \vdots  \\
&\hspace{0.3cm} c_r : \Delta_n \rightarrow D \, a_1 \ldots a_n \, e_{r1} \ldots e_{rm}  \\
\end{align*}
\endgroup
\end{center}
\normalsize
where the index instantiations $e_{k1} \ldots e_{km}$ are expressions in the scope induced by the telescope $\Delta_k$. Every expression in the definition must also be well-typed according to the provided declarations.


As an example, the datatype \texttt{Vec} represents lists of a known length. It is defined in figure~\ref{fig:vec}.
There is one parameter, namely \texttt{(A : Set)}, and one index, namely \texttt{Nat}.
The second constructor, \texttt{\_::\_}, has a recursive instance of \texttt{Vec} as an argument.

\begin{figure}
\begin{center}
%\begingroup
\begin{BVerbatim}
data Vec (A : Set) : Nat → Set where
  []   : Vec A zero
  _::_ : {n : Nat} →
         (x : A) → (xs : Vec A n) → 
         Vec A (suc n)
\end{BVerbatim}
%\endgroup
\end{center}
\caption{Length-indexed lists}
\label{fig:vec}
\end{figure}



%The type of $A_i$ can take one of the three forms: a constant type {\tt B}, the inductive type $D$, or a function $B_1 \rightarrow \ldots \rightarrow B_n \rightarrow D$ with codomain $D$. The parameters $(x_1:P_1)\ldots(x_n:P_n)$ are common to all the constructors, and the type of each constructor implicitly encodes the parameter references. However, the indices are different for each constructor. So, the type of each constructor explicitly exhibits the index declaration.

While inductive datatypes are essentially characterized by their constructors, it must also be possible to eliminate their inhabitants, exposing the information in the constructors.
This section describes an Agda metaprogram that generates a non-dependent recursion principle for an inductive type; section~\ref{sec:sec3.2} generalizes this technique to fully dependent induction principles.

For {\tt Vec}, the recursion principle says that, in order to eliminate a \texttt{Vec A n}, one must provide a result for the empty \texttt{Vec} and a means for transforming the head and tail of a non-empty \texttt{Vec} combined with the result of recursion onto a tail into the desired answer for the entire \texttt{Vec}.
Concretely, the type of the recursor \texttt{recVec} is:
\begin{center}
\begin{BVerbatim}
recVec : (A : Set) →
         {n : Nat} → Vec A n →
         (C : Set) →
         (base : C) →
         (step : {n : Nat} →
                 (x : A) →
                 (xs : Vec A n) → C →
                 C) →
         C
\end{BVerbatim}
\end{center}
The recursor \texttt{recVec} maps the constructor {\tt []}, which takes zero arguments, to \texttt{base}.
It maps \texttt{(x :: xs)} to {\tt (step x xs (recVec xs C base step))}.
Because \texttt{step} is applied to a recursive call to the recursor, it takes one more argument than the constructor \texttt{\_::\_}.


Based on the schematic presentation of inductive types $D$ earlier in this section, we can define a schematic representation for their non-dependent eliminators $D_{\mathit{rec}}$.
\begin{align*}
D_{\mathit{rec}} :\ & (a_1 : A_1) \to \ldots \to (a_n : A_n) \to\\
& (i_1 : I_1) \to \ldots \to (i_m : I_m) \to\\
& (\mathit{tgt} : D\ a_1 \ldots a_n\ i_1\ \ldots\ i_n) \to\\
& (\mathit{C} : \SET{}) \to \\
& (\mathit{f_1} : \Delta_1^\prime \to \mathit{C}) \to \ldots \to (\mathit{f_r} : \Delta_r^\prime \to \mathit{C}) \to \\
& \mathit{C}
\end{align*}

The type of $f_i$, which is the method for fulfilling the desired type $C$ when eliminating the constructor $c_i$, is determined by the type of $c_i$.
The telescope $\Delta_i^\prime$ is the same as $\Delta_i$ for non-recursive constructor arguments.
However, $\Delta_i^\prime$ binds additional variables when there are recursive occurrences of $D$ in the arguments.
If $\Delta_i$ has an argument $(y : B)$, where $B$ is not an application of $D$ or a function returning such an application, $\Delta_i^\prime$ binds $(y : B)$ directly.
If $B$ is an application of $D$, then an additional binding $(y^\prime : C)$ is inserted following $y$.
Finally, if $B$ is a function type $\Psi \to D$, the additional binding is $(y^\prime : \Psi \to C)$. 

To construct the type of \texttt{recVec}, we need to build the types of {\tt base} and {\tt step}.
These are derived from the corresponding types of \texttt{base} and \texttt{\_::\_}, which can be discovered using reflection primitives.
Since {\tt []} requires no arguments, its corresponding method is {\tt (base : C)}.
The constructor {\tt pi} of type {\tt Term} encodes the abstract syntax tree (AST) representation of {\tt \_::\_} (figure~\ref{fig:ast-g}). We can retrieve and traverse the AST of {\tt \_::\_}, and add new type information into it to build a new type representing {\tt step}.

During the traversal of abstract syntax tree of the type of {\tt \_::\_}, when the type {\tt Vec} occurs directly as an argument, the result type {\tt C} is added next to it.
For example, in figure~\ref{fig:ast-g}, a new function is built from the argument {\tt (xs : Vec A n)} by modifying it to {\tt (Vec A n) → C} (figure~\ref{fig:ast-d}).
Arguments other than \texttt{Vec} require no modifications.
Therefore, {\tt (x : A)} is copied into the new type without any changes.
Finally, the codomain \texttt{Vec A (suc n)} of {\tt \_::\_}'s type is replaced with \texttt{C}, resulting in an AST for the type of {\tt step}.


\begin{figure}
\begin{center}
\begingroup
\fontsize{9pt}{10pt}\selectfont
\begin{Verbatim}
pattern _[_v]⇒_ a s b = pi (vArg a) (abs s b)
pattern _[_h]⇒_ a s b = pi (hArg a) (abs s b)

(agda-sort (lit 0) [ "A" h]⇒         -- A
 (def (quote Nat) [] [ "n" h]⇒       -- n
  (var 1 [] [ "x" v]⇒                -- x
   (def (quote Vec)                   -- xs : Vec A n
        (vArg (var 2 []) ::
         vArg (var 1 []) :: [])
         [ "xs" v]⇒
    def (quote Vec)                  -- Vec A (suc n)
        (vArg (var 3 []) ::
         vArg (con (quote suc)
                (vArg (var 2 []) :: []))
         :: [])))))
\end{Verbatim}
\endgroup
\end{center}
\caption{Abstract syntax tree for the type of {\tt \_::\_}}
\label{fig:ast-g}
\end{figure}
\normalsize

In general, when automating the production of $D_{\mathit{rec}}$, all the information that is needed to produce the type signature is available in the \texttt{TC} monad by looking up $D$'s definition.
The constructor {\tt data-type} contains the number of parameters occurring in a defined type. It also encodes the constructors of the type as a list of \texttt{Name}s. Metaprograms can retrieve the index count by finding the difference between the number of parameters and the length of the constructor list. The constructors of $D$ refer to the parameter and the index using de~Bruijn indices.

The method {\tt step} for the constructor {\tt \_::\_} in {\tt Vec}, refers to the parameter and the index using de~Bruijn indices.
During the construction of the type of {\tt step}, the recursor generator updates the de~Bruijn indices accordingly.
Note that not all indices occur as arguments to a constructor: in {\tt Vec}, the constructor {\tt []} instantiates the index with a constant.
Agda does not provide a reflection primitive to retrieve the index count from a constructor name.
A workaround is to pass the index count of each constructor explicitly to the metaprogram.\todo{What do these last 2 sentences mean? What is an index count?}

Once the AST for {\tt step}'s type has been found, it is possible to build the type of {\tt recVec} in figure~\ref{fig:ast-d}.
To quantify over the return type \texttt{(C : Set)}, the \texttt{Term} constructor \texttt{agda-sort} refers to \texttt{Set)}. 


The general schema for the computation rules corresponding to $D_{\mathit{rec}}$ and constructors $c_1, \ldots, c_n$ follows:

\newcommand*{\RHSap}[2]{\ensuremath{\mathsf{RHS}\left(#1, #2\right)}}
\newcommand*{\RHS}[1]{\RHSap{f_{#1}}{\Delta_{#1}^\prime}}


\begin{center}
\begingroup
\fontsize{8.9pt}{2pt}\selectfont
\begin{align*}
& D_\mathit{rec}\ a_1\ \ldots\ a_n\ i_1\ \ldots\ i_m\ (c_1\ {\Delta_1}) \, C \, f_1 \ldots f_r = \\
&\hspace{0.5cm}\RHS{1}\\
& \vdots  \\
& D_\mathit{rec}\ a_1\ \ldots\ a_n\ i_1\ \ldots\ i_m\ (c_r\ {\Delta_r}) \, C \, f_1 \ldots f_r = \\
&\hspace{0.5cm}\RHS{r}\\ 
\end{align*}
\endgroup
\end{center}
\normalsize

Here, $\overline{\Delta_j}$ is the sequence of variables bound in $\Delta_j$.
$\mathsf{RHS}$ constructs the application of the method $f_j$ to the arguments of $c_j$, such that $C$ is satisfied.
It is defined by recursion on $\Delta_j$.
$\RHSap{f_j}{\cdot}$ is $f_j$, because all arguments have been accounted for.
$\RHSap{f_j}{(y : B)\Delta_k}$ is $\RHSap{f_j\ y}{\Delta_k}$ when $B$ does not mention $D$.
$\RHSap{f_j}{(y : D) (y^\prime : C)\Delta_k}$ is $\RHSap{f_j\ y\ \left(D_{\mathit{rec}}\ \ldots y \ldots\right)}{\Delta_k}$, where the recursive use of $D_{\mathit{rec}}$ is applied to the recursive constructor argument as well as the appropriate indices, and the parameters, result type, and methods remain constant.
Higher-order recursive arguments are a generalization of first-order arguments.
Finally,
\begin{displaymath}
\RHSap{f_j}{(y : \Psi \to D) (y^\prime : \Psi \to C)\Delta_k}
\end{displaymath}
is
\begin{displaymath}
\RHSap{f_j\ y\ \left(\lambda \overline{\Psi} . D_{\mathit{rec}}\ \ldots \left(y\ \overline{\Psi} \right) \ldots\right)}{\Delta_k}
\end{displaymath}
where the recursive use of $D_{\mathit{rec}}$ is as before.





\begin{figure}
\begin{center}
\begingroup
\fontsize{9pt}{10pt}\selectfont
\begin{Verbatim}
(agda-sort (lit 0) [ "A" h]⇒              -- A
 (def (quote Nat) [] [ "n" h]⇒            -- n
  (def (quote Vec) (vArg (var 1 []) ::     -- Vec A n
     vArg (var 0 []) :: []) [ "_" v]⇒
   (agda-sort (lit 0) [ "C" v]⇒           -- C
    (var 0 [] [ "_" v]⇒                   -- base
     ((def (quote Nat) [] [ "n" h]⇒       -- step
       (var 5 [] [ "x" v]⇒                -- x
        (def (quote Vec)
          (vArg (var 6 []) ::         
           vArg (var 1 []) ::
           [])
          [ "xs" v]⇒                      -- xs
          (var 4 [] [ "_" v]⇒             -- → C
           var 5 []))))                    -- C
      [ "_" v]⇒ var 2 []))))))            -- C
\end{Verbatim}
\endgroup
\end{center}
\caption{Abstract syntax tree of \texttt{recVec}'s type}
\label{fig:ast-d}
\end{figure}
\normalsize


After declaring \texttt{recVec}'s type using {\tt declareDef}, it is time to define its computational meaning.
The computation rule representing the action of function \texttt{recVec} on {\tt []} and {\tt \_::\_} using {\tt clause} (figure~\ref{fig:ast-cdef}). The first argument to {\tt clause} encodes variables corresponding to the above type, and it also includes the abstract representation of the constructors {\tt []} and {\tt \_::\_} on which the pattern matching should occur. The second argument to \texttt{clause}, which is of type {\tt Term}, refers to the variables in the first argument using de~Bruijn indices, and it encodes the output of \texttt{recVec} when the pattern matches.
The constructor {\tt var} of {\tt Pattern} is used to introduce new variables in the {\tt clause} definition. The type {\tt Pattern} also has another constructor {\tt con} that represents patterns that match specific constructors.
The type {\tt Term} has similar constructors {\tt var} and {\tt con}, that respectively represent variable references and constructor invocations.
The computation rules for \texttt{recVec} are
\begin{Verbatim}
recVec []        C base step =
  base
recVec (x :: xs) C base step =
  step x xs (f xs C base step)
\end{Verbatim}



\begin{figure}
\begin{center}
\begingroup
\fontsize{9pt}{10pt}\selectfont
\begin{Verbatim}
(clause
  (vArg (con (quote _::_)           -- _::_
          (vArg (var "x") ::        -- x
           vArg (var "xs") :: []))  -- xs
   vArg (var "C") ::                -- C
   vArg (var "base") ::             -- base
   vArg (var "step") :: [])         -- step
  (var 0                            
    (vArg (var 4 []) ::             -- x
     vArg (var 3 []) ::             -- xs
     vArg
      (def recVec                   -- recursion
       (vArg (var 3 [])             -- xs
        vArg (var 2 []) ::          -- C
        vArg (var 1 []) ::          -- base
        vArg (var 0 []) :: [])))))  -- step

\end{Verbatim}
\endgroup
\end{center}
\caption{Clause definition for the computation rule of \texttt{\_::\_}}
\label{fig:ast-cdef}
\end{figure}
\normalsize

\begin{figure}
\begin{center}
%\begingroup
\begin{BVerbatim}
data W (A : Set) (B : A → Set) : Set where
  sup : (a : A) → (B a → W A B) → W A B
\end{BVerbatim}
%\endgroup
\end{center}
\caption{W-Type}
\label{fig:W-type}
\end{figure}

Figure~\ref{fig:ast-cdef} presents the AST for the clause that matches \texttt{\_::\_}.
The de~Bruijn index reference increments right-to-left, starting from the last argument.
Definitions by pattern matching are added to the global context using the \texttt{defineFun} primitive.


Figure~\ref{fig:W-type} presents an Agda encoding of Martin-Löf's well-orderings, the so-called \emph{W-type}.
\texttt{W} is interesting because its constructor exhibits a \emph{higher-order} recursive instance of the type being defined.
Following the recipe yields the recursor in figure~\ref{fig:recW}, in which the recursive call occurs under a function representing arbitrary choices of tag.
\begin{figure}
\begin{Verbatim}
recW : ∀ {A B}
       (tgt : W A B) →
       (C : Set) →
       (step : (x : A) →
               (f : B x → W A B) →
               (f' : B x → C) →
               C) →
       C
recW (sup x f) C step =
  step x f (λ b → recW (f b) C step)
\end{Verbatim}
  \caption{The non-dependent eliminator for \texttt{W}}
  \label{fig:recW}
\end{figure}

The type of {\tt step} is built by traversing the AST of {\tt sup}'s type.
The first argument to {\tt sup}, which is a constant type {\tt A}, is copied directly into \texttt{step}'s type.
The second argument is a {\tt (B x → W A B)}, which is a function whose codomain is a recursive instance of {\tt W}.
The resulting arguments must account for the recursion and are thus {\tt (B x → W A B)} and \texttt{(B x → C)}.
Finally, the codomain {\tt W A B} of {\tt sup} is replaced by {\tt C}.

In the above computation rule, the third argument to {\tt step} is a function that works for any choice of tag \texttt{b}.
The arguments to {\tt lam} are referenced using de~Bruijn indices inside the lambda body.
Thus, the de~Bruijn indices for referring variables outside the lambda body must be updated accordingly.



\begin{figure}
\begin{center}
\begin{Verbatim}
generateRec : Arg Name → Name → 
  (indexList : List Nat) → TC ⊤
generateRec (arg i f) t indLs =
  do indLs' ← getIndex t indLs
     cns ← getConstructors t
     lcons ← getLength cns
     cls ← getClause lcons zero t f indLs cns
     RTy ← getType t
     funType ← getRtype t indLs' zero RTy
     declareDef (arg i f) funType
     defineFun f cls
\end{Verbatim}
\end{center}
\caption{Implementation for {\tt generateRec}}
\label{fig:generateRec}
\end{figure}

Figure~\ref{fig:generateRec} demonstrates the implementation of {\tt generateRec}, which constructs recursors.
{\tt generateRec} uses {\tt getClause} and {\tt getRtype} to build the computation and elimination rules respectively. It takes three arguments: the name of the function to be defined (represented by an element of type {\tt Arg Name}), the quoted {\tt Name} of the datatype, and a list containing the index count\todo{What is an index count?} of the individual constructors. {\tt generateRec} can be used to automate the generation of recursion rules for inductive types having the general schema given at the beginning of this section. The recursion rule generated by {\tt generateRec} is brought into scope using {\tt unquoteDecl} as follows.

\begin{center}
\begin{BVerbatim}
unquoteDecl f = generateRec (vArg f)
                  (quote Vec) 
                  (0 :: 1 :: [])
\end{BVerbatim}
\end{center}

The third argument to {\tt generateRec} is a list consisting of the index count\todo{What is this?} for the constructors. It is required to pass the index count for each constructor explicitly as the Agda reflection library does not have built-in primitives to retrieve the index value.

\subsection{Dependent Eliminators}
\label{sec:sec3.2}

The dependent eliminator for a datatype, also known as the \emph{induction principle}, is used to eliminate elements of a datatype when the type resulting from the elimination mentions the very element being eliminated. The type of the induction principle for $D$ is:
\begin{align*}
D_{\mathit{ind}} :\ & (a_1 : A_1) \to \ldots \to (a_n : A_n) \to\\
& (i_1 : I_1) \to \ldots \to (i_m : I_m) \to\\
& (\mathit{tgt} : D\ a_1 \ldots a_n\ i_1\ \ldots\ i_m) \to\\
& \begin{array}{@{}l@{}l}(\mathit{C} :\ & (i_1 : I_1) \to \ldots \to (i_m : I_m) \to\\  & D\ a_1 \ldots a_n\ i_1\ \ldots\ i_n \to\\ &\SET{})\to\end{array} \\
& (\mathit{f_1} : \Delta_1^\prime \to \mathit{C}\ e_{11} \ldots e_{1p}\ (c_1\ \overline{\Delta_1})) \to \\
& (\mathit{f_r} : \Delta_r^\prime \to \mathit{C}\ e_{r1} \ldots e_{rp}\ (c_r\ \overline{\Delta_r})) \to \\
& \mathit{C}\ i_1\ \ldots\ i_n\ \mathit{tgt}
\end{align*}

Unlike the non-dependent recursion principle $D_{\mathit{rec}}$, the result type is now computed from the target and its indices.
Because it expresses the reason that the target must be eliminated, the function $C$ is often referred to as the \emph{motive}.
Similarly to  $D_{\mathit{rec}}$, the type of each method $f_i$ is derived from the type of the constructor $c_i$---the method argument telescope $\Delta_k^\prime$ is similar, except the arguments that represent the result of recursion now apply the motive $C$ to appropriate arguments.
If $\Delta_i$ has an argument $(y : B)$, where $B$ is not an application of $D$ or a function returning such an application, $\Delta_i^\prime$ still binds $(y : B)$ directly.
If $B$ is an application of $D$ to parameters $a\ldots$ and indices $e\ldots$, then an additional binding $(y^\prime : C\ e\ldots\ y)$ is inserted following $y$.
Finally, if $B$ is a function type $\Psi \to D\ a\ldots\ e\ldots$, the additional binding is $(y^\prime : \Psi \to C\ e\ldots (y\ \overline{\Psi}))$. 

The computation rules for the induction principle are the same as for the recursion principle.
Following these rules, the induction principle for \texttt{W} can be seen in figure~\ref{fig:w-ind}.

\begin{figure}
\begin{Verbatim}
indW : {A : Set} → {B : A → Set} →
       (tgt : W A B) →
       (mot : W A B → Set) →
       (step : (x : A) →
               (f : B x → W A B) →
               (f' : (b : B x) → mot (f b)) →
               mot (sup x f)) →
       mot tgt
indW (sup x f) mot step =
  step x f (λ b -> indW (f b) mot step)
\end{Verbatim}
  \caption{The induction principle for \texttt{W}}
  \label{fig:w-ind}
\end{figure}

Automating the production of the dependent eliminator is an extension of the procedure for automating the production of the non-dependent eliminator.

We can construct the AST of {\tt d} using the static type information obtained from {\tt sup}.
To construct \texttt{indW}, during the traversal of the AST of \texttt{sup}'s type, the argument {\tt (a : A)} is copied without any changes, just as it is in the case of the non-dependent eliminator.
The next argument, however, is a function that returns a \texttt{W}.
An additional argument, representing the induction hypothesis, is needed.
The induction hypothesis {\tt (f' : (b : B x) → mot (f b))} takes the same arguments as {\tt f}, but it returns the motive instantiated at the application of \texttt{f}.
The final return type is found by applying the motive to the target and its indices (figure~\ref{fig:ast-d'}).

\begin{figure}
\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}
(agda-sort (lit 0) [ "A" h]⇒               -- A
 ((var 0 [] [ "_" v]⇒                      -- B : A → Set
     agda-sort (lit 0)) [ "B" h]⇒
  (def (quote W)
       (vArg (var 1 []) ::                 -- tgt : W A B
        vArg (var 0 []) :: []) [ "tgt" v]⇒
   ((def (quote W)
      (vArg (var 2 []) ::                  -- mot : W A B → Set
       vArg (var 1 []) :: []) [ "_" v]⇒
     agda-sort (lit 0)) [ "mot" v]⇒
    ((var 3 [] [ "x" v]⇒                   -- x : A
      ((var 3
        (vArg (var 0 []) :: [])             -- f : B x → W A B
        [ "_" v]⇒
        def (quote W)
         (vArg (var 5 []) :: 
          vArg (var 4 []) :: [])) [ "f" v]⇒
       ((var 4 (vArg (var 1 []) ::          -- f' : B x → mot (f x)
                [])
         [ "f'" v]⇒
         var 3
          (vArg (var 1 (vArg (var 0 []) ::
                        [])) ::
                []))
        [ "z" v]⇒
        var 3                               -- mot (sup x f)
        (vArg
         (con (quote sup)
          (vArg (var 2 []) :: 
           vArg (var 1 []) :: []))
         :: []))))
     [ "_" v]⇒ var 1 (vArg (var 2 []) ::    -- mot tgt
                      []))))))
\end{Verbatim}
\endgroup
\end{center}
\caption{Abstract syntax tree for the dependent eliminator of {\tt W}}
\label{fig:ast-d'}
\end{figure}
\normalsize

We can construct the type of the induction principle {\tt f} using {\tt d}. The type {\tt C} in the mapping {\tt f} depends on the element of the input type {\tt W A B}.
Operationally, the induction principle computes just like the recursion principle.
It is constructed using {\tt clause} definitions following the same approach.
The generation of induction principles is carried out using {\tt generateInd}, in figure~\ref{fig:generateInd}.

%The following code gives the implementation of {\tt generateInd}.

%\begin{center}
%\begingroup
%\begin{BVerbatim}
\begin{figure}
\begin{center}
\begin{Verbatim}
generateInd : Arg Name → Name → 
  (indexList : List Nat) → TC ⊤
generateInd (arg i f) t indLs =
  do id' ← getIndex t indLs
     cns ← getConstructors t
     lcns ← getLength cns
     cls ← getClauseDep lcns zero t f id' cns
     RTy ← getType t
     funType ← getRtypeInd t zero id' RTy
     declareDef (arg i f) funType
     defineFun f cls
\end{Verbatim}

\end{center}
\caption{Implementation for {\tt generateInd}}
\label{fig:generateInd}
\end{figure}
\normalsize

%\end{BVerbatim}
%\endgroup
%\end{center}

{\tt generateInd} uses {\tt getClauseDep} to generate the {\tt clause} definitions representing the computation rules. The abstract representation of the type is provided by {\tt getRtypeInd}.
A version of the induction principle called {\tt indW'} generated by {\tt generateInd} is brought into scope by {\tt unquoteDecl} as follows:
\begin{center}
\begingroup
\begin{BVerbatim}
unquoteDecl indW' = generateInd (vArg f) 
                      (quote W) []
\end{BVerbatim}
\endgroup
\end{center}

% TODO: This makes no sense to DTC, so it is commented out for now
% An empty list is passed to {\tt generateInd}, because {\tt W} has no indices.
% An empty list can also be passed if all the constructors of a type has the same number of index as the parent type. But if any one constructor has an index count different from the index count of the parent type, then the index count of all the constructors should be passed explicitly.
%
\section{Code Generation for Higher Inductive Types}
\label{sec:sec4}

In Agda, there are no built-in primitives to support the definition of higher inductive types.
However, we can still define a higher inductive type with a base type using Licata's~\citep{Licata-2011} method, as described in section~\ref{sec:sec2.1}.
In this section, we discuss the automation of code generation for the boiler-plate code segments defining the higher inductive types.


\subsection{Defining Higher Inductive Types}
\label{sec:sec4.1}

Our library defines a higher inductive type $G$ as a top-level definition using a base type $D$, similar to the module {\tt Circle} in section 2.1.
The first step is to generate the private base type.
After this, public definitions are created to provide access to the constructors, and the paths are postulated.
Finally, the elimination principles are generated, and their actions on paths are postulated.

The first step is to copy the type constructor $D$'s type, re-using it for the declaration of $G$.
Next, the library copies the type of each constructors $c_i$ to a corresponding definition $g_i$, except each reference to $D$ is replaced by a reference to $G$.

We explicitly pass the types of the path constructors to the automation tool. The higher inductive type definition of {\tt Circle} in section 2.1 represents the path constructors as propositional equalities. The automation tool takes the path types as input and declares them as propositional equalities using the reflection primitive {\tt declarePostulate}. We introduce a new data type {\tt ArgPath} (figure~\ref{fig:argPath}) to input the path types to the automation tool. The constructor {\tt argPath} takes the type of a path constructor as input.

\begin{figure}
\begin{center}
\begingroup
\begin{BVerbatim}
data ArgPath {ℓ₁} : Set (lsuc ℓ₁) where
  argPath : Set ℓ₁ → ArgPath
\end{BVerbatim}
\endgroup
\end{center}
\caption{Definition of ArgPath}
\label{fig:argPath}
\end{figure}

We define the generic form of a higher inductive type as follows.
\begin{center}
\begingroup
\fontsize{10pt}{0pt}\selectfont
\begin{align*}
& \texttt{data-hit (quote D) G}\\
  & \hspace {0.3cm} \texttt{Gpoints ($g_1$ :: $\ldots$ :: $g_n$ :: [])} \\
  & \hspace {0.3cm} \texttt{Gpaths ($p_1$ :: $\ldots$ :: $p_n$ :: [])} \\
  & \hspace {0.3cm} \texttt{(argPath} \\
  & \hspace {0.6cm} (\{x_1:P_1\} \rightarrow \ldots \rightarrow \{x_n:P_n\} \rightarrow \\
  & \hspace {0.7cm} \{i_1:Q_1\} \rightarrow \ldots \rightarrow \{i_n:Q_n\} \rightarrow \Delta_1 \rightarrow \\
  & \hspace {0.7cm} (c_i \{x_1\} \ldots \{x_n\} \{i_1\} \ldots \{i_n\} \ldots) \equiv (c_j \ldots))\ \texttt{::} \\
  & \hspace {3cm} \vdots \\
  & \hspace {0.4cm} \texttt{argPath} \\
  & \hspace {0.6cm} (\{x_1:P_1\} \rightarrow \ldots \rightarrow \{x_n:P_n\} \rightarrow \\
  & \hspace {0.7cm} \{j_1:Q_1\} \rightarrow \ldots \rightarrow \{j_n:Q_n\} \rightarrow \Delta_n \rightarrow \\
  & \hspace {0.7cm} (c_i \{x_1\} \ldots \{x_n\} \{j_1\} \ldots \{j_n\} \ldots) \equiv (c_j \ldots))\ \texttt{:: [])}\\ \nonumber
\end{align*}
\endgroup
\end{center}
\normalsize

We define holders $Gpoints$ for point constructors and $Gpaths$ for path constructors as part of the higher inductive type definition of $G$. We cannot retrieve the constructors of the higher inductive type $G$ using {\tt Definition}. Therefore, $Gpoints$ and $Gpaths$ act as the only references for the constructors of $G$. The elements of the {\tt argPath} list represent the type of the path constructors $p_1 \ldots p_n$ respectively. We explicitly include the parameter references $\{x_1 : P_1\} \ldots \{x_n : P_n\}$ and the index references $\{k_1 : Q_1\} \ldots \{k_n : Q_n\}$ in the type of the arguments to {\tt argPath}. The constructor $g_i$ is not in scope when used in the path type passed to {\tt argPath}. Therefore, we use the base type constructor $c_i$ as a dummy argument in the place of $g_i$. The automation tool implements the interface {\tt data-hit} as given in figure~\ref{fig:data-hit}.

%\begin{center}
%\begingroup
%\begin{BVerbatim}
\begin{figure}
\begin{center}
\begingroup
\begin{Verbatim}
data-hit : ∀{ℓ₁} 
  (baseType : Name) → (indType : Name) →
  (pointHolder : Name) → (lcons : List Name) →
  (pathHolder : Name) → (lpaths : List Name) →
  (lpathTypes : (List (ArgPath {ℓ₁}))) → TC ⊤
data-hit base ind h1 lcons h2 lpaths pTy =
  do defineHindType base ind
     cns ← getConstructors base
     defineHitCons base ind cns lcons
     pTy' ← getPathTypes base ind cns lcons pTy
     defineHitPathCons lpaths pTy'
     definePointHolder h1 lcons
     definePathHolder h2 lpaths
\end{Verbatim}
\endgroup
\end{center}
\caption{The implementation of {\tt data-hit}}
\label{fig:data-hit}
\end{figure}
\normalsize

%\end{BVerbatim}
%\endgroup
%\end{center}

The higher inductive type \texttt{G}, the points $g_1 \ldots g_n$, the paths $p_1 \ldots p_n$, and the holders \texttt{Gpoints} and \texttt{Gpaths} are brought into scope by {\tt unquoteDecl}. In the implementation of {\tt data-hit} in figure~\ref{fig:data-hit}, {\tt defineHindType} defines the higher inductive type as a top-level definition using the base type. The interface {\tt defineHitCons} specifies the point constructors of the higher inductive type using the type information obtained from the constructors of the base type, and the interface {\tt defineHitPathCons} builds the paths constructors of the higher inductive type using the {\tt argPath} list. The following code automates the generation of the higher inductive type definition for {\tt Circle} given in section 2.1.
\begin{center}
\begingroup
\begin{BVerbatim}
unquoteDecl S Spoints base Spaths loop =
  data-hit (quote S*) S
    Spoints (base :: []) -- point constructors
    Spaths (loop :: [])  -- path constructors
    (argPath (base* ≡ base*) :: []) 
    -- base replaces base*
\end{BVerbatim}
\endgroup
\end{center}

The identity type input {\tt (base* ≡ base*)} to argPath represents the type of the path {\tt loop}, and it uses the inductive type constructor {\tt base*} as a dummy argument in the place of the higher inductive type constructor {\tt base}. The constructor {\tt base} comes into scope only during the execution of {\tt unquoteDecl}, and so cannot be used in the identity type reference in {\tt argPath}. We use the constructor {\tt base*} of type {\tt S*} as dummy argument because the type of {\tt base*} is similar to {\tt base}, and has the same references for the common arguments. The automation tool traverses the abstract syntax tree of {\tt loop} and replaces the occurrences of {\tt base*} with {\tt base}.

\subsection{Non-dependent Eliminator}
\label{sec:sec4.2}

Non-dependent eliminator or the recursion principle of a higher inductive type $G$ maps the points and paths of $G$ to an output type $C$. We extend the general schema of the recursion principle given in section \ref{sec:sec3.1} by adding methods for path constructors as follows.
\begin{align*}
G_{\mathit{rec}} : & (a_1 : A_1) \to \ldots \to (a_n : A_n) \to\\
& (i_1 : I_1) \to \ldots \to (i_m : I_m) \to\\
& (\mathit{tgt} : G\ a_1 \ldots a_n\ i_1\ \ldots\ i_n) \to\\
& (\mathit{C} : \SET{}) \to \\
& (\mathit{f_1} : \Delta_1^\prime \to \mathit{C}) \ldots (\mathit{f_r} : \Delta_r^\prime \to \mathit{C}) \to \\
& (\mathit{k_1} : \Delta_1^\prime \to (f_i \ldots) \equiv (f_j \ldots)) \to \\
& \vdots \\
& (\mathit{k_r} : \Delta_r^\prime \to (f_i \ldots) \equiv (f_j \ldots)) \to \\
& \mathit{C}
\end{align*}
 
In the schema definition above, we have given only one-dimensional paths. The automation tool currently supports one-dimensional paths, and we are planning to improve the tool to support higher-dimensional paths in the future. 

The type of $f_i$, method for the point constructor $g_i$ in $G_{rec}$, is built the same way as for the normal inductive type $D$ (sec.\ref{sec:sec3.1}). The automation tool builds the type of $k_i$, method for path constructor $p_i$ in $G_{rec}$, by traversing the AST of $p_i$. The arguments of $k_i$ are handled the same way as for the point constructor $f_i$. During the traversal, the automation tool uses the base type recursor $D_{rec}$ to map the point constructors $g_i$ of $G$ in the codomain of $p_i$ to $f_i$. The schema for the computation rules corresponding to points $g_i$ is similar to the computation rules corresponding to constructors $c_i$ of the inductive type $D$ except that it has additional variables to represent paths. The schema for the computation rules corresponding to paths $p_i$ is given as follows.
\begin{align*}
\beta G_{rec} :  & (a_1 : A_1) \to \ldots \to (a_n : A_n) \to\\
& (\mathit{C} : \SET{}) \to \\
& (\mathit{f_1} : \Delta_1^\prime \to \mathit{C}) \ldots (\mathit{f_r} : \Delta_r^\prime \to \mathit{C}) \to \\
& (\mathit{k_1} : \Delta_1^\prime \to (f_i \ldots) \equiv (f_j \ldots)) \to \\
& \vdots \\
& (\mathit{k_r} : \Delta_r^\prime \to (f_i \ldots) \equiv (f_j \ldots)) \to \\
& \mathit{ap} \, (\lambda \, x \to G_{rec} \, x \, C \, f_1 \, f_r \, k_1 \, k_r) \, (p_i \ldots) \equiv (k_i \ldots)
\end{align*}

The computation rule $\beta G_{rec}$ exists only as propositional equality. The automation tool builds the type of $\beta G_{rec}$ using the same approach as for the recursion rule $G_{rec}$. The type of $G_{rec}$ and $\beta G_{rec}$ is similar except for the mapping $G \to C$ in $G_{rec}$ which is replaced by the term representing the action of function $G_{rec}$ on the path $(p_i \, \ldots)$. The function {\tt ap} (sec. \ref{sec:sec2.2}) applies $G_{rec}$, which is nested inside a lambda function, on the path $(p_i \ldots)$. The tool uses the constructor {\tt lam} of {\tt Term} to introduce a lambda function.

Lets consider the higher inductive type {\tt S} (sec \ref{sec:sec2.1}), which represents the {\tt Circle}. To define a mapping {\tt recS : S → C}, we need a point {\tt cbase : C} and a path {\tt cloop : cbase ≡ cbase} in the space {\tt C}. To construct the recursion principle {\tt recS}, we need to build the type of point {\tt cbase} and path {\tt cloop}. The type of {\tt cbase} is built from the AST of points {\tt base} using the approach described in section \ref{sec:sec3.1}. The automation tool builds the type of {\tt cloop} by traversing the AST of {\tt loop}. During the traversal, the tool maps the point {\tt base}, which forms the two arguments to the identity type in the codomain of the path {\tt loop}, to the point {\tt cbase} using the recursor of the base type {\tt S*}.

\begin{figure}
\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}
(def (quote S) [] [ "_" v]⇒                 -- S
 (agda-sort (lit 0) [ "C" v]⇒               -- C : Set
  (var 0 [] [ "cbase" v]⇒                   -- cbase
   (def (quote _≡_)                         -- cloop
    (vArg (var 0 []) ::
     vArg (var 0 []) :: [])
    [ "cloop" v]⇒ var 2 []))))
\end{Verbatim}
\endgroup
\end{center}
\caption{Abstract syntax tree for {\tt recS}}
\label{fig:ast-f}
\end{figure}
\normalsize

The recursion rule {\tt recS} corresponding to figure~\ref{fig:ast-f} is given as follows.
\begin{center}
\begingroup
\begin{BVerbatim}
  recS : S → 
    (C : Set) →
    (cbase : C) →
    (cloop : cbase ≡ cbase) →
    C
\end{BVerbatim}
\endgroup
\end{center}

The automation tool builds the computation rule for the point constructor {\tt base} using the same approach as described in sec.~\ref{sec:sec3.1}. Additionally, it includes variables in the {\tt clause} definition for the path constructor {\tt loop}. The tool builds the computation rule {\tt βrecS} for the path constructor {\tt loop} using {\tt ap}. The type of {\tt βrecS} is given as follows.

\begin{center}
\begingroup
\begin{BVerbatim}

    βrecS : (C : Set) → (cbase : C) → 
      (cloop : cbase ≡ cbase) → 
      ap (λ x → recS x C cbase cloop) loop 
      ≡ cloop
\end{BVerbatim}
\endgroup
\end{center}

The application of function {\tt recS} to the path {\tt loop} substitutes the point {\tt base} for the lambda argument {\tt x}, and it evaluates to the path {\tt cloop} in the output type {\tt C}. The automation tool uses {\tt declarePostulate} primitive to introduce {\tt βrecS} as a postulate. We implement the {\tt generateRecHit} interface as given in figure~\ref{fig:generateRecHit}.

\begin{figure}
\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}
(agda-sort (lit 0) [ "C" v]⇒
 (var 0 [] [ "cbase" v]⇒
  (def (quote _≡_)
   (vArg (var 0 []) :: vArg (var 0 []) :: [])
   [ "cloop" v]⇒
   def (quote _≡_)
   (vArg
    (def (quote ap)
     (vArg
      (lam visible
       (abs "x"
        (def (quote recS)
         (vArg (var 0 []) ::
          vArg (var 3 []) :: vArg (var 2 []) :: 
          vArg (var 1 []) :: []))))
      :: vArg (def (quote loop) []) :: []))
    :: vArg (var 0 []) :: []))))
\end{Verbatim}
\endgroup
\end{center}
\caption{AST representing the action of function {\tt recS} on path {\tt loop}}
\label{fig:ast-beta-f}
\end{figure}
\normalsize

\begin{figure}
\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}
generateRecHit : 
  Arg Name → List (Arg Name) →
  (baseType : Name) → (indexList : List Nat) →
  (baseRec : Name) → (indType : Name) →
  (points : List Name) → 
  (paths : List Name) → TC ⊤
generateRecHit (arg i f) argD b il br i p1 p2 =
  do lcons ← getConstructors b
     lpoints ← getLength p1
     lpaths ← getLength p2
     clauses ← getPathClause lpoints lpaths br
     RTy ← getType baseType
     fTy ← getRtypePath b i br il p2 zero RTy
     declareDef (arg i f) fTy
     defineFun f clauses
     generateβRecHit argD b il br i f p1 p2
\end{Verbatim}
\endgroup
\end{center}
\caption{Implementation for {\tt generateRecHit}}
\label{fig:generateRecHit}
\end{figure}
\normalsize

{\tt generateRecHit} takes the base type recursion rule as input and uses that to eliminate the points during the construction of the path methods in the recursor $G_{rec}$. The second argument {\tt argD} is a list of terms representing the computation rules for the path constructors. The {\tt generateβRecHit} interface takes {\tt argD} as input and builds the computation rule for the path constructors. Other inputs to {\tt generateRecHit} are the point and path holders declared during the higher inductive type definition.

\subsection{Dependent Eliminator}
\label{sec:sec4.3}

Dependent eliminator or the induction principle of a higher inductive type $G$ is a dependent function that maps an element $g$ of $G$ to an output type $C \, g$. The general schema for the induction principle of $G$ is given as follows.
\begin{align*}
G_{\mathit{ind}} : & (a_1 : A_1) \to \ldots \to (a_n : A_n) \to\\
& (i_1 : I_1) \to \ldots \to (i_m : I_m) \to\\
& (\mathit{tgt} : G\ a_1 \ldots a_n\ i_1\ \ldots\ i_n) \to\\
& \begin{array}{@{}l@{}l}(\mathit{C} :\ & (i_1 : I_1) \to \ldots \to (i_m : I_m) \to\\  & G\ a_1 \ldots a_n\ i_1\ \ldots\ i_n \to\\ &\SET{})\to\end{array} \\
& (\mathit{f_1} : \Delta_1^\prime \to \mathit{C}\ j_{11} \ldots j_{1p}\ (c_1\ \overline{\Delta_1})) \to \\
& (\mathit{f_r} : \Delta_r^\prime \to \mathit{C}\ j_{r1} \ldots j_{rp}\ (c_r\ \overline{\Delta_r})) \to \\
& (\mathit{k_1} : \Delta_1^\prime \to transport \, \mathit{C} \, p_1 \, (f_i \ldots) \equiv (f_j \ldots)) \to \\
& (\mathit{k_r} : \Delta_r^\prime \to transport \, \mathit{C} \, p_r \, (f_i \ldots) \equiv (f_j \ldots)) \to \\
& \mathit{C}\ i_1\ \ldots\ i_n\ \mathit{tgt}
\end{align*}

Similar to $G_{rec}$, the type of $f_i$ is built the same way as for the normal inductive type $D$. The automation tool builds the type of $k_i$, method for path constructor $p_i$ in $G_{ind}$, by traversing the AST of $p_i$. During the traversal, the automation tool uses the base eliminator $D_{ind}$ to map the point constructors $g_i$ of $G$ in the codomain of $p_i$ to $f_i$. In the first argument to the identity type in the codomain of $k_i$, the automation tool adds the quoted {\tt name} of {\tt transport}, reference to the motive {\tt C}, and the path $p_i$. The arguments of $k_i$ are handled the same way as for $f_i$. The schema for the computation rules corresponding to paths $p_i$ is given as follows.
\begin{align*}
\beta G_i : & (a_1 : A_1) \to \ldots \to (a_n : A_n) \to\\
& \begin{array}{@{}l@{}l}(\mathit{C} :\ & (i_1 : I_1) \to \ldots \to (i_m : I_m) \to\\  & G\ a_1 \ldots a_n\ i_1\ \ldots\ i_n \to\\ &\SET{})\to\end{array} \\
& (\mathit{f_1} : \Delta_1^\prime \to \mathit{C}\ j_{11} \ldots j_{1p}\ (c_1\ \overline{\Delta_1})) \to \\
& (\mathit{f_r} : \Delta_r^\prime \to \mathit{C}\ j_{r1} \ldots j_{rp}\ (c_r\ \overline{\Delta_r})) \to \\
& (\mathit{k_1} : \Delta_1^\prime \to transport \, \mathit{C} \, p_1 \, (f_i \ldots) \equiv (f_j \ldots)) \to \\
& (\mathit{k_r} : \Delta_r^\prime \to transport \, \mathit{C} \, p_r \, (f_i \ldots) \equiv (f_j \ldots)) \to \\
& \mathit{apd} \, (\lambda \, x \to G_{ind} \, x \, C \, f_1 \, f_r \, k_1 \, k_r) \, (p_i \ldots) \equiv (k_i \ldots)
\end{align*}

The automation tool builds the type of $\beta G_{ind}$ using the same approach as for the induction rule $G_{ind}$. The type of $G_{ind}$ and $\beta G_{ind}$ is similar except for the mapping $(g : G) \to C g$ in $G_{ind}$ which is replaced by the term representing the action of function $G_{ind}$ on the path $(p_i \, \ldots)$. The function {\tt apd} (sec. \ref{sec:sec2.2}) applies $G_{ind}$, which is nested inside a lambda function, on the path $(p_i \ldots)$.

For the type {\tt S} with point constructor {\tt base} and path constructor {\tt loop}, to define a mapping {\tt indS : (x : S) → C x}, we need {\tt cbase : C base} and {\tt cloop : transport C loop cbase ≡ cbase}, where {\tt cloop} is a heterogeneous path transported over {\tt loop}. The automation tool builds the type of {\tt cloop} by traversing the abstract syntax tree of {\tt loop} and adding relevant type information into it. For the codomain of {\tt cloop}, which is an identity type, we insert the quoted {\tt name} of {\tt transport} with arguments {\tt C}, {\tt loop} and {\tt cbase}. The automation tool applies the eliminator of base type {\tt S*} to map {\tt base} to {\tt cbase} during the construction of the codomain of {\tt cloop}. The following declaration gives the type of {\tt indS}.
\begin{center}
\begin{BVerbatim}
indS : (circle : S) → 
  (C : S → Set) →
  (cbase : C base) →
  (cloop : transport C loop cbase ≡ cbase) →
  C circle
\end{BVerbatim}
\end{center}

The computation rule for {\tt base}, which defines the action of {\tt indS} on {\tt base}, is built using the same approach as for the non-dependent eliminator {\tt recS}. The computation rule {\tt βindS} for the path {\tt loop} is built using {\tt apd} which gives the action of dependent function {\tt indS} on the path {\tt loop}.
\begin{center}
\begin{BVerbatim}
βindS : (C : S → Set) → 
  (cbase : C base) → 
  (cloop : transport C loop cbase ≡ cbase) → 
  apd (λ x → indS x C cbase cloop) loop ≡ cloop
\end{BVerbatim}
\end{center}

Figure~\ref{fig:generateIndHit} gives the implementation of {\tt generateIndHit} interface in the automation tool. {\tt generateβIndHit} builds the computation rule for the path constructors.

\begin{figure}
\begin{center}
%\begingroup
\begin{Verbatim}
generateIndHit : Arg Name → List (Arg Name) →
  (baseType : Name) → (indLs : List Nat) →
  (baseElm : Name) → (indType : Name) →
  (points : List Name) → 
  (paths : List Name) → TC ⊤
generateIndHit (arg i f) argD b il br i p1 p2 =
  do il' ← getIndex b il
     lcons ← getConstructors b
     lp1 ← getLength p1
     lp2 ← getLength p2
     clauses ← getPathClauseDep lp1 lp2
                 b br il' lcons
     RTy ← getType b
     fTy ← getRtypePathDep b i br
             p1 p2 zero il' RTy
     declareDef (arg i f) fTy
     defineFun f clauses
     generateβIndHit argD b il br i f p1 p2
\end{Verbatim}
%\endgroup
\end{center}
\caption{Implementation for {\tt generateIndHit}}
\label{fig:generateIndHit}
\end{figure}
\normalsize


\section{Application}

The field of homotopy type theory is less well-developed on the programming side. There are only few programming applications of homotopy type theory, and the role of computationally relevant equality proofs on programming is an area of active research. Applications such as homotopical patch theory \cite{Angiuli-2014} discuss the implementation of Darcs \cite{Darcs-2005} version control system using patch theory \cite{Mimram-2013} \cite{Jason-2009} in the context of homotopy type theory. Containers in homotopy type theory \cite{Altenkirch-2014} \cite{Abbott-2005} implement data structures such as multisets and cycles. The automation tool discussed in this paper abstracts away the difficulties involved in the implementation of a higher inductive type and its elimination rules. It introduces interfaces which simplify the intricacies of a higher inductive type definition and usage by automating the generation of the code segments defining the higher inductive type and its elimination rules. The automation tool is significant in reducing the development effort for existing applications, and it can also attract new programming applications in homotopy type theory.

%In the next section, we discuss the implementation of patch theory application in Agda and exhibit a tremendous reduction in code size using the automation tool. In section \ref{crypto}, we present a cryptography application and discuss how to abstract the implementation difficulties of a higher inductive type making it more accessible to the cryptographers.

\subsection{Patch Theory Revisited}
\label{patch-theory}

A patch is a syntactic representation of a function that modifies a repository context when applied. For example, a patch $(s1 \leftrightarrow s2 \, @ \, l)$, which replaces string s1 with s2 at line l, when applied to a repository context with string s1 at line l results in a repository context with string s2 at line l. In homotopical patch theory \cite{Angiuli-2014}, the patches are modeled as paths in a higher inductive type. The higher inductive type representation of patches automatically satisfy groupoid laws such as the composition of patches is associative, and inverse composes to identity. Domain-specific laws related to the patches such as two swaps at independent lines commute are designed as higher dimensional paths. The computation content of the patches is extracted by mapping them to bijections in the universe with the help of univalence. Due to the functoriality of mappings in type theory, the functions preserve the path structures in their mapping to the universe.

We developed the patch theory application in Agda using Licata's method \cite{Licata-2011}. We implemented basic patches like the insertion of a string as line l1 in a file and deletion of a line l2 from a file. The functions implementing insertion and deletion in the universe are not bijective. So, to map the paths representing the patches insert and delete into the universe, we used the patch history approach \cite{Angiuli-2014}. According to this approach, we developed a separate higher inductive type $History$ which serves as the types of patches. In addition to basic patches, we also implemented patches of encryption using cryptosystems like rsa \cite{Rivest-1978} and paillier \cite{Paillier-1999}.

We used the automation tool described in this paper to generate code for the higher inductive type definition representing $History$ and the repository context $cryptR$ for the patches. We also automated the code generation for the elimination and the computation rules for the higher inductive types $History$ and $cryptR$. In addition to abstracting the implementation difficulties of higher inductive types, the automation tool helped us to achieve an extensive reduction in the code size of the original application. We were able to automate the generation of approximately 1500 lines of code with just about 70 lines of automation code. The automation massively reduced the code size of the application which is about 2500 lines resulting in 60\% reduction in the original code size.

\subsection{Cryptography}
\label{crypto}

The work of \cite{Paventhan-2018} applies the tools of homotopy type theory for cryptographic protocol implementation. It introduces a new approach for the formal specification of cryptographic schemes using types. The work discusses modeling $cryptDB$ \citep{Popa-2011} using a framework similar to patch theory. CryptDB employs layered encryption techniques and demonstrates computation on top of encrypted data. We can implement cryptDB by modeling the database queries as paths in a higher inductive type and mapping the paths to the universe using singleton types \cite{Angiuli-2014}. The automation tool can be applied to generate code for the higher inductive type representing cryptDB and its corresponding elimination and computation rules. By using the automation tool, we can abstract the convolutions of homotopy type theory thus making it more accessible to the broad community of cryptography.

A formal specification of a cryptographic construction promises correctness of properties related to security and implementation. The downside of formal specification is that it introduces a framework which requires expert knowledge on theorem proving and a strong mathematical background. By automating the code constructions for the mathematical part such as the higher inductive type implementation, we simplify formal specification to a considerable extent and make it more accessible to regular programmers without a strong mathematical background.

\section{Related Work}

There are other works which use the Agda's reflection library for performing different meta-programming tasks. \emph{Auto in Agda} \cite{Kokke-2015} implements a library for proof search using Agda's reflection primitives. It discusses implementing a Prolog interpreter in the style of Stutterheim et al \cite{Stutterheim-2013}. It employs a hint database, associated with a customizable depth-first traversal, with lemmas to assist in the proof search. The implementation of \emph{Auto in Agda} used an older version of Agda's reflection library which does not include the support for elaborator reflection. 

The work of \cite{Walt-2013} \cite{Walt-2012} discusses automating specific categories of proofs using \emph{proof by reflection}. It presents \emph{Autoquote}, an Agda library, for translation of a quoted expression, based on a conversion table, to a representation defined by the user using a non-dependent datatype. It gives an overview of a prior version of Agda's reflection library and also sites its limitations such as the inability to introduce top-level definitions. However, the new Agda reflection library has addressed a lot of those limitations.

\section{Conclusion and Future Work}

We presented an automation tool developed using the new reflection library of Agda extended with support for elaborator reflection. Our automation tool handles code generation for inductive types with constructors taking zero arguments, one or more arguments, and type being defined itself as an argument. We simplified the syntax for defining higher inductive types through the mechanized construction of the boiler-plate code segments. By automating the generation of the elimination and the computation rules associated with a higher inductive type, we demonstrated an extensive reduction in code size and abstraction of difficulties involved in implementing and using the higher inductive type. Next, we intend to extend the tool to support higher-dimensional paths in the definition of the higher inductive type. Also, we would like to automate code generation for more members of the inductive type family such as the inductive-inductive type and the inductive-recursive type.


\bibliographystyle{ACM-Reference-Format}
\bibliography{sigproc}

\end{document}
