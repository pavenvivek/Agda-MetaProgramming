\documentclass[sigplan,10pt]{acmart}
\settopmatter{printfolios=true,printccs=false,printacmref=false}

\usepackage{booktabs} % For formal tables
%\usepackage{breqn}


% Copyright
%\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
\setcopyright{none}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}


\acmConference[TyDe'18]{ACM SIGPLAN Workshop on Type-Driven Development}{September 27, 2018}{St. Louis, MO, USA}
\acmYear{2018}
%\acmISBN{} % \acmISBN{978-x-xxxx-xxxx-x/YY/MM}
%\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption

\usepackage{bbm}
\usepackage[greek,english]{babel}

% This handles the translation of unicode to latex:
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{autofe}
\usepackage{fixltx2e}

\DeclareUnicodeCharacter{8988}{\ensuremath{\ulcorner}}
\DeclareUnicodeCharacter{8989}{\ensuremath{\urcorner}}
\DeclareUnicodeCharacter{8803}{\ensuremath{\overline{\equiv}}}
%\DeclareUnicodeCharacter{11820}{\ensuremath{\urcorner}}
%\DeclareUnicodeCharacter{8759}{\ensuremath{\urcorner}}

\usepackage{amsmath}
\usepackage{fancyvrb}
\usepackage[euler]{textgreek}
\usepackage{textcomp}
\usepackage{relsize}
\usepackage{mathabx}
\usepackage{amssymb}
\usepackage{mathtools}

\renewcommand{\theFancyVerbLine}{%
  \sffamily
  \textcolor[rgb]{0,0.7,0}{%
    \tiny{%
      \arabic{FancyVerbLine}%
    }
  }%
}


\begin{document}
\title{Automating Code Generation for Higher Inductive Types}
                                        %% when present, will be used in
                                        %% header instead of Full Title.
%\titlenote{with title note}             %% \titlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'
%\subtitle{Automating Code Generation for Higher Inductive Types}                     %% \subtitle is optional
%\subtitlenote{with subtitle note}       %% \subtitlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{Paventhan Vivekanandan}
%\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  %\position{Position1}
  \department{School of Informatics, Computing and Engineering}  %% \department is recommended
  \institution{Indiana University Bloomington} %% \institution is required
  %\streetaddress{Street1 Address1}
  %\city{City1}
  %\state{State1}
  %\postcode{Post-Code1}
  \country{USA}                    %% \country is recommended
}
\email{pvivekan@indiana.edu}          %% \email is recommended

%% Author with two affiliations and emails.
\author{David Christiansen}
%\authornote{with author2 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
%\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
%  \position{Position2a}
  \department{School of Informatics, Computing and Engineering}             %% \department is recommended
  \institution{Indiana University Bloomington} %% \institution is required
  %\streetaddress{Street2a Address2a}
  %\city{City2a}
  %\state{State2a}
  %\postcode{Post-Code2a}
  \country{USA}                   %% \country is recommended
}
\email{davidchr@indiana.edu}         %% \email is recommended
%\affiliation{
%  \position{Position2b}
%  \department{Department2b}             %% \department is recommended
%  \institution{Institution2b}           %% \institution is required
%  \streetaddress{Street3b Address2b}
%  \city{City2b}
%  \state{State2b}
%  \postcode{Post-Code2b}
%  \country{Country2b}                   %% \country is recommended
%}
%\email{first2.last2@inst2b.org}         %% \email is recommended



% The default list of authors is too long for headers}
%\renewcommand{\shortauthors}{B. Trovato et al.}


\begin{abstract}
This paper provides a sample of a \LaTeX\ document which conforms,
somewhat loosely, to the formatting guidelines for
ACM SIG Proceedings. 
\end{abstract}

%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below. 
%
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003456.10003457.10003521.10003525</concept_id>
<concept_desc>Social and professional topics~History of programming languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~General programming languages}
\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code

\keywords{ACM proceedings, \LaTeX, text tagging}

\maketitle

\section{Introduction}

\label{sec:intro}
Type theory, a foundational language of mathematics, is a functional programming language and a theorem prover. We can view a type in type theory as a topological space in homotopy theory or a groupoid in a category theory. Elements of a type corresponds to points in a topological space and elements of identity type corresponds to paths in a topological space. Homotopy type theory extends Martin-Löf’s intensional type theory by adding the notion of higher inductive type and univalence axiom. A higher inductive type is a general schema for defining new types using constructors for points and paths. The paths specified by a higher inductive type are realized by equivalences in the universe, and the mapping of paths to equivalences is made possible by univalence axiom \cite{HoTT-2013}.

Proof assistants like Coq \cite{Coq-2009} and Agda \cite{Agda-2007} does not have built-in mechanisms to support the specification of higher inductive types. However, we can work with higher inductive types in Coq and Agda by postulating them using axioms. In this approach, the elimination rule acting on the higher inductive type does not compute. Dan Licata suggested an alternative method to work with higher inductive types using type abstraction \cite{Licata-2011}. It involves defining a higher inductive type using an abstract type inside a module. The module consists of a boiler-plate code segment which defines the higher inductive type using a private base type. Inside the module, the recursion and the induction principles acts on the constructors of the private base type. The abstract type is then exported allowing the reduction rules for point constructors to hold definitionally.

Agda is a proof-assistant based on Martin-Löf’s intensional type theory. In Agda, a metaprogram, which is a programs used to construct other programs, runs in a built-in type checking monad. Inspired by Idris’s elaborator \cite{David-2016}, Agda’s reflection library expose an interface to the type checker using the type checking monad which allows for the construction of more interesting metaprograms. The type checking monad provides the interface to the Agda type checker through a set of primitive operations which can be used to retrieve static type information regarding various code segments. The primitive operations can also be used to build code fragments using constructs of abstract syntax tree, and to convert an abstract syntax tree to its concrete syntax.

In this paper, we discuss a tool used to automate the generation of bolier-plate code segments of the higher inductive type and its reduction rules. This tool extensively uses the Agda reflection library and it builds the abstract syntax tree of the code segments with static type informations obtained using the reflection primitives. The generated code is then brought into scope by another top-level reflection primitive. More specifically, we discuss the following contributions.

\begin{itemize}
\item We introduce a tool to automate construction of the recursion and the induction principles for inductive types with constructors taking zero arguments, one or more arguments, and the type being defined itself as an argument.

\item We discuss the automation of code generation of boiler-plate code for a higher inductive type defined inside a module. The boiler-plate code depends on a base type defined as private inside the module. The constructors of the private base type are not accessible outside the module.

\item We discuss the automation of code generation of the elimination and the computation rules for a higher inductive type with point and path constructors. We demonstrate the code generation of the reduction rules, specified as postulates, for the path constructors of the higher inductive type.

\item We discuss the automation of code generation for patch theory \cite{Angiuli-2014} implementation enriched with patches of encryption. 

\end{itemize}

We automated the code generation of approximately 1500 lines of code of the patch theory implementation with just 70 lines of automation code. The automation code extensively uses the static type information queried from the type checker using the reflection primitives.

\section{Background}
\label{sec:sec2}

\subsection{Higher Inductive Type}
\label{sec:sec2.1}

In homotopy type theory, an element of an \emph{identity type} is used to model the notion of a path in a topological space or a morphism in a groupoid. An element of an identity type $a =_A b$ states that $a$ and $b$ are propositionally equal. In type theory, \emph{propositional equality} is a proof-relevant notion of equality, internal to the theory, expressed by identity types. We also have a proof-irrelevant notion of equality, external to the theory, known as \emph{judgmental equality} or \emph{definitional equality}. Definitional equality is used to express equality by definition. For instance, when we have a function $f : Nat \rightarrow Nat$ defined as $f(x) = x^2$ then the expression $f(3)$ is definitionally equal to $3^2$. 

A higher inductive type extends normal inductive type by providing constructors for generating paths in addition to providing constructors for generating points. For example, consider the following higher inductive type definition of circle.

\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = lines, rulecolor=\color{blue}, numbers = left, numbersep = 0pt]

  data Circle : Set where
    base : Circle         -- point constructor
    loop : base ≡ base    -- path constructor

\end{Verbatim}
\endgroup
\end{center}

In Agda and Coq, we don't have built-in primitives to support the definition of {\tt Circle}. However, the higher inductive types including {\tt Circle} can be specified using Dan Licata's method \cite{Licata-2011}. According to this method, a higher inductive type is defined using type abstraction. For example, {\tt Circle} is defined using Dan Licata's method as follows. 

\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = lines, rulecolor=\color{blue}, numbers = left, numbersep = 0pt]

  module Circle where
    private
      data S* : Set where
        base* : S*

    S : Set
    S = S*

    base : S
    base = base*
	   
    postulate
      loop : base ≡ base

\end{Verbatim}
\endgroup
\end{center}

Inside the module {\tt Circle}, the type {\tt S} is defined using a private type {\tt S*}. The constructor {\tt base} is defined using {\tt base*} and the path {\tt loop} is given as a propositional equality. The recursion and the induction principles are defined to pattern match on the constructor {\tt base*} of the type {\tt S*}. The clients of {\tt Circle} will not have access to the constructor {\tt base*} of the private type {\tt S*} as it is not visible outside the module. The clients only way of access to the constructor is through the elimination rules {\tt recS} and {\tt indS} defined as follows. 

\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = lines, rulecolor=\color{blue}, numbers = left, numbersep = 0pt]

    recS : {C : Set} → 
      (cbase : C) → 
      (cloop : cbase ≡ cbase) → 
      S → C
    recS cbase cloop base* = cbase
 
    indS : {C : S → Set} → 
      (cbase : C base) → 
      (cloop : transport C loop cbase ≡ cbase) → 
      (circle : S) → C circle
    indS cbase cloop base* = cbase

\end{Verbatim}
\endgroup
\end{center}

{\tt recS} and {\tt indS} ignores the path argument and simply computes to the appropriate answer for the point constructor. The computational behavior for the path constructor loop is postulated using reduction rules {\tt βrecS} and {\tt βindS} defined as follows.

\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = lines, rulecolor=\color{blue}, numbers = left, numbersep = 0pt]

    postulate
      βrecS : {C : Set} → 
        (cbase : C) → 
        (cloop : cbase ≡ cbase) → 
        ap (recS cbase cloop) loop ≡ cloop

      βindS : {C : S → Set} → 
        (cbase : C base) →
        (cloop : transport C loop cbase ≡ cbase) → 
        apd (indS {C} cbase cloop) loop ≡ cloop

\end{Verbatim}
\endgroup
\end{center}

\subsection{Agda Reflection}
\label{sec:sec2.2}
Agda has a reflection library that enables compile time meta-programming. The reflection library provides an interface to the Agda type checker through a built-in type checking {\tt TC} monad. Using the reflection library and its meta-programming interface, we can convert a code fragment to its corresponding abstract syntax tree, and we can also convert the abstract representation back to its concrete agda code. Internally, agda translates the reflection code to a unique reflection syntax. The core library of Agda is enriched with functions supporting translations from reflection syntax to abstract syntax and from abstract syntax to concrete syntax and vice-versa. In this section, we will see usage examples for some of the primitive operations specified in the Agda reflection library which are used by the tool described in this paper. More information on the reflection library can be found in the Agda documentation \cite{Agda-doc-2017}.

In Agda, macros are used to construct a metaprogram that executes in a {\tt Term} position. Macros are functions of type {\tt t1 → t2 → ... → Term → TC ⊤} defined inside a macro block. During a macro invocation, the last argument of type {\tt Term} is provided by the type checker, and it represents the metavariable instantiated with the result of the macro invocation. Also, the arguments of type {\tt Term} and {\tt Name} are automatically quoted. For example, consider the following macro invocation on an identity function.

%, fontsize=\relsize{-0.5}
\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = lines, rulecolor=\color{blue}, numbers = left, numbersep = 0pt]

  macro
    mc1 : Term → Term → TC ⊤
    mc1 exp hole = bindTC (quoteTC exp) 
                     (λ exp' → unify hole exp')

  sampleTerm : Term
  sampleTerm = mc1 (λ (n : Nat) → n) 

\end{Verbatim}
\endgroup
\end{center}

The value of {\tt sampleTerm} is as follows: 
%\begin{Verbatim}[fontsize=\relsize{-0.5},commandchars=\\\{\}]
\begin{equation}
	lam \, visible \, (abs \, "n" \, (var \, 0 \, []))
\end{equation}

In (1), the constructor \emph{lam} encodes the abstract representation of the identity function. The argument {\tt n} is represented as explicit and the body of the lambda function refers to {\tt n} using de-bruijn index.   

{\tt Term} is the central type that defines an abstract syntax tree representation for the Agda terms. It is mapped to the AGDATERM built-in. The surface syntax for reflection primitives is not fixed, and so they are mapped to their corresponding built-ins, using BUILTIN pragma, to inform the type checker about the reflection concept being defined. In the above macro, the {\tt quoteTC} primitive converts a concrete agda syntax into its {\tt Term} representation. {\tt unify} performs the unification of two terms and attempts to solve any meta variables present during the unification process. {\tt bindTC} unwraps the result of {\tt (quoteTC exp)}, which is captured in {\tt exp'}, and passes it to {\tt unify} for the unification process.

The {\tt unquoteTC} primitive converts the abstract syntax tree representation of {\tt Term} into its concrete Agda syntax. Consider the following example:

\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = lines, rulecolor=\color{blue}, numbers = left, numbersep = 0pt]

  macro
    mc2 : Term → Term → TC ⊤
    mc2 exp hole = bindTC (unquoteTC exp) 
                     (λ exp' → unify hole exp')

  sampleSyntax : Nat → Nat
  sampleSyntax = mc2 (lam visible (abs "n" (var 0 [])))

\end{Verbatim}
\endgroup
\end{center}

Macro {\tt mc2} converts the abstract representation of the identity function given by (1) to its concrete syntax. We also have a type {\tt Name}, an internal identifier mapped to a built-in type {\tt QName}. In Agda, {\tt Name} literals are created using {\tt quote} primitive.

Metaprograms to create top-level definitions are brought into scope and executed using {\tt unquoteDecl} or {\tt unquoteDef} primitive. A function of a given type is declared using {\tt declareDef}, and is later defined by {\tt defineFun}. A postulate of a given type is defined using {\tt declarePostulate}. Newly defined functions and postulates are brought into scope and executed by {\tt unquoteDecl}. The usage of {\tt declareDef}, {\tt defineFun} and {\tt unquoteDecl} is best illustrated with the following example:

\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = lines, rulecolor=\color{blue}, numbers = left, numbersep = 0pt]

  plus : Nat → Nat → Nat
  plus zero b = b
  plus (suc n) b = suc (plus n b)

\end{Verbatim}
\endgroup
\end{center}
The above function computes addition of two natural numbers. It can be defined using Agda reflection primitives as follows: 

\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = lines, rulecolor=\color{blue}, numbers = left, numbersep = 0pt]

   pattern vArg x = arg (arg-info visible relevant) x
   pattern _`⇒_ a b = pi (vArg a) (abs "_" b)
   pattern `Nat = def (quote Nat) []

   unquoteDecl plus =
     bindTC (declareDef (vArg plus) (`Nat `⇒ `Nat `⇒ `Nat)) λ _ → 
         defineFun plus
           (clause (vArg (con (quote zero) []) ::
                         vArg (var "y") :: [])
              (var 0 []) ::
            clause (vArg (con (quote suc)
                         (vArg (var "x") :: [])) ::
               vArg (var "y") :: [])
               (con (quote suc)
                    (vArg
                        (def plus
                           (vArg (var 1 []) ::
                            vArg (var 0 []) :: [])) :: [])) :: [])

\end{Verbatim}
\endgroup
\end{center}

In the above code, {\tt declareDef} declares the type of {\tt plus} using the constructor {\tt pi}, and {\tt defineFun} uses the declared type information to define the clauses for {\tt plus} using constructors {\tt con} and {\tt def}. Finally, the function {\tt plus} is brought into scope by {\tt unquoteDecl}. Terms use the de-bruijn index to refer to the declared variables. For example, the variable {\tt y} declared at line 10 is referenced using a de-bruijn index {\tt 0} at line 11. {\tt vArg} encodes the visibility and relevance informations of the arguments to the reflection constructs.

In the next section, we will see automation of code generation for normal inductive types. In section 4, we will see automation of code generation for higher inductive types, and in section 5, we will revisit patch theory \citep{Angiuli-2014} application and discuss automation of code generation for the higher inductive types defined to model Darc's version control system.

\section{Code Generation for Inductive Type}
\label{sec:sec3}
An inductive type {\tt X} is a type that is freely generated by a finite collection of constructors. The constructors of {\tt X} are functions with zero or more arguments and codomain {\tt X}. The constructors can also take an element of type {\tt X} itself as an argument, but only strictly positively. In Agda reflection library, {\tt data-type} of type {\tt Definition} stores the constructors of an inductive type as a list of {\tt Name}. The type of a constructor can be retrieved by giving its {\tt Name} as an input to the {\tt getType} primitive. In the following subsections, we will discuss how to use the constructor informations to generate code for the elimination rules of an inductive type. 

\subsection{Non-dependent Eliminator}
\label{sec:sec3.1}

For an inductive type \emph{W}, with a constructor \emph{g}, the recursion principle says that to define a mapping $f : W \rightarrow P$, it suffices to define the action of \emph{f} on input \emph{g}. For example, the recursion principle for {\tt Nat} says that a mapping {\tt f : Nat → P} can be given by defining the action of {\tt f} on the constructors {\tt zero} and {\tt (suc x)} for {\tt x : Nat}. 

The constructor \emph{g} can take zero or more arguments including an element of the type \emph{W}. Lets define the type of \emph{g} as follows.
\begin{equation}
g : (A \rightarrow W) \rightarrow B \rightarrow W \rightarrow W
\end{equation}

To define the action of \emph{f} on input \emph{g}, we need a function \emph{d} of the following type.
\begin{equation}
d : (A \rightarrow W) \rightarrow (A \rightarrow P) \rightarrow B \rightarrow W \rightarrow P \rightarrow P
\end{equation}

The function \emph{f} will map the constructor $g$ to $d$. To construct the type of the recursion rule for \emph{W}, we need to build the type of $d$. We can retrieve the static type information of \emph{g} using reflection primitives, and use that to construct the type of \emph{d}. The constructor {\tt pi} of type {\tt Term} encodes the abstract syntax tree (AST) representation of \emph{g} (fig.~\ref{fig:ast-g}). We can retrieve and traverse the AST of \emph{g}, and add new type information into it to build a new type representing \emph{d}.

\begin{figure}
\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = single]

   (pi (vArg 
      (pi (vArg `A) (abs "_" `W)))     -- f1 : A → W
      (abs "_" (pi (vArg `B)           -- B
      (abs "_" (pi (vArg `W)           -- W
      (abs "_" `W))))))                -- W

\end{Verbatim}
\endgroup
\end{center}
\caption{Abstract syntax tree for constructor $g$}
\label{fig:ast-g}
\end{figure}

During the traversal of the abstract syntax tree of $g$, when we identify a function {\tt f1} with codomain \emph{W}, we add a new function {\tt f2}, with the same arguments as {\tt f1} and codomain \emph{P}, to the tree. For example, in figure~\ref{fig:ast-g}, a new function is built from the first argument $A \rightarrow W$ by modifying the codomain \emph{W} to \emph{P}. The new function of type $A \rightarrow P$ is added after the function $A \rightarrow W$ as in figure~\ref{fig:ast-d}. Constant types require no modifications. Therefore, we copy \emph{B} into the new type without any changes. When the type \emph{W} occurs directly in a non-codomain position, we add the type \emph{P} next to it. Finally, we change the codomain \emph{W} of $g$ to \emph{P} resulting in an abstract syntax tree representation of $d$ (fig.~\ref{fig:ast-d}). We repeat this process for all the constructors of a given type. In the case of {\tt Nat}, we construct the output types for {\tt zero} and {\tt (suc x)} for {\tt x : Nat} using the above method.


\begin{figure}
\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = single]

   (pi (vArg 
      (pi (vArg `A) (abs "_" `W)))      -- f1 : A → W
      (abs "_" (pi (vArg 
      (pi (vArg `A) (abs "_" `P)))      -- f2 : A → P
      (abs "_" (pi (vArg `B)            -- B
      (abs "_" (pi (vArg `W)            -- W
      (abs "_" (pi (vArg `P)            -- P
      (abs "_" `P))))))))))             -- P

\end{Verbatim}
\endgroup
\end{center}
\caption{Abstract syntax tree for constructor $d$}
\label{fig:ast-d}
\end{figure}

The parameter and the index of \emph{W}, if present, should be encoded as part of the type of function \emph{f}. We can retrieve information about the parameter and the index of \emph{W} from its type. The constructors refer to the parameter and the index using de-bruijn indices. During the construction of the output type $d$, we should update the de-bruijn indices accordingly. The constructor {\tt data-type} contains the count \emph{cp} of parameters occurring in a defined type. It also encodes the constructors of the type as a list of {\tt Name}. We can retrieve the index count by finding the difference between \emph{cp} and length of the constructor list. The parameters are common to all the constructors of a type. But the index values are different for each constructor. So we have to encode unique indices for each constructor. Also, some constructors might not take the same number of indices as the parent type. For example, in the case of {\tt Vec}, the constructor {\tt []} excludes the index {\tt Nat} from its type. We do not have any reflection primitive to retrieve the index count from a constructor name. A workaround is to pass the index count of each constructor explicitly to the automation tool.

Once we have the type of $d$, we can build the type of the recursion rule for \emph{W}. To encode the mapping $W \rightarrow P$ in the recursion type we need to declare \emph{P}. We can use the constructor {\tt agda-sort} to introduce the type \emph{(P : Set)}. The type of the recursion rule \emph{f} is given as follows.
\begin{multline}
f : (P : Set) \rightarrow  \\
    \, \, \,  \, \, \,   (d : (A \rightarrow W) \rightarrow (A \rightarrow P) \rightarrow B \rightarrow W \rightarrow P \rightarrow P)
  \rightarrow \\ \, \, \,  \, \, \, W \rightarrow P
\end{multline}
 
The above type is declared using {\tt declareDef}. We can build the computation rule representing the action of function \emph{f} on $d$ using {\tt clause} (fig.~\ref{fig:ast-cdef}). The first argument to {\tt clause} encodes variables corresponding to the above type, and it also includes the abstract representation of $g$ on which the pattern matching should occur. The second argument to clause, which is of type {\tt Term}, refers to the variables in the first argument using de-bruijn indices, and it encodes the output of the action of function \emph{f} on $d$. The constructor {\tt var} in {\tt Pattern} is used to introduce new variables in the {\tt clause} definition. The type {\tt Pattern} also has another constructor {\tt con} used to represent the pattern matching term $g$. The type {\tt Term} has similar constructors {\tt var} and {\tt con}, but with different types, used to encode the output of the recursion rule. Given $\alpha : A \rightarrow W$, $\beta : B$ and $\omega : W$, the computation rule corresponding to the above type is given as follows.
\begin{equation}
f (P, d, g (\alpha, \beta, \omega)) \equiv d (\alpha, f \circ \alpha, \beta, \omega, f (\omega))
\end{equation}

\begin{figure}
\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = single]

  (clause 
    (vArg (var "P") ::                           -- P
     vArg (var "d") ::                           -- d
     vArg (con (quote g)                         -- g
            (vArg (var "alpha") ::               -- α
             vArg (var "beta") ::                -- β
             vArg (var "omega") :: [])) :: [])   -- ω
    (var 3                                       -- d
      (vArg (var 2 []) ::                        -- α
       vArg (lam visible (abs "a"                -- a
         (def f                                  -- f ∘ α
           (vArg (var 3                     
           (vArg (var 0 []) :: [])) :: []))) ::
       vArg (var 1 []) ::                        -- β
       vArg (var 0 []) ::                        -- ω
       vArg (def f (vArg (var 0 []) :: [])))))   -- f(ω)

\end{Verbatim}
\endgroup
\end{center}
\caption{Clause definition for the computation rule of \emph{W}}
\label{fig:ast-cdef}
\end{figure}

The second argument $(f \circ \alpha)$ to $d$ is the composite of function $f$ and $\alpha$. We can build a composite function inside a lambda using the constructor {\tt lam}. The arguments to {\tt lam} are referenced using de-bruijn indices inside the lambda body. So, the de-bruijn indices for referring variables outside the lambda body are updated accordingly. The clause definition, which evaluates to the above computation rule of \emph{W}, is given in figure~\ref{fig:ast-cdef}. The de-bruijn index reference increments right to left starting from the last argument $\omega$. Inside the lambda body, the reference {\tt 0} refers to the lambda argument {\tt a}, and the index references to the variables outside the lambda body starts from 1 and increments towards the left. The above clause definition is defined using {\tt defineFun} primitive, and the function \emph{f} is brought into scope by {\tt unquotedecl}. 

In the automation tool, {\tt generateRec} interface is used to generate the resursion rule $f$ for the type $W$. The implementation of {\tt generateRec} is given as follows.

\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = lines, rulecolor=\color{blue}, numbers = left, numbersep = 0pt]

  generateRec : Arg Name → Name → List Nat → TC ⊤
  generateRec (arg i f) t indLs =
    bindTC (getConstructors t) λ cns →
    bindTC (getLength cns) λ lcons →
    bindTC (getClause lcons zero t f indLs cns) λ cls →
    bindTC (getType t) λ RTy → 
    bindTC (getRtype t indLs zero RTy) λ funType →
    bindTC (declareDef (arg i f) funType) λ _ →
    (defineFun f cls)

\end{Verbatim}
\endgroup
\end{center}

{\tt generateRec} uses {\tt getClause} and {\tt getRtype} to build the computation and elimination rules respectively. It takes three arguments which consists of the function name to be defined as an element of type {\tt Arg Name}, the quoted {\tt Name} of the type \emph{W} and a list containing the index count of the individual constructors. {\tt generateRec} can be used to automate the generation of recursion rules for the inductive types with point constructors. It can be used with the constructors of inductive types that takes no arguments (eg. {\tt Bool}), one or multiple arguments (eg. coproduct, cartesian product) and the constructors that takes argument from the inductive type being defined (eg. {\tt Nat}, {\tt List}, {\tt Vec}). The recursion rule generated by {\tt generateRec} is brought into scope using {\tt unquoteDecl} as follows.

\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}
  unquoteDecl f = generateRec (vArg f) (quote W) (0 :: [])
\end{Verbatim}
\endgroup
\end{center}

The third argument to {\tt generateRec} is a list consisting of the index count for the constructors. Since the constructor $g$ does not have any index, the count is given as 0. It is required to pass the index count for each constructor explicitly as the Agda reflection library does not have built-in primitives to retrieve the index value.

\subsection{Dependent Eliminator}
\label{sec:sec3.1}

The dependent eliminator or the induction principle is used to define the behavior of a mapping $f'$ when the output type is dependent on the input element to $f'$. For the inductive type $W$, the induction principle says that to define a mapping $f' : (w : W) \rightarrow P(w)$, it suffices to define the action of $f'$ on $g$. To define the action of $f'$ on $g$, we need an element of the following type.
\begin{equation}
d' : \prod_{\alpha : A \rightarrow W} (\prod_{a : A} P(\alpha (a))) \rightarrow  \prod_{\beta : B} \prod_{\omega : W} P(\omega) \rightarrow P (g(\alpha, \beta, \omega))
\end{equation}

In the first argument of $d'$, the type $P$ depends on the action of the function $\alpha$ on input $a : A$. In the second argument, it depends on the input element $\omega : W$. The output of function $d'$ depends on the action of constructor $g$ on inputs $\alpha$, $\beta$, and $\omega$. 

To build the dependent eliminator, we need the type of the function $d'$. We can construct the abstract syntax tree of $d'$ using the static type information obtained from $g$. To construct $d'$, during the traversal of the abstract syntax tree of $g$, when we identify a function $\alpha$ with codomain \emph{W}, we add a new function with the same argument {\tt A} as in $\alpha$ and codomain \emph{P}, which depends on the action of $\alpha$ on {\tt (a : A)}. We copy the constant \emph{B} directly without any changes as in the case of the non-dependant eliminator. When we see $(\omega : W)$ in a non-codomain position, we add the type \emph{P}, which depends on the element $\omega$, next to it. Finally, the output type \emph{W} of the constructor $g$ is changed to \emph{P}, which depends on the action of the constructor $g$ on inputs $\alpha$, $\beta$ and $\omega$ (fig.~\ref{fig:ast-d'}). 

\begin{figure}
\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = single]

   (pi (vArg
      (pi (vArg `A) (abs "_" `W)))                -- α : A → W
      (abs "_" (pi (vArg                          -- A → P(α(a))
      (pi (vArg `A)                               -- a : A
      (abs "_" (var 2                             -- P(α(a))
      (vArg (var 1                                -- α ref
      (vArg (var 0 []) :: [])) :: [])))))         -- a ref
      (abs "_" (pi (vArg `B)                      -- β : B
      (abs "_" (pi (vArg `W)                      -- ω : W
      (abs "_" (pi (vArg (var 4                   -- P(ω)
      (vArg (var 0 []) :: [])))                   -- ω ref
      (abs "_" (var 5                             -- P(g i β ω)
      (vArg (con (quote g)                        -- g ref
      (vArg (var 4 []) ::                         -- α ref
       vArg (var 2 []) ::                         -- β ref
       vArg (var 1 []) :: [])) :: []))))))))))))  -- ω ref

\end{Verbatim}
\endgroup
\end{center}
\caption{Abstract syntax tree for constructor $d'$}
\label{fig:ast-d'}
\end{figure}

We can construct the type of the induction principle $f'$ using $d'$ . The type \emph{P} in the mapping $f'$ depends on the element of the input type \emph{W}. The following equation gives the type of the induction principle $f'$.
\begin{multline}
f' : (P : W \rightarrow Set) \rightarrow \\
(d' : \prod_{\alpha : A \rightarrow W} (\prod_{a : A} P(\alpha (a))) \rightarrow \prod_{\beta : B} \prod_{\omega : W} P(\omega) \rightarrow \\ P (g(\alpha, \beta, \omega)))
  \rightarrow \\ (w : W) \rightarrow P (w)
\end{multline}

The computation rule for the above type is the same as the computation rule of the recursion principle of \emph{W} except that the function \emph{f} and $d$ are changed to \emph{f'} and $d'$ respectively. It is constructed using {\tt clause} definitions using the same approach as the recursion principle. The computation rule corresponding to \emph{f'} is given as follows.
\begin{equation}
f' (P, d', g (\alpha, \beta, \omega)) \equiv d' (\alpha, f' \circ \alpha, \beta, \omega, f' (\omega))
\end{equation}

We can automate the generation of the induction rule $f'$ for the type \emph{W} using {\tt generateInd} interface. The implementation of {\tt generateInd} is given as follows:

\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}[frame = lines, rulecolor=\color{blue}, numbers = left, numbersep = 0pt]

  generateInd : Arg Name → Name → List Nat → TC ⊤
  generateInd (arg i f) t indLs =
    bindTC (getIndex’ t indLs) λ indLs' →
    bindTC (getConstructors t) λ cns →
    bindTC (getLength cns) λ lcons →
    bindTC (getClauseDep lcons zero t f indLs' cns) λ cls →
    bindTC (getType t) λ RTy →
    bindTC (getRtypeInd t zero indLs' RTy) λ funType → 
    bindTC (declareDef (arg i f) funType) λ _ →
    (defineFun f cls)

\end{Verbatim}
\endgroup
\end{center}

{\tt generateInd} uses {\tt getClauseDep} to generate the {\tt clause} definitions representing the computation rule of the type \emph{W}. The abstract representation of the type of \emph{W} is provided by {\tt getRtypeInd}. $f'$ generated by {\tt generateInd} is brought into scope by {\tt unquoteDecl} as follows.

\begin{center}
\begingroup
\fontsize{7pt}{9pt}\selectfont
\begin{Verbatim}

  unquoteDecl f' = generateInd (vArg f') (quote W) [] 

\end{Verbatim}
\endgroup
\end{center}

We pass an empty list to {\tt generateInd} as the type \emph{W} has no index. We can also pass an empty list if all the constructors of a type has the same number of index as the parent type. But if any one constructor has an index count different from the index count of the parent type, then we have to explicitly pass the index count of all the constructors.

\bibliographystyle{ACM-Reference-Format}
\bibliography{sigproc} 

\end{document}
